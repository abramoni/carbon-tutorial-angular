{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-dropdown.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { position } from '@carbon/utils-position';\nimport { Subscription, of, fromEvent, Observable, isObservable } from 'rxjs';\nimport { debounceTime, map, filter, first } from 'rxjs/operators';\nimport { Input, Output, EventEmitter, Directive, Injectable, Component, ElementRef, ContentChild, ViewChild, HostListener, HostBinding, TemplateRef, ViewChildren, ApplicationRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { I18n, I18nModule } from 'carbon-components-angular/i18n';\nimport { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';\nimport { AnimationFrameService, closestAttr, ElementService, getScrollableParents, hasScrollableParents, UtilsModule } from 'carbon-components-angular/utils';\nimport { IconModule } from 'carbon-components-angular/icon';\n/**\n * A component that intends to be used within `Dropdown` must provide an implementation that extends this base class.\n * It also must provide the base class in the `@Component` meta-data.\n * ex: `providers: [{provide: AbstractDropdownView, useExisting: forwardRef(() => MyDropdownView)}]`\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'carbon-components-angular/placeholder';\nimport * as ɵngcc2 from 'carbon-components-angular/utils';\nimport * as ɵngcc3 from 'carbon-components-angular/i18n';\nimport * as ɵngcc4 from '@angular/common';\nimport * as ɵngcc5 from 'carbon-components-angular/icon';\nconst _c0 = [\"dropdownButton\"];\nconst _c1 = [\"dropdownMenu\"];\n\nfunction Dropdown_label_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r13.label);\n  }\n}\n\nfunction Dropdown_label_0_2_ng_template_0_Template(rf, ctx) {}\n\nfunction Dropdown_label_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Dropdown_label_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r14.label);\n  }\n}\n\nconst _c2 = function (a0) {\n  return {\n    \"bx--label--disabled\": a0\n  };\n};\n\nfunction Dropdown_label_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"label\", 15);\n    ɵngcc0.ɵɵtemplate(1, Dropdown_label_0_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    ɵngcc0.ɵɵtemplate(2, Dropdown_label_0_2_Template, 1, 1, null, 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"for\", ctx_r0.id)(\"ngClass\", ɵngcc0.ɵɵpureFunction1(4, _c2, ctx_r0.disabled));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.isTemplate(ctx_r0.label));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.isTemplate(ctx_r0.label));\n  }\n}\n\nfunction Dropdown_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 17);\n    ɵngcc0.ɵɵlistener(\"click\", function Dropdown_div_4_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r17);\n      const ctx_r16 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r16.clearSelected());\n    })(\"keydown.enter\", function Dropdown_div_4_Template_div_keydown_enter_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r17);\n      const ctx_r18 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r18.clearSelected());\n    });\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(2, \"svg\", 18);\n    ɵngcc0.ɵɵelement(3, \"path\", 19);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"title\", ctx_r2.clearText);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r2.getSelectedCount(), \" \");\n  }\n}\n\nfunction Dropdown_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 20);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵpipe(2, \"async\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r3.getDisplayStringValue()));\n  }\n}\n\nfunction Dropdown_6_ng_template_0_Template(rf, ctx) {}\n\nfunction Dropdown_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Dropdown_6_ng_template_0_Template, 0, 0, \"ng-template\", 21);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutletContext\", ctx_r4.getRenderTemplateContext())(\"ngTemplateOutlet\", ctx_r4.displayValue);\n  }\n}\n\nfunction Dropdown__svg_svg_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"svg\", 22);\n  }\n}\n\nfunction Dropdown__svg_svg_8_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"svg\", 23);\n  }\n}\n\nconst _c3 = function (a0) {\n  return {\n    \"bx--list-box__menu-icon--open\": a0\n  };\n};\n\nfunction Dropdown__svg_svg_10_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"svg\", 24);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(2, _c3, !ctx_r7.menuIsClosed));\n    ɵngcc0.ɵɵattribute(\"aria-label\", ctx_r7.menuButtonLabel);\n  }\n}\n\nfunction Dropdown_ng_content_13_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0, 0, [\"*ngIf\", \"!menuIsClosed\"]);\n  }\n}\n\nfunction Dropdown_div_14_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r20.helperText);\n  }\n}\n\nfunction Dropdown_div_14_2_ng_template_0_Template(rf, ctx) {}\n\nfunction Dropdown_div_14_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Dropdown_div_14_2_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r21.helperText);\n  }\n}\n\nconst _c4 = function (a0) {\n  return {\n    \"bx--form__helper-text--disabled\": a0\n  };\n};\n\nfunction Dropdown_div_14_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 25);\n    ɵngcc0.ɵɵtemplate(1, Dropdown_div_14_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    ɵngcc0.ɵɵtemplate(2, Dropdown_div_14_2_Template, 1, 1, null, 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(3, _c4, ctx_r10.disabled));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r10.isTemplate(ctx_r10.helperText));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r10.isTemplate(ctx_r10.helperText));\n  }\n}\n\nfunction Dropdown_div_15_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r23.invalidText);\n  }\n}\n\nfunction Dropdown_div_15_2_ng_template_0_Template(rf, ctx) {}\n\nfunction Dropdown_div_15_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Dropdown_div_15_2_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r24.invalidText);\n  }\n}\n\nfunction Dropdown_div_15_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 26);\n    ɵngcc0.ɵɵtemplate(1, Dropdown_div_15_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    ɵngcc0.ɵɵtemplate(2, Dropdown_div_15_2_Template, 1, 1, null, 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r11.isTemplate(ctx_r11.invalidText));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r11.isTemplate(ctx_r11.invalidText));\n  }\n}\n\nfunction Dropdown_div_16_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r26 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r26.warnText);\n  }\n}\n\nfunction Dropdown_div_16_2_ng_template_0_Template(rf, ctx) {}\n\nfunction Dropdown_div_16_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Dropdown_div_16_2_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r27 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r27.warnText);\n  }\n}\n\nfunction Dropdown_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 26);\n    ɵngcc0.ɵɵtemplate(1, Dropdown_div_16_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    ɵngcc0.ɵɵtemplate(2, Dropdown_div_16_2_Template, 1, 1, null, 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r12.isTemplate(ctx_r12.warnText));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r12.isTemplate(ctx_r12.warnText));\n  }\n}\n\nconst _c5 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {\n  return {\n    \"bx--dropdown\": a0,\n    \"bx--multiselect\": a1,\n    \"bx--multi-select--selected\": a2,\n    \"bx--dropdown--light\": a3,\n    \"bx--list-box--light\": a4,\n    \"bx--list-box--inline\": a5,\n    \"bx--skeleton\": a6,\n    \"bx--dropdown--disabled bx--list-box--disabled\": a7,\n    \"bx--dropdown--invalid\": a8,\n    \"bx--dropdown--warning bx--list-box--warning\": a9,\n    \"bx--dropdown--xl bx--list-box--xl\": a10,\n    \"bx--dropdown--sm bx--list-box--sm\": a11,\n    \"bx--list-box--expanded\": a12\n  };\n};\n\nconst _c6 = function (a0) {\n  return {\n    \"a\": a0\n  };\n};\n\nconst _c7 = function (a0) {\n  return {\n    \"bx--list-box--up\": a0\n  };\n};\n\nconst _c8 = [\"*\"];\nconst _c9 = [\"list\"];\nconst _c10 = [\"listItem\"];\n\nfunction DropdownList_li_2_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 9)(1, \"label\", 10);\n    ɵngcc0.ɵɵelement(2, \"input\", 11)(3, \"span\", 12);\n    ɵngcc0.ɵɵelementStart(4, \"span\", 13);\n    ɵngcc0.ɵɵtext(5);\n    ɵngcc0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const item_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"data-contained-checkbox-state\", item_r2.selected);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"checked\", item_r2.selected)(\"disabled\", item_r2.disabled);\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵtextInterpolate(item_r2.content);\n  }\n}\n\nfunction DropdownList_li_2_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(item_r2.content);\n  }\n}\n\nfunction DropdownList_li_2__svg_svg_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"svg\", 14);\n  }\n}\n\nfunction DropdownList_li_2_6_ng_template_0_Template(rf, ctx) {}\n\nconst _c11 = function (a0) {\n  return {\n    item: a0\n  };\n};\n\nfunction DropdownList_li_2_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, DropdownList_li_2_6_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n\n  if (rf & 2) {\n    const item_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r8 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c11, item_r2))(\"ngTemplateOutlet\", ctx_r8.listTpl);\n  }\n}\n\nconst _c12 = function (a0, a1) {\n  return {\n    \"bx--list-box__menu-item--active\": a0,\n    \"bx--list-box__menu-item--highlighted\": a1\n  };\n};\n\nfunction DropdownList_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 3);\n    ɵngcc0.ɵɵlistener(\"click\", function DropdownList_li_2_Template_li_click_0_listener($event) {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r14);\n      const item_r2 = restoredCtx.$implicit;\n      const ctx_r13 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r13.doClick($event, item_r2));\n    });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 4, 5);\n    ɵngcc0.ɵɵtemplate(3, DropdownList_li_2_div_3_Template, 6, 4, \"div\", 6);\n    ɵngcc0.ɵɵtemplate(4, DropdownList_li_2_ng_container_4_Template, 2, 1, \"ng-container\", 7);\n    ɵngcc0.ɵɵtemplate(5, DropdownList_li_2__svg_svg_5_Template, 1, 0, \"svg\", 8);\n    ɵngcc0.ɵɵtemplate(6, DropdownList_li_2_6_Template, 1, 4, null, 7);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r2 = ctx.$implicit;\n    const i_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r1.getItemId(i_r3))(\"ngClass\", ɵngcc0.ɵɵpureFunction2(9, _c12, item_r2.selected, ctx_r1.highlightedItem === ctx_r1.getItemId(i_r3)));\n    ɵngcc0.ɵɵattribute(\"aria-selected\", item_r2.selected)(\"title\", ctx_r1.showTitles ? item_r2.content : null)(\"disabled\", item_r2.disabled ? true : null);\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.listTpl && ctx_r1.type === \"multi\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.listTpl && ctx_r1.type === \"single\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.listTpl && ctx_r1.type === \"single\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.listTpl);\n  }\n}\n\nlet AbstractDropdownView = /*#__PURE__*/(() => {\n  class AbstractDropdownView {\n    constructor() {\n      /**\n       * Specifies whether or not the `DropdownList` supports selecting multiple items as opposed to single\n       * item selection.\n       */\n      this.type = \"single\";\n      /**\n       * Specifies the render size of the items within the `AbstractDropdownView`.\n       *\n       * @deprecated since v4\n       */\n\n      this.size = \"md\";\n    }\n    /**\n     * The items to be displayed in the list within the `AbstractDropDownView`.\n     */\n\n\n    set items(value) {}\n\n    get items() {\n      return;\n    }\n    /**\n     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.\n     */\n\n\n    getNextItem() {\n      return;\n    }\n    /**\n     * Returns a boolean if the currently selected item is preceded by another\n     */\n\n\n    hasNextElement() {\n      return;\n    }\n    /**\n     * Returns the `HTMLElement` for the item that is subsequent to the selected item.\n     */\n\n\n    getNextElement() {\n      return;\n    }\n    /**\n     * Returns the `ListItem` that precedes the selected item within `DropdownList`.\n     */\n\n\n    getPrevItem() {\n      return;\n    }\n    /**\n     * Returns a boolean if the currently selected item is followed by another\n     */\n\n\n    hasPrevElement() {\n      return;\n    }\n    /**\n     * Returns the `HTMLElement` for the item that precedes the selected item.\n     */\n\n\n    getPrevElement() {\n      return;\n    }\n    /**\n     * Returns the selected leaf level item(s) within the `DropdownList`.\n     */\n\n\n    getSelected() {\n      return;\n    }\n    /**\n     * Returns the `ListItem` that is selected within `DropdownList`.\n     */\n\n\n    getCurrentItem() {\n      return;\n    }\n    /**\n     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.\n     */\n\n\n    getCurrentElement() {\n      return;\n    }\n    /**\n     * Guaranteed to return the current items as an Array.\n     */\n\n\n    getListItems() {\n      return;\n    }\n    /**\n     * Transforms array input list of items to the correct state by updating the selected item(s).\n     */\n\n\n    propagateSelected(value) {}\n    /**\n     *\n     * @param value value to filter the list by\n     */\n\n\n    filterBy(value) {}\n    /**\n     * Initializes focus in the list\n     * In most cases this just calls `getCurrentElement().focus()`\n     */\n\n\n    initFocus() {}\n    /**\n     * Subscribe the function passed to an internal observable that will resolve once the items are ready\n     */\n\n\n    onItemsReady(subcription) {}\n    /**\n     * Reorder selected items bringing them to the top of the list\n     */\n\n\n    reorderSelected(moveFocus) {}\n\n  }\n\n  AbstractDropdownView.ɵfac = function AbstractDropdownView_Factory(t) {\n    return new (t || AbstractDropdownView)();\n  };\n\n  AbstractDropdownView.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractDropdownView,\n    selectors: [[\"\", \"ibmAbstractDropdownView\", \"\"]],\n    inputs: {\n      items: \"items\"\n    },\n    outputs: {\n      select: \"select\",\n      blurIntent: \"blurIntent\"\n    }\n  });\n  return AbstractDropdownView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst defaultOffset = {\n  top: 0,\n  left: 0\n};\nlet DropdownService = /*#__PURE__*/(() => {\n  class DropdownService {\n    constructor(placeholderService, animationFrameService) {\n      this.placeholderService = placeholderService;\n      this.animationFrameService = animationFrameService;\n      /**\n       * Maintains an Event Observable Subscription for the global requestAnimationFrame.\n       * requestAnimationFrame is tracked only if the `Dropdown` is appended to the body otherwise we don't need it\n       */\n\n      this.animationFrameSubscription = new Subscription();\n      this._offset = defaultOffset;\n    }\n\n    set offset(value) {\n      this._offset = Object.assign({}, defaultOffset, value);\n    }\n\n    get offset() {\n      return this._offset;\n    }\n    /**\n     * Appends the menu to the body, or a `ibm-placeholder` (if defined)\n     *\n     * @param parentRef container to position relative to\n     * @param menuRef menu to be appended to body\n     * @param classList any extra classes we should wrap the container with\n     */\n\n\n    appendToBody(parentRef, menuRef, classList) {\n      // build the dropdown list container\n      menuRef.style.display = \"block\";\n      const dropdownWrapper = document.createElement(\"div\");\n      dropdownWrapper.className = `dropdown ${classList}`;\n      dropdownWrapper.style.width = parentRef.offsetWidth + \"px\";\n      dropdownWrapper.style.position = \"absolute\";\n      dropdownWrapper.appendChild(menuRef); // append it to the placeholder\n\n      if (this.placeholderService.hasPlaceholderRef()) {\n        this.placeholderService.appendElement(dropdownWrapper); // or append it directly to the body\n      } else {\n        document.body.appendChild(dropdownWrapper);\n      }\n\n      this.menuInstance = dropdownWrapper;\n      this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {\n        this.positionDropdown(parentRef, dropdownWrapper);\n      }); // run one position in sync, so we're less likely to have the view \"jump\" as we focus\n\n      this.positionDropdown(parentRef, dropdownWrapper);\n      return dropdownWrapper;\n    }\n    /**\n     * Reattach the dropdown menu to the parent container\n     * @param hostRef container to append to\n     */\n\n\n    appendToDropdown(hostRef) {\n      // if the instance is already removed don't try and remove it again\n      if (!this.menuInstance) {\n        return;\n      }\n\n      const instance = this.menuInstance;\n      const menu = instance.firstElementChild; // clean up the instance\n\n      this.menuInstance = null;\n      menu.style.display = \"none\";\n      hostRef.appendChild(menu);\n      this.animationFrameSubscription.unsubscribe();\n\n      if (this.placeholderService.hasPlaceholderRef() && this.placeholderService.hasElement(instance)) {\n        this.placeholderService.removeElement(instance);\n      } else if (document.body.contains(instance)) {\n        document.body.removeChild(instance);\n      }\n\n      return instance;\n    }\n    /**\n     * position an open dropdown relative to the given parentRef\n     */\n\n\n    updatePosition(parentRef) {\n      this.positionDropdown(parentRef, this.menuInstance);\n    }\n\n    ngOnDestroy() {\n      this.animationFrameSubscription.unsubscribe();\n    }\n\n    positionDropdown(parentRef, menuRef) {\n      if (!menuRef) {\n        return;\n      }\n\n      let leftOffset = 0;\n      const boxMenu = menuRef.querySelector(\".bx--list-box__menu\");\n\n      if (boxMenu) {\n        // If the parentRef and boxMenu are in a different left position relative to the\n        // window, the the boxMenu position has already been flipped and a check needs to be done\n        // to see if it needs to stay flipped.\n        if (parentRef.getBoundingClientRect().left !== boxMenu.getBoundingClientRect().left) {\n          // The getBoundingClientRect().right of the boxMenu if it were hypothetically flipped\n          // back into the original position before the flip.\n          const testBoxMenuRightEdgePos = parentRef.getBoundingClientRect().left - boxMenu.getBoundingClientRect().left + boxMenu.getBoundingClientRect().right;\n\n          if (testBoxMenuRightEdgePos > (window.innerWidth || document.documentElement.clientWidth)) {\n            leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;\n          } // If it has not already been flipped, check if it is necessary to flip, ie. if the\n          // boxMenu is outside of the right viewPort.\n\n        } else if (boxMenu.getBoundingClientRect().right > (window.innerWidth || document.documentElement.clientWidth)) {\n          leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;\n        }\n      } // If ibm-placeholder has a parent with a position(relative|fixed|absolute) account for the parent offset\n\n\n      const closestMenuWithPos = closestAttr(\"position\", [\"relative\", \"fixed\", \"absolute\"], menuRef.parentElement);\n      const topPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().top * -1 : this.offset.top;\n      const leftPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().left * -1 : this.offset.left + leftOffset;\n      let pos = position.findAbsolute(parentRef, menuRef, \"bottom\");\n      pos = position.addOffset(pos, topPos, leftPos);\n      position.setElement(menuRef, pos);\n    }\n\n  }\n\n  DropdownService.ɵfac = function DropdownService_Factory(t) {\n    return new (t || DropdownService)(ɵngcc0.ɵɵinject(ɵngcc1.PlaceholderService), ɵngcc0.ɵɵinject(ɵngcc2.AnimationFrameService));\n  };\n\n  DropdownService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DropdownService,\n    factory: DropdownService.ɵfac\n  });\n  /** @nocollapse */\n\n  return DropdownService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Drop-down lists enable users to select one or more items from a list.\n *\n * #### Opening behavior/List DOM placement\n * By default the dropdown will try to figure out the best placement for the dropdown list.\n *\n * If it's not contained within any scrolling elements, it will open inline, if it _is_\n * contained within a scrolling container it will try to open in the body, or an `ibm-placeholder`.\n *\n * To control this behavior you can use the `appendInline` input:\n * - `[appendInline]=\"null\"` is the default (auto detection)\n * - `[appendInline]=\"false\"` will always append to the body/`ibm-placeholder`\n * - `[appendInline]=\"true\"` will always append inline (next to the dropdown button)\n *\n * [See demo](../../?path=/story/components-dropdown--basic)\n *\n * <example-url>../../iframe.html?id=components-dropdown--basic</example-url>\n */\n\n\nlet Dropdown = /*#__PURE__*/(() => {\n  class Dropdown {\n    /**\n     * Creates an instance of Dropdown.\n     */\n    constructor(elementRef, i18n, dropdownService, elementService) {\n      this.elementRef = elementRef;\n      this.i18n = i18n;\n      this.dropdownService = dropdownService;\n      this.elementService = elementService;\n      this.id = `dropdown-${Dropdown.dropdownCount++}`;\n      /**\n       * Value displayed if no item is selected.\n       */\n\n      this.placeholder = \"\";\n      /**\n       * The selected value from the `Dropdown`. Can be a string or template.\n       */\n\n      this.displayValue = \"\";\n      /**\n       * Sets the optional clear button tooltip text.\n       */\n\n      this.clearText = this.i18n.get().DROPDOWN.CLEAR;\n      /**\n       * Size to render the dropdown field.\n       *\n       * @deprecated since v4\n       */\n\n      this.size = \"md\";\n      /**\n       * Defines whether or not the `Dropdown` supports selecting multiple items as opposed to single\n       * item selection.\n       */\n\n      this.type = \"single\";\n      /**\n       * `light` or `dark` dropdown theme\n       */\n\n      this.theme = \"dark\";\n      /**\n       * Set to `true` to disable the dropdown.\n       */\n\n      this.disabled = false;\n      /**\n       * Set to `true` for a loading dropdown.\n       */\n\n      this.skeleton = false;\n      /**\n       * Set to `true` for an inline dropdown.\n       */\n\n      this.inline = false;\n      /**\n       * Set to `true` for a dropdown without arrow key activation.\n       */\n\n      this.disableArrowKeys = false;\n      /**\n       * Set to `true` for invalid state.\n       */\n\n      this.invalid = false;\n      /**\n        * Set to `true` to show a warning (contents set by warningText)\n        */\n\n      this.warn = false;\n      /**\n       * set to `true` to place the dropdown view inline with the component\n       */\n\n      this.appendInline = null;\n      /**\n       * Specify feedback (mode) of the selection.\n       * `top`: selected item jumps to top\n       * `fixed`: selected item stays at it's position\n       * `top-after-reopen`: selected item jump to top after reopen dropdown\n       */\n\n      this.selectionFeedback = \"top-after-reopen\";\n      /**\n       * Accessible label for the button that opens the dropdown list.\n       * Defaults to the `DROPDOWN.OPEN` value from the i18n service.\n       */\n\n      this.menuButtonLabel = this.i18n.get().DROPDOWN.OPEN;\n      /**\n       * Provides the label for the \"# selected\" text.\n       * Defaults to the `DROPDOWN.SELECTED` value from the i18n service.\n       */\n\n      this.selectedLabel = this.i18n.get().DROPDOWN.SELECTED;\n      /**\n       * Emits selection events.\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).\n       */\n\n      this.onClose = new EventEmitter();\n      /**\n       * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).\n       */\n\n      this.close = new EventEmitter();\n      this.hostClass = true;\n      /**\n       * Set to `true` if the dropdown is closed (not expanded).\n       */\n\n      this.menuIsClosed = true;\n      /**\n       * controls whether the `drop-up` class is applied\n       */\n\n      this._dropUp = false; // .bind creates a new function, so we declare the methods below\n      // but .bind them up here\n\n      this.noop = this._noop.bind(this);\n      this.outsideClick = this._outsideClick.bind(this);\n      this.outsideKey = this._outsideKey.bind(this);\n      this.keyboardNav = this._keyboardNav.bind(this);\n      this.visibilitySubscription = new Subscription();\n      this.onTouchedCallback = this._noop; // primarily used to capture and propagate input to `writeValue` before the content is available\n\n      this._writtenValue = [];\n      /**\n       * function passed in by `registerOnChange`\n       */\n\n      this.propagateChange = _ => {};\n    }\n    /**\n     * Deprecated. Use `itemValueKey` instead.\n     * Specifies the property to be used as the return value to `ngModel`\n     * @deprecated since v4 use itemValueKey instead\n     */\n\n\n    set value(newValue) {\n      console.warn(\"Dropdown `value` property has been deprecated. Use `itemValueKey` instead\");\n      this.itemValueKey = newValue;\n    }\n\n    get value() {\n      return this.itemValueKey;\n    }\n\n    get writtenValue() {\n      return this._writtenValue;\n    }\n\n    set writtenValue(val) {\n      if (val && val.length === 0) {\n        this.clearSelected();\n      }\n\n      this._writtenValue = val;\n    }\n    /**\n     * Updates the `type` property in the `@ContentChild`.\n     * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.\n     */\n\n\n    ngOnInit() {\n      if (this.view) {\n        this.view.type = this.type;\n      }\n    }\n    /**\n     * Initializes classes and subscribes to events for single or multi selection.\n     */\n\n\n    ngAfterContentInit() {\n      if (!this.view) {\n        return;\n      }\n\n      if (this.writtenValue && this.writtenValue.length || typeof this.writtenValue === \"number\") {\n        this.writeValue(this.writtenValue);\n      }\n\n      this.view.type = this.type;\n      this.view.size = this.size; // function to check if the event is organic (isUpdate === false) or programmatic\n\n      const isUpdate = event => event && event.isUpdate;\n\n      this.view.select.subscribe(event => {\n        if (this.type === \"single\" && !isUpdate(event)) {\n          this.closeMenu();\n\n          if (event.item && event.item.selected) {\n            if (this.itemValueKey) {\n              this.propagateChange(event.item[this.itemValueKey]);\n            } else {\n              this.propagateChange(event.item);\n            }\n          } else {\n            this.propagateChange(null);\n          }\n        }\n\n        if (this.type === \"multi\" && !isUpdate(event)) {\n          // if we have a `value` selector and selected items map them appropriately\n          if (this.itemValueKey && this.view.getSelected()) {\n            const values = this.view.getSelected().map(item => item[this.itemValueKey]);\n            this.propagateChange(values); // otherwise just pass up the values from `getSelected`\n          } else {\n            this.propagateChange(this.view.getSelected());\n          }\n        } // only emit selected for \"organic\" selections\n\n\n        if (!isUpdate(event)) {\n          this.checkForReorder();\n          this.selected.emit(event);\n        }\n      });\n    }\n\n    ngAfterViewInit() {\n      // if appendInline is default valued (null) we should:\n      // 1. if there are scrollable parents (not including body) don't append inline\n      //    this should also cover the case where the dropdown is in a modal\n      //    (where we _do_ want to append to the placeholder)\n      if (this.appendInline === null && hasScrollableParents(this.elementRef.nativeElement)) {\n        this.appendInline = false; // 2. otherwise we should append inline\n      } else if (this.appendInline === null) {\n        this.appendInline = true;\n      }\n\n      this.checkForReorder();\n    }\n    /**\n     * Removing the `Dropdown` from the body if it is appended to the body.\n     */\n\n\n    ngOnDestroy() {\n      if (!this.appendInline) {\n        this._appendToDropdown();\n      }\n    }\n    /**\n     * Propagates the injected `value`.\n     */\n\n\n    writeValue(value) {\n      // cache the written value so we can use it in `AfterContentInit`\n      this.writtenValue = value;\n      this.view.onItemsReady(() => {\n        // propagate null/falsey as an array (deselect everything)\n        if (!value) {\n          this.view.propagateSelected([value]);\n        } else if (this.type === \"single\") {\n          if (this.itemValueKey) {\n            // clone the specified item and update its state\n            const newValue = Object.assign({}, this.view.getListItems().find(item => item[this.itemValueKey] === value));\n            newValue.selected = true;\n            this.view.propagateSelected([newValue]);\n          } else {\n            // pass the singular value as an array of ListItem\n            this.view.propagateSelected([value]);\n          }\n        } else {\n          if (this.itemValueKey) {\n            // clone the items and update their state based on the received value array\n            // this way we don't lose any additional metadata that may be passed in via the `items` Input\n            let newValues = [];\n\n            for (const v of value) {\n              for (const item of this.view.getListItems()) {\n                if (item[this.itemValueKey] === v) {\n                  newValues.push(Object.assign({}, item, {\n                    selected: true\n                  }));\n                }\n              }\n            }\n\n            this.view.propagateSelected(newValues);\n          } else {\n            // we can safely assume we're passing an array of `ListItem`s\n            this.view.propagateSelected(value);\n          }\n        }\n\n        this.checkForReorder();\n      });\n    }\n\n    onBlur() {\n      this.onTouchedCallback();\n    }\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n    /**\n     * Registering the function injected to control the touch use of the `Dropdown`.\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * `ControlValueAccessor` method to programmatically disable the dropdown.\n     *\n     * ex: `this.formGroup.get(\"myDropdown\").disable();`\n     *\n     * @param isDisabled `true` to disable the input\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.\n     */\n    // \"Esc\", \"Spacebar\", \"Down\", and \"Up\" are IE specific values\n\n\n    onKeyDown(event) {\n      if ((event.key === \"Escape\" || event.key === \"Esc\") && !this.menuIsClosed) {\n        event.stopImmediatePropagation(); // don't unintentionally close other widgets that listen for Escape\n      }\n\n      if (event.key === \"Escape\" || event.key === \"Esc\") {\n        event.preventDefault();\n        this.closeMenu();\n        this.dropdownButton.nativeElement.focus();\n      } else if (this.menuIsClosed && (event.key === \" \" || event.key === \"ArrowDown\" || event.key === \"ArrowUp\" || event.key === \"Spacebar\" || event.key === \"Down\" || event.key === \"Up\")) {\n        if (this.disableArrowKeys && (event.key === \"ArrowDown\" || event.key === \"ArrowUp\" || event.key === \"Down\" || event.key === \"Up\")) {\n          return;\n        }\n\n        event.preventDefault();\n        this.openMenu();\n      }\n\n      if (!this.menuIsClosed && event.key === \"Tab\" && this.dropdownMenu.nativeElement.contains(event.target)) {\n        this.closeMenu();\n      }\n\n      if (!this.menuIsClosed && event.key === \"Tab\" && event.shiftKey) {\n        this.closeMenu();\n      }\n\n      if (this.type === \"multi\") {\n        return;\n      }\n\n      if (this.menuIsClosed) {\n        this.closedDropdownNavigation(event);\n      }\n    }\n\n    closedDropdownNavigation(event) {\n      // \"Down\", and \"Up\" are IE specific values\n      if (event.key === \"ArrowDown\" || event.key === \"Down\") {\n        event.preventDefault();\n        this.view.getCurrentItem().selected = false;\n        let item = this.view.getNextItem();\n\n        if (item) {\n          item.selected = true;\n        }\n      } else if (event.key === \"ArrowUp\" || event.key === \"Up\") {\n        event.preventDefault();\n        this.view.getCurrentItem().selected = false;\n        let item = this.view.getPrevItem();\n\n        if (item) {\n          item.selected = true;\n        }\n      }\n    }\n    /**\n     * Returns the display value if there is a selection and displayValue is set,\n     * if there is just a selection the ListItem content property will be returned,\n     * otherwise the placeholder will be returned.\n     */\n\n\n    getDisplayStringValue() {\n      if (!this.view) {\n        return;\n      }\n\n      let selected = this.view.getSelected();\n\n      if (selected.length && (!this.displayValue || !this.isRenderString())) {\n        if (this.type === \"multi\") {\n          return of(this.placeholder);\n        } else {\n          return of(selected[0].content);\n        }\n      } else if (selected.length && this.isRenderString()) {\n        return of(this.displayValue);\n      }\n\n      return of(this.placeholder);\n    }\n\n    isRenderString() {\n      return typeof this.displayValue === \"string\";\n    }\n\n    getRenderTemplateContext() {\n      if (!this.view) {\n        return;\n      }\n\n      let selected = this.view.getSelected();\n\n      if (this.type === \"multi\") {\n        return {\n          items: selected\n        };\n      } else if (selected && selected.length > 0) {\n        return {\n          item: selected[0]\n        }; // this is to be compatible with the dropdown-list template\n      } else {\n        return {};\n      }\n    }\n\n    getSelectedCount() {\n      if (this.view.getSelected()) {\n        return this.view.getSelected().length;\n      }\n    }\n\n    clearSelected() {\n      if (this.disabled || this.getSelectedCount() === 0) {\n        return;\n      }\n\n      for (const item of this.view.getListItems()) {\n        item.selected = false;\n      }\n\n      this.selected.emit([]);\n      this.propagateChange([]);\n    }\n    /**\n     * Returns `true` if there is a value selected.\n     */\n\n\n    valueSelected() {\n      if (this.view.getSelected()) {\n        return true;\n      }\n\n      return false;\n    }\n\n    _noop() {}\n    /**\n     * Handles clicks outside of the `Dropdown`.\n     */\n\n\n    _outsideClick(event) {\n      if (!this.elementRef.nativeElement.contains(event.target) && // if we're appendToBody the list isn't within the _elementRef,\n      // so we've got to check if our target is possibly in there too.\n      !this.dropdownMenu.nativeElement.contains(event.target)) {\n        this.closeMenu();\n      }\n    }\n\n    _outsideKey(event) {\n      if (!this.menuIsClosed && event.key === \"Tab\" && this.dropdownMenu.nativeElement.contains(event.target)) {\n        this.closeMenu();\n      }\n    }\n    /**\n     * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.\n     */\n\n\n    _keyboardNav(event) {\n      // \"Esc\" is an IE specific value\n      if ((event.key === \"Escape\" || event.key === \"Esc\") && !this.menuIsClosed) {\n        event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it\n      }\n\n      if (event.key === \"Escape\" || event.key === \"Esc\") {\n        event.preventDefault();\n        this.closeMenu();\n        this.dropdownButton.nativeElement.focus();\n      } else if (!this.menuIsClosed && event.key === \"Tab\") {\n        // this way focus will start on the next focusable item from the dropdown\n        // not the top of the body!\n        this.dropdownButton.nativeElement.focus();\n        this.dropdownButton.nativeElement.dispatchEvent(new KeyboardEvent(\"keydown\", {\n          bubbles: true,\n          cancelable: true,\n          key: \"Tab\"\n        }));\n        this.closeMenu();\n      }\n    }\n    /**\n     * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.\n     */\n\n\n    _appendToDropdown() {\n      this.dropdownService.appendToDropdown(this.elementRef.nativeElement);\n      this.dropdownMenu.nativeElement.removeEventListener(\"keydown\", this.keyboardNav, true);\n    }\n    /**\n     * Creates the `Dropdown` list as an element that is appended to the DOM body.\n     */\n\n\n    _appendToBody() {\n      const lightClass = this.theme === \"light\" ? \" bx--list-box--light\" : \"\";\n      const expandedClass = !this.menuIsClosed ? \" bx--list-box--expanded\" : \"\";\n      this.dropdownService.appendToBody(this.dropdownButton.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${lightClass}${expandedClass}`);\n      this.dropdownMenu.nativeElement.addEventListener(\"keydown\", this.keyboardNav, true);\n    }\n    /**\n     * Detects whether or not the `Dropdown` list is visible within all scrollable parents.\n     * This can be overridden by passing in a value to the `dropUp` input.\n     */\n\n\n    _shouldDropUp() {\n      // check if dropdownMenu exists first.\n      const menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(\".bx--list-box__menu\"); // check if menu exists first.\n\n      const menuRect = menu && menu.getBoundingClientRect();\n\n      if (menu && menuRect) {\n        const scrollableParents = getScrollableParents(menu);\n        return scrollableParents.reduce((shouldDropUp, parent) => {\n          const parentRect = parent.getBoundingClientRect();\n          const isBelowParent = !(menuRect.bottom <= parentRect.bottom);\n          return shouldDropUp || isBelowParent;\n        }, false);\n      }\n\n      return false;\n    }\n    /**\n     * Expands the dropdown menu in the view.\n     */\n\n\n    openMenu() {\n      // prevents the dropdown from opening when list of items is empty\n      if (this.view.getListItems().length === 0) {\n        return;\n      }\n\n      this._dropUp = false;\n      this.menuIsClosed = false; // move the dropdown list to the body if we're not appending inline\n      // and position it relative to the dropdown wrapper\n\n      if (!this.appendInline) {\n        const target = this.dropdownButton.nativeElement;\n        const parent = this.elementRef.nativeElement;\n        this.visibilitySubscription = this.elementService.visibility(target, parent).subscribe(value => {\n          if (!value.visible) {\n            this.closeMenu();\n          }\n        });\n\n        this._appendToBody();\n      } // set the dropdown menu to drop up if it's near the bottom of the screen\n      // setTimeout lets us measure after it's visible in the DOM\n\n\n      setTimeout(() => {\n        if (this.dropUp === null || this.dropUp === undefined) {\n          this._dropUp = this._shouldDropUp();\n        }\n      }, 0); // we bind noop to document.body.firstElementChild to allow safari to fire events\n      // from document. Then we unbind everything later to keep things light.\n\n      document.body.firstElementChild.addEventListener(\"click\", this.noop, true);\n      document.body.firstElementChild.addEventListener(\"keydown\", this.noop, true);\n      document.addEventListener(\"click\", this.outsideClick, true);\n      document.addEventListener(\"keydown\", this.outsideKey, true);\n      setTimeout(() => this.view.initFocus(), 0);\n    }\n    /**\n     * Collapsing the dropdown menu and removing unnecessary `EventListeners`.\n     */\n\n\n    closeMenu() {\n      // return early if the menu is already closed\n      if (this.menuIsClosed) {\n        return;\n      }\n\n      this.menuIsClosed = true;\n      this.checkForReorder();\n      this.onClose.emit();\n      this.close.emit(); // focus the trigger button when we close ...\n\n      this.dropdownButton.nativeElement.focus(); // remove the conditional once this api is settled and part of abstract-dropdown-view.class\n\n      if (this.view[\"disableScroll\"]) {\n        this.view[\"disableScroll\"]();\n      } // move the list back in the component on close\n\n\n      if (!this.appendInline) {\n        this.visibilitySubscription.unsubscribe();\n\n        this._appendToDropdown();\n      }\n\n      document.body.firstElementChild.removeEventListener(\"click\", this.noop, true);\n      document.body.firstElementChild.removeEventListener(\"keydown\", this.noop, true);\n      document.removeEventListener(\"click\", this.outsideClick, true);\n      document.removeEventListener(\"keydown\", this.outsideKey, true);\n    }\n    /**\n     * Controls toggling menu states between open/expanded and closed/collapsed.\n     */\n\n\n    toggleMenu() {\n      if (this.menuIsClosed) {\n        this.openMenu();\n      } else {\n        this.closeMenu();\n      }\n    }\n\n    isTemplate(value) {\n      return value instanceof TemplateRef;\n    }\n    /**\n     * Controls when it's needed to apply the selection feedback\n     */\n\n\n    checkForReorder() {\n      const topAfterReopen = this.menuIsClosed && this.selectionFeedback === \"top-after-reopen\";\n\n      if (this.type === \"multi\" && (topAfterReopen || this.selectionFeedback === \"top\")) {\n        this.view.reorderSelected();\n      }\n    }\n\n  }\n\n  Dropdown.ɵfac = function Dropdown_Factory(t) {\n    return new (t || Dropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n), ɵngcc0.ɵɵdirectiveInject(DropdownService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService));\n  };\n\n  Dropdown.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Dropdown,\n    selectors: [[\"ibm-dropdown\"]],\n    contentQueries: function Dropdown_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, AbstractDropdownView, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.view = _t.first);\n      }\n    },\n    viewQuery: function Dropdown_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownButton = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownMenu = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function Dropdown_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function Dropdown_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--dropdown__wrapper\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      placeholder: \"placeholder\",\n      displayValue: \"displayValue\",\n      clearText: \"clearText\",\n      size: \"size\",\n      type: \"type\",\n      theme: \"theme\",\n      disabled: \"disabled\",\n      skeleton: \"skeleton\",\n      inline: \"inline\",\n      disableArrowKeys: \"disableArrowKeys\",\n      invalid: \"invalid\",\n      warn: \"warn\",\n      appendInline: \"appendInline\",\n      selectionFeedback: \"selectionFeedback\",\n      menuButtonLabel: \"menuButtonLabel\",\n      selectedLabel: \"selectedLabel\",\n      value: \"value\",\n      itemValueKey: \"itemValueKey\",\n      label: \"label\",\n      helperText: \"helperText\",\n      invalidText: \"invalidText\",\n      warnText: \"warnText\",\n      scrollableContainer: \"scrollableContainer\",\n      dropUp: \"dropUp\"\n    },\n    outputs: {\n      selected: \"selected\",\n      onClose: \"onClose\",\n      close: \"close\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: Dropdown,\n      multi: true\n    }])],\n    ngContentSelectors: _c8,\n    decls: 17,\n    vars: 36,\n    consts: [[\"class\", \"bx--label\", 3, \"for\", \"ngClass\", 4, \"ngIf\"], [1, \"bx--list-box\", 3, \"ngClass\"], [\"type\", \"button\", \"aria-haspopup\", \"listbox\", 1, \"bx--list-box__field\", 3, \"id\", \"ngClass\", \"click\", \"blur\"], [\"dropdownButton\", \"\"], [\"class\", \"bx--list-box__selection bx--tag--filter bx--list-box__selection--multi\", \"tabindex\", \"0\", 3, \"title\", \"click\", \"keydown.enter\", 4, \"ngIf\"], [\"class\", \"bx--list-box__label\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"bx--dropdown__invalid-icon\", \"ibmIcon\", \"warning--filled\", \"size\", \"16\", 4, \"ngIf\"], [\"ibmIcon\", \"warning--alt--filled\", \"size\", \"16\", \"class\", \"bx--list-box__invalid-icon bx--list-box__invalid-icon--warning\", 4, \"ngIf\"], [1, \"bx--list-box__menu-icon\"], [\"ibmIcon\", \"chevron--down\", \"size\", \"16\", 3, \"ngClass\", 4, \"ngIf\"], [3, \"ngClass\"], [\"dropdownMenu\", \"\"], [\"class\", \"bx--form__helper-text\", 3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"bx--form-requirement\", 4, \"ngIf\"], [1, \"bx--label\", 3, \"for\", \"ngClass\"], [3, \"ngTemplateOutlet\"], [\"tabindex\", \"0\", 1, \"bx--list-box__selection\", \"bx--tag--filter\", \"bx--list-box__selection--multi\", 3, \"title\", \"click\", \"keydown.enter\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"role\", \"img\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\", 2, \"will-change\", \"transform\"], [\"d\", \"M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z\"], [1, \"bx--list-box__label\"], [3, \"ngTemplateOutletContext\", \"ngTemplateOutlet\"], [\"ibmIcon\", \"warning--filled\", \"size\", \"16\", 1, \"bx--dropdown__invalid-icon\"], [\"ibmIcon\", \"warning--alt--filled\", \"size\", \"16\", 1, \"bx--list-box__invalid-icon\", \"bx--list-box__invalid-icon--warning\"], [\"ibmIcon\", \"chevron--down\", \"size\", \"16\", 3, \"ngClass\"], [1, \"bx--form__helper-text\", 3, \"ngClass\"], [1, \"bx--form-requirement\"]],\n    template: function Dropdown_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, Dropdown_label_0_Template, 3, 6, \"label\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1)(2, \"button\", 2, 3);\n        ɵngcc0.ɵɵlistener(\"click\", function Dropdown_Template_button_click_2_listener($event) {\n          return ctx.disabled ? $event.stopPropagation() : ctx.toggleMenu();\n        })(\"blur\", function Dropdown_Template_button_blur_2_listener() {\n          return ctx.onBlur();\n        });\n        ɵngcc0.ɵɵtemplate(4, Dropdown_div_4_Template, 4, 2, \"div\", 4);\n        ɵngcc0.ɵɵtemplate(5, Dropdown_span_5_Template, 3, 3, \"span\", 5);\n        ɵngcc0.ɵɵtemplate(6, Dropdown_6_Template, 1, 2, null, 6);\n        ɵngcc0.ɵɵtemplate(7, Dropdown__svg_svg_7_Template, 1, 0, \"svg\", 7);\n        ɵngcc0.ɵɵtemplate(8, Dropdown__svg_svg_8_Template, 1, 0, \"svg\", 8);\n        ɵngcc0.ɵɵelementStart(9, \"span\", 9);\n        ɵngcc0.ɵɵtemplate(10, Dropdown__svg_svg_10_Template, 1, 4, \"svg\", 10);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵelementStart(11, \"div\", 11, 12);\n        ɵngcc0.ɵɵtemplate(13, Dropdown_ng_content_13_Template, 1, 0, \"ng-content\", 6);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(14, Dropdown_div_14_Template, 3, 5, \"div\", 13);\n        ɵngcc0.ɵɵtemplate(15, Dropdown_div_15_Template, 3, 2, \"div\", 14);\n        ɵngcc0.ɵɵtemplate(16, Dropdown_div_16_Template, 3, 2, \"div\", 14);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.label);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunctionV(18, _c5, [ctx.type !== \"multi\", ctx.type === \"multi\", ctx.type === \"multi\" && ctx.getSelectedCount() > 0, ctx.theme === \"light\", ctx.theme === \"light\", ctx.inline, ctx.skeleton, ctx.disabled, ctx.invalid, ctx.warn, ctx.size === \"xl\", ctx.size === \"sm\", !ctx.menuIsClosed]));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.id)(\"ngClass\", ɵngcc0.ɵɵpureFunction1(32, _c6, !ctx.menuIsClosed));\n        ɵngcc0.ɵɵattribute(\"aria-expanded\", !ctx.menuIsClosed)(\"aria-disabled\", ctx.disabled)(\"disabled\", ctx.disabled ? true : null);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.type === \"multi\" && ctx.getSelectedCount() > 0);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.isRenderString());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.isRenderString());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.warn && ctx.invalid);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.invalid && ctx.warn);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(34, _c7, ctx.dropUp !== null && ctx.dropUp !== undefined ? ctx.dropUp : ctx._dropUp));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.menuIsClosed);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.helperText && !ctx.invalid && !ctx.warn);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.warn && ctx.invalid);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.invalid && ctx.warn);\n      }\n    },\n    dependencies: [ɵngcc4.NgClass, ɵngcc4.NgIf, ɵngcc4.NgTemplateOutlet, ɵngcc5.IconDirective, ɵngcc4.AsyncPipe],\n    encapsulation: 2\n  });\n  Dropdown.dropdownCount = 0;\n  /** @nocollapse */\n\n  return Dropdown;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * returns an observable bound to keydown events that\n * filters to a single element where the first letter of\n * it's textContent matches the key pressed\n *\n * @param target element to watch\n * @param elements elements to search\n */\n\n\nfunction watchFocusJump(target, elements) {\n  return fromEvent(target, \"keydown\").pipe(debounceTime(150), map(ev => {\n    let el = elements.find(itemEl => itemEl.textContent.trim().toLowerCase().startsWith(ev.key));\n\n    if (el) {\n      return el;\n    }\n  }), filter(el => !!el));\n}\n/**\n * ```html\n * <ibm-dropdown-list [items]=\"listItems\"></ibm-dropdown-list>\n * ```\n * ```typescript\n * listItems = [\n * \t{\n * \t\tcontent: \"item one\",\n * \t\tselected: false\n * \t},\n * \t{\n * \t\tcontent: \"item two\",\n * \t\tselected: false,\n * \t},\n * \t{\n * \t\tcontent: \"item three\",\n * \t\tselected: false\n * \t},\n * \t{\n * \t\tcontent: \"item four\",\n * \t\tselected: false\n * \t}\n * ];\n * ```\n */\n\n\nlet DropdownList = /*#__PURE__*/(() => {\n  class DropdownList {\n    /**\n     * Creates an instance of `DropdownList`.\n     */\n    constructor(elementRef, i18n, appRef) {\n      this.elementRef = elementRef;\n      this.i18n = i18n;\n      this.appRef = appRef;\n      this.ariaLabel = this.i18n.get().DROPDOWN_LIST.LABEL;\n      /**\n       * Template to bind to items in the `DropdownList` (optional).\n       */\n\n      this.listTpl = null;\n      /**\n       * Event to emit selection of a list item within the `DropdownList`.\n       */\n\n      this.select = new EventEmitter();\n      /**\n       * Event to emit scroll event of a list within the `DropdownList`.\n       */\n\n      this.scroll = new EventEmitter();\n      /**\n       * Event to suggest a blur on the view.\n       * Emits _after_ the first/last item has been focused.\n       * ex.\n       * ArrowUp -> focus first item\n       * ArrowUp -> emit event\n       *\n       * When this event fires focus should be placed on some element outside of the list - blurring the list as a result\n       */\n\n      this.blurIntent = new EventEmitter();\n      /**\n       * Defines whether or not the `DropdownList` supports selecting multiple items as opposed to single\n       * item selection.\n       */\n\n      this.type = \"single\";\n      /**\n       * Defines whether to show title attribute or not\n       */\n\n      this.showTitles = true;\n      /**\n       * Defines the rendering size of the `DropdownList` input component.\n       *\n       * @deprecated since v4\n       */\n\n      this.size = \"md\";\n      this.listId = `listbox-${DropdownList.listCount++}`;\n      this.highlightedItem = null;\n      /**\n       * Holds the list of items that will be displayed in the `DropdownList`.\n       * It differs from the the complete set of items when filtering is used (but\n       * it is always a subset of the total items in `DropdownList`).\n       */\n\n      this.displayItems = [];\n      /**\n       * Maintains the index for the selected item within the `DropdownList`.\n       */\n\n      this.index = -1;\n      /**\n       * Useful representation of the items, should be accessed via `getListItems`.\n       */\n\n      this._items = [];\n    }\n    /**\n     * The list items belonging to the `DropdownList`.\n     */\n\n\n    set items(value) {\n      if (isObservable(value)) {\n        if (this._itemsSubscription) {\n          this._itemsSubscription.unsubscribe();\n        }\n\n        this._itemsReady = new Observable(observer => {\n          this._itemsSubscription = value.subscribe(v => {\n            this.updateList(v);\n            observer.next(true);\n            observer.complete();\n          });\n        });\n        this.onItemsReady(null);\n      } else {\n        this.updateList(value);\n      }\n\n      this._originalItems = value;\n    }\n\n    get items() {\n      return this._originalItems;\n    }\n    /**\n     * Retrieves array of list items and index of the selected item after view has rendered.\n     * Additionally, any Observables for the `DropdownList` are initialized.\n     */\n\n\n    ngAfterViewInit() {\n      this.index = this.getListItems().findIndex(item => item.selected);\n      this.setupFocusObservable();\n      setTimeout(() => {\n        this.doEmitSelect(true);\n      });\n    }\n    /**\n     * Removes any Observables on destruction of the component.\n     */\n\n\n    ngOnDestroy() {\n      if (this.focusJump) {\n        this.focusJump.unsubscribe();\n      }\n\n      if (this._itemsSubscription) {\n        this._itemsSubscription.unsubscribe();\n      }\n    }\n\n    doEmitSelect(isUpdate = true) {\n      if (this.type === \"single\") {\n        this.select.emit({\n          item: this._items.find(item => item.selected),\n          isUpdate: isUpdate\n        });\n      } else {\n        // abuse javascripts object mutability until we can break the API and switch to\n        // { items: [], isUpdate: true }\n        const selected = this.getSelected() || [];\n        selected[\"isUpdate\"] = isUpdate;\n        this.select.emit(selected);\n      }\n    }\n\n    getItemId(index) {\n      return `${this.listId}-${index}`;\n    }\n    /**\n     * Updates the displayed list of items and then retrieves the most current properties for the `DropdownList` from the DOM.\n     */\n\n\n    updateList(items) {\n      this._items = items.map(item => Object.assign({}, item));\n      this.displayItems = this._items;\n      this.updateIndex();\n      this.setupFocusObservable();\n      this.doEmitSelect();\n    }\n    /**\n     * Filters the items being displayed in the DOM list.\n     */\n\n\n    filterBy(query = \"\") {\n      if (query) {\n        this.displayItems = this.getListItems().filter(item => item.content.toLowerCase().includes(query.toLowerCase())); // Reset index if items were found\n        // Prevent selecting index in list that are undefined.\n\n        if (this.displayItems) {\n          this.index = 0;\n        }\n      } else {\n        this.displayItems = this.getListItems();\n      }\n\n      this.updateIndex();\n    }\n    /**\n     * Initializes (or re-initializes) the Observable that handles switching focus to an element based on\n     * key input matching the first letter of the item in the list.\n     */\n\n\n    setupFocusObservable() {\n      if (!this.list) {\n        return;\n      }\n\n      if (this.focusJump) {\n        this.focusJump.unsubscribe();\n      }\n\n      let elList = Array.from(this.list.nativeElement.querySelectorAll(\"li\"));\n      this.focusJump = watchFocusJump(this.list.nativeElement, elList).subscribe(el => {\n        el.focus();\n      });\n    }\n    /**\n     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.\n     */\n\n\n    getNextItem() {\n      if (this.index < this.displayItems.length - 1) {\n        this.index++;\n      }\n\n      return this.displayItems[this.index];\n    }\n    /**\n     * Returns `true` if the selected item is not the last item in the `DropdownList`.\n     */\n\n\n    hasNextElement() {\n      return this.index < this.displayItems.length - 1 && (!(this.index === this.displayItems.length - 2) || !this.displayItems[this.index + 1].disabled);\n    }\n    /**\n     * Returns the `HTMLElement` for the item that is subsequent to the selected item.\n     */\n\n\n    getNextElement() {\n      // Only return native elements if they are rendered\n      const elemList = this.listElementList ? this.listElementList.toArray() : [];\n\n      if (!elemList.length) {\n        return null;\n      }\n      /**\n       * Start checking from next index\n       * Continue looping through the list until a non disabeled element is found or\n       * end of list is reached\n       */\n\n\n      for (let i = this.index + 1; i < elemList.length; i++) {\n        // If the values in the list are not disabled\n        if (!this.displayItems[i].disabled) {\n          this.index = i;\n          return elemList[i].nativeElement;\n        }\n      }\n\n      return elemList[this.index].nativeElement;\n    }\n    /**\n     * Returns the `ListItem` that precedes the selected item within `DropdownList`.\n     */\n\n\n    getPrevItem() {\n      if (this.index > 0) {\n        this.index--;\n      }\n\n      return this.displayItems[this.index];\n    }\n    /**\n     * Returns `true` if the selected item is not the first in the list.\n     */\n\n\n    hasPrevElement() {\n      return this.index > 0 && (!(this.index === 1) || !this.displayItems[0].disabled);\n    }\n    /**\n     * Returns the `HTMLElement` for the item that precedes the selected item.\n     */\n\n\n    getPrevElement() {\n      // Only return native elements if they are rendered\n      const elemList = this.listElementList ? this.listElementList.toArray() : [];\n\n      if (!elemList.length) {\n        return null;\n      }\n      /**\n       * Start checking from next index\n       * Continue looping through the list until a non disabeled element is found or\n       * end of list is reached\n       */\n\n\n      for (let i = this.index - 1; i < this.index && i >= 0; i--) {\n        // If the values in the list are not disabled\n        if (!this.displayItems[i].disabled) {\n          this.index = i;\n          return elemList[i].nativeElement;\n        }\n      }\n\n      return elemList[this.index].nativeElement;\n    }\n    /**\n     * Returns the `ListItem` that is selected within `DropdownList`.\n     */\n\n\n    getCurrentItem() {\n      if (this.index < 0) {\n        return this.displayItems[0];\n      }\n\n      return this.displayItems[this.index];\n    }\n    /**\n     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.\n     */\n\n\n    getCurrentElement() {\n      if (this.index < 0) {\n        return this.listElementList.first.nativeElement;\n      }\n\n      return this.listElementList.toArray()[this.index].nativeElement;\n    }\n    /**\n     * Returns the items as an Array\n     */\n\n\n    getListItems() {\n      return this._items;\n    }\n    /**\n     * Returns a list containing the selected item(s) in the `DropdownList`.\n     */\n\n\n    getSelected() {\n      let selected = this.getListItems().filter(item => item.selected);\n\n      if (selected.length === 0) {\n        return [];\n      }\n\n      return selected;\n    }\n    /**\n     * Transforms array input list of items to the correct state by updating the selected item(s).\n     */\n\n\n    propagateSelected(value) {\n      // if we get a non-array, log out an error (since it is one)\n      if (!Array.isArray(value)) {\n        console.error(`${this.constructor.name}.propagateSelected expects an Array<ListItem>, got ${JSON.stringify(value)}`);\n      }\n\n      this.onItemsReady(() => {\n        // loop through the list items and update the `selected` state for matching items in `value`\n        for (let oldItem of this.getListItems()) {\n          // copy the item\n          let tempOldItem = Object.assign({}, oldItem); // deleted selected because it's what we _want_ to change\n\n          delete tempOldItem.selected; // stringify for compare\n\n          tempOldItem = JSON.stringify(tempOldItem);\n\n          for (let newItem of value) {\n            // copy the item\n            let tempNewItem = Object.assign({}, newItem); // deleted selected because it's what we _want_ to change\n\n            delete tempNewItem.selected; // stringify for compare\n\n            tempNewItem = JSON.stringify(tempNewItem); // do the compare\n\n            if (tempOldItem.includes(tempNewItem)) {\n              oldItem.selected = newItem.selected; // if we've found a matching item, we can stop looping\n\n              break;\n            } else {\n              oldItem.selected = false;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Initializes focus in the list, effectively a wrapper for `getCurrentElement().focus()`\n     */\n\n\n    initFocus() {\n      if (this.index < 0) {\n        this.updateIndex();\n      }\n\n      this.list.nativeElement.focus();\n      setTimeout(() => {\n        this.highlightedItem = this.getItemId(this.index);\n      });\n    }\n\n    updateIndex() {\n      // initialize index on the first selected item or\n      // on the next non disabled item if no items are selected\n      const selected = this.getSelected();\n\n      if (selected.length) {\n        this.index = this.displayItems.indexOf(selected[0]);\n      } else if (this.hasNextElement()) {\n        this.getNextElement();\n      }\n    }\n    /**\n     * Manages the keyboard accessibility for navigation and selection within a `DropdownList`.\n     * @deprecated since v4\n     */\n\n\n    doKeyDown(event, item) {\n      // \"Spacebar\", \"Down\", and \"Up\" are IE specific values\n      if (event.key === \"Enter\" || event.key === \" \" || event.key === \"Spacebar\") {\n        if (this.listElementList.some(option => option.nativeElement === event.target)) {\n          event.preventDefault();\n        }\n\n        if (event.key === \"Enter\") {\n          this.doClick(event, item);\n        }\n      } else if (event.key === \"ArrowDown\" || event.key === \"ArrowUp\" || event.key === \"Down\" || event.key === \"Up\") {\n        event.preventDefault();\n\n        if (event.key === \"ArrowDown\" || event.key === \"Down\") {\n          if (this.hasNextElement()) {\n            // this.getNextElement().focus();\n            this.getNextElement();\n          } else {\n            this.blurIntent.emit(\"bottom\");\n          }\n        } else if (event.key === \"ArrowUp\" || event.key === \"Up\") {\n          if (this.hasPrevElement()) {\n            // this.getPrevElement().focus();\n            this.getPrevElement();\n          } else {\n            this.blurIntent.emit(\"top\");\n          }\n        }\n      }\n    }\n    /**\n     * Manages the keyboard accessibility for navigation and selection within a `DropdownList`.\n     */\n\n\n    navigateList(event) {\n      // \"Spacebar\", \"Down\", and \"Up\" are IE specific values\n      if (event.key === \"Enter\" || event.key === \" \" || event.key === \"Spacebar\") {\n        if (this.listElementList.some(option => option.nativeElement === event.target)) {\n          event.preventDefault();\n        }\n\n        if (event.key === \"Enter\") {\n          this.doClick(event, this.getCurrentItem());\n        }\n      } else if (event.key === \"ArrowDown\" || event.key === \"ArrowUp\" || event.key === \"Down\" || event.key === \"Up\") {\n        event.preventDefault();\n\n        if (event.key === \"ArrowDown\" || event.key === \"Down\") {\n          if (this.hasNextElement()) {\n            this.getNextElement().scrollIntoView({\n              block: \"end\"\n            });\n          } else {\n            this.blurIntent.emit(\"bottom\");\n          }\n        } else if (event.key === \"ArrowUp\" || event.key === \"Up\") {\n          if (this.hasPrevElement()) {\n            this.getPrevElement().scrollIntoView();\n          } else {\n            this.blurIntent.emit(\"top\");\n          }\n        }\n\n        setTimeout(() => {\n          this.highlightedItem = this.getItemId(this.index);\n        });\n      }\n    }\n    /**\n     * Emits the selected item or items after a mouse click event has occurred.\n     */\n\n\n    doClick(event, item) {\n      event.preventDefault();\n\n      if (item && !item.disabled) {\n        this.list.nativeElement.focus();\n\n        if (this.type === \"single\") {\n          item.selected = true; // reset the selection\n\n          for (let otherItem of this.getListItems()) {\n            if (item !== otherItem) {\n              otherItem.selected = false;\n            }\n          }\n        } else {\n          item.selected = !item.selected;\n        }\n\n        this.index = this.displayItems.indexOf(item);\n        this.highlightedItem = this.getItemId(this.index);\n        this.doEmitSelect(false);\n        this.appRef.tick();\n      }\n    }\n\n    onItemFocus(index) {\n      const element = this.listElementList.toArray()[index].nativeElement;\n      element.classList.add(\"bx--list-box__menu-item--highlighted\");\n      element.tabIndex = 0;\n    }\n\n    onItemBlur(index) {\n      const element = this.listElementList.toArray()[index].nativeElement;\n      element.classList.remove(\"bx--list-box__menu-item--highlighted\");\n      element.tabIndex = -1;\n    }\n    /**\n     * Emits the scroll event of the options list\n     */\n\n\n    emitScroll(event) {\n      const atTop = event.srcElement.scrollTop === 0;\n      const atBottom = event.srcElement.scrollHeight - event.srcElement.scrollTop === event.srcElement.clientHeight;\n      const customScrollEvent = {\n        atTop,\n        atBottom,\n        event\n      };\n      this.scroll.emit(customScrollEvent);\n    }\n    /**\n     * Subscribe the function passed to an internal observable that will resolve once the items are ready\n     */\n\n\n    onItemsReady(subcription) {\n      // this subscription will auto unsubscribe because of the `first()` pipe\n      (this._itemsReady || of(true)).pipe(first()).subscribe(subcription);\n    }\n\n    reorderSelected(moveFocus = true) {\n      this.displayItems = [...this.getSelected(), ...this.getListItems().filter(item => !item.selected)];\n\n      if (moveFocus) {\n        setTimeout(() => {\n          this.updateIndex();\n          this.highlightedItem = this.getItemId(this.index);\n        });\n      }\n    }\n\n  }\n\n  DropdownList.ɵfac = function DropdownList_Factory(t) {\n    return new (t || DropdownList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef));\n  };\n\n  DropdownList.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DropdownList,\n    selectors: [[\"ibm-dropdown-list\"]],\n    viewQuery: function DropdownList_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c9, 7);\n        ɵngcc0.ɵɵviewQuery(_c10, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listElementList = _t);\n      }\n    },\n    inputs: {\n      ariaLabel: \"ariaLabel\",\n      listTpl: \"listTpl\",\n      type: \"type\",\n      showTitles: \"showTitles\",\n      items: \"items\"\n    },\n    outputs: {\n      select: \"select\",\n      scroll: \"scroll\",\n      blurIntent: \"blurIntent\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AbstractDropdownView,\n      useExisting: DropdownList\n    }])],\n    decls: 3,\n    vars: 4,\n    consts: [[\"role\", \"listbox\", \"tabindex\", \"-1\", 1, \"bx--list-box__menu\", \"bx--multi-select\", 3, \"id\", \"scroll\", \"keydown\"], [\"list\", \"\"], [\"role\", \"option\", \"class\", \"bx--list-box__menu-item\", 3, \"id\", \"ngClass\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"option\", 1, \"bx--list-box__menu-item\", 3, \"id\", \"ngClass\", \"click\"], [\"tabindex\", \"-1\", 1, \"bx--list-box__menu-item__option\"], [\"listItem\", \"\"], [\"class\", \"bx--form-item bx--checkbox-wrapper\", 4, \"ngIf\"], [4, \"ngIf\"], [\"ibmIcon\", \"checkmark\", \"size\", \"16\", \"class\", \"bx--list-box__menu-item__selected-icon\", 4, \"ngIf\"], [1, \"bx--form-item\", \"bx--checkbox-wrapper\"], [1, \"bx--checkbox-label\"], [\"type\", \"checkbox\", \"tabindex\", \"-1\", 1, \"bx--checkbox\", 3, \"checked\", \"disabled\"], [1, \"bx--checkbox-appearance\"], [1, \"bx--checkbox-label-text\"], [\"ibmIcon\", \"checkmark\", \"size\", \"16\", 1, \"bx--list-box__menu-item__selected-icon\"], [3, \"ngTemplateOutletContext\", \"ngTemplateOutlet\"]],\n    template: function DropdownList_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0, 1);\n        ɵngcc0.ɵɵlistener(\"scroll\", function DropdownList_Template_ul_scroll_0_listener($event) {\n          return ctx.emitScroll($event);\n        })(\"keydown\", function DropdownList_Template_ul_keydown_0_listener($event) {\n          return ctx.navigateList($event);\n        });\n        ɵngcc0.ɵɵtemplate(2, DropdownList_li_2_Template, 7, 12, \"li\", 2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.listId);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"aria-activedescendant\", ctx.highlightedItem);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.displayItems);\n      }\n    },\n    dependencies: [ɵngcc4.NgClass, ɵngcc4.NgForOf, ɵngcc4.NgIf, ɵngcc4.NgTemplateOutlet, ɵngcc5.IconDirective],\n    encapsulation: 2\n  });\n  DropdownList.listCount = 0;\n  /** @nocollapse */\n\n  return DropdownList;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ScrollableList = /*#__PURE__*/(() => {\n  class ScrollableList {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /**\n       * Optional target list to scroll\n       */\n\n      this.nScrollableList = null;\n      /**\n       * Enables or disables scrolling for the whole directive\n       */\n\n      this.scrollEnabled = true;\n      /**\n       * How many lines to scroll by each time `wheel` fires\n       * Defaults to 10 - based on testing this isn't too fast or slow on any platform\n       */\n\n      this.scrollBy = 10;\n      this.canScrollUp = false;\n      this.canScrollDown = false;\n      this.list = this.elementRef.nativeElement;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.scrollEnabled) {\n        if (changes.scrollEnabled.currentValue) {\n          this.list.style.overflow = \"hidden\";\n          this.scrollUpTarget.style.display = \"flex\";\n          this.scrollDownTarget.style.display = \"flex\";\n          this.canScrollUp = true;\n          this.canScrollDown = true;\n          this.updateScrollHeight();\n          this.checkScrollArrows();\n          setTimeout(() => {\n            this.checkScrollArrows();\n          });\n        } else {\n          this.scrollUpTarget.style.display = \"none\";\n          this.scrollDownTarget.style.display = \"none\";\n          this.canScrollUp = false;\n          this.canScrollDown = false;\n          this.list.style.height = null;\n          this.list.style.overflow = null;\n          clearInterval(this.hoverScrollInterval);\n        }\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.nScrollableList) {\n        this.list = this.elementRef.nativeElement.querySelector(this.nScrollableList);\n      }\n\n      this.scrollUpTarget.addEventListener(\"mouseover\", () => this.onHoverUp(true));\n      this.scrollUpTarget.addEventListener(\"mouseout\", () => this.onHoverUp(false));\n      this.scrollDownTarget.addEventListener(\"mouseover\", () => this.onHoverDown(true));\n      this.scrollDownTarget.addEventListener(\"mouseout\", () => this.onHoverDown(false));\n    }\n\n    updateScrollHeight() {\n      if (this.scrollEnabled) {\n        const container = this.elementRef.nativeElement.parentElement;\n        const containerRect = container.getBoundingClientRect();\n        const innerHeightDiff = this.list.getBoundingClientRect().top - containerRect.top;\n        const outerHeightDiff = containerRect.height - (containerRect.bottom - window.innerHeight); // 40 gives us some padding between the bottom of the list,\n        // the bottom of the window, and the scroll down button\n\n        const height = outerHeightDiff - innerHeightDiff - 40;\n        this.list.style.height = `${height}px`;\n      }\n    }\n\n    checkScrollArrows() {\n      const scrollUpHeight = this.scrollUpTarget.offsetHeight;\n      const scrollDownHeight = this.scrollDownTarget.offsetHeight;\n\n      if (this.list.scrollTop === 0) {\n        if (this.canScrollUp) {\n          this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollUpHeight}px`;\n        }\n\n        this.scrollUpTarget.style.display = \"none\";\n        this.canScrollUp = false;\n      } else if (this.list.scrollTop === this.list.scrollTopMax) {\n        if (this.canScrollDown) {\n          this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollDownHeight}px`;\n        }\n\n        this.scrollDownTarget.style.display = \"none\";\n        this.canScrollDown = false;\n      } else {\n        if (!this.canScrollUp) {\n          this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollUpHeight}px`;\n        }\n\n        if (!this.canScrollDown) {\n          this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollDownHeight}px`;\n        }\n\n        this.scrollUpTarget.style.display = \"flex\";\n        this.scrollDownTarget.style.display = \"flex\";\n        this.canScrollUp = true;\n        this.canScrollDown = true;\n      }\n    }\n\n    onWheel(event) {\n      if (event.deltaY < 0) {\n        this.list.scrollTop -= this.scrollBy;\n      } else {\n        this.list.scrollTop += this.scrollBy;\n      } // only prevent the parent/window from scrolling if we can scroll\n\n\n      if (!(this.list.scrollTop === this.list.scrollTopMax || this.list.scrollTop === 0)) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      this.checkScrollArrows();\n    }\n\n    onTouchStart(event) {\n      if (event.touches[0]) {\n        this.lastTouch = event.touches[0].clientY;\n      }\n    }\n\n    onTouchMove(event) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (event.touches[0]) {\n        const touch = event.touches[0];\n        this.list.scrollTop += this.lastTouch - touch.clientY;\n        this.lastTouch = touch.clientY;\n        this.checkScrollArrows();\n      }\n    }\n\n    hoverScrollBy(hovering, amount) {\n      if (hovering) {\n        this.hoverScrollInterval = setInterval(() => {\n          this.list.scrollTop += amount;\n          this.checkScrollArrows();\n        }, 1);\n      } else {\n        clearInterval(this.hoverScrollInterval);\n      }\n    }\n\n    onHoverUp(hovering) {\n      // how many px/lines to scroll by on hover\n      // 3 is just a random number that felt good\n      // 1 and 2 are too slow, 4 works but it might be a tad fast\n      this.hoverScrollBy(hovering, -3);\n    }\n\n    onHoverDown(hovering) {\n      this.hoverScrollBy(hovering, 3);\n    }\n\n    onKeyDown(event) {\n      if (event.key === \"ArrowDown\" || event.key === \"ArrowUp\") {\n        this.checkScrollArrows();\n      }\n    }\n\n  }\n\n  ScrollableList.ɵfac = function ScrollableList_Factory(t) {\n    return new (t || ScrollableList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  ScrollableList.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ScrollableList,\n    selectors: [[\"\", \"ibmScrollableList\", \"\"]],\n    hostBindings: function ScrollableList_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"wheel\", function ScrollableList_wheel_HostBindingHandler($event) {\n          return ctx.onWheel($event);\n        })(\"touchstart\", function ScrollableList_touchstart_HostBindingHandler($event) {\n          return ctx.onTouchStart($event);\n        })(\"touchmove\", function ScrollableList_touchmove_HostBindingHandler($event) {\n          return ctx.onTouchMove($event);\n        })(\"keydown\", function ScrollableList_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      nScrollableList: \"nScrollableList\",\n      scrollEnabled: \"scrollEnabled\",\n      scrollBy: \"scrollBy\",\n      scrollUpTarget: \"scrollUpTarget\",\n      scrollDownTarget: \"scrollDownTarget\"\n    },\n    exportAs: [\"scrollable-list\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return ScrollableList;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DropdownModule = /*#__PURE__*/(() => {\n  class DropdownModule {}\n\n  DropdownModule.ɵfac = function DropdownModule_Factory(t) {\n    return new (t || DropdownModule)();\n  };\n\n  DropdownModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DropdownModule\n  });\n  DropdownModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [DropdownService],\n    imports: [CommonModule, FormsModule, I18nModule, PlaceholderModule, UtilsModule, IconModule]\n  });\n  return DropdownModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DropdownModule, {\n    declarations: function () {\n      return [Dropdown, DropdownList, ScrollableList, AbstractDropdownView];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule, I18nModule, PlaceholderModule, UtilsModule, IconModule];\n    },\n    exports: function () {\n      return [Dropdown, DropdownList, ScrollableList, AbstractDropdownView];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Dropdown, DropdownList, ScrollableList, AbstractDropdownView, DropdownService, DropdownModule }; //# sourceMappingURL=carbon-components-angular-dropdown.js.map","map":null,"metadata":{},"sourceType":"module"}