{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-utils.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ɵngcc0 from '@angular/core';\nexport { PLACEMENTS, Position, defaultPositions, position } from '@carbon/utils-position';\nimport { map } from 'rxjs/operators';\nimport { Injectable, NgZone, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { Subject, from, fromEvent, merge, Observable, Subscription } from 'rxjs';\n\nfunction findSiblingElem(target, direction) {\n  if (target[direction]) {\n    if (target[direction].classList.contains(\"disabled\")) {\n      return findSiblingElem(target[direction], direction);\n    }\n\n    return target[direction];\n  }\n}\n\nfunction findNextElem(target) {\n  return findSiblingElem(target, \"nextElementSibling\");\n}\n\nfunction findPrevElem(target) {\n  return findSiblingElem(target, \"previousElementSibling\");\n} // check for Hight contrast mode\n\n\nfunction HcModeChecker() {\n  let colorTest = \"rgb(255, 0, 0)\";\n  let htmlChecker = document.createElement(\"div\");\n  htmlChecker.classList.add(\"hc-checker\");\n  document.body.appendChild(htmlChecker);\n\n  if (window.getComputedStyle(htmlChecker).backgroundColor.toString() !== colorTest) {\n    document.body.classList.add(\"a11y\");\n  }\n\n  document.body.removeChild(htmlChecker);\n}\n\nfunction focusNextTree(elem, rootElem = null) {\n  if (elem) {\n    let focusable = elem.querySelector(\"[tabindex='0']\");\n\n    if (focusable) {\n      focusable.focus();\n    } else {\n      focusNextElem(elem, rootElem);\n    }\n  }\n}\n\nfunction focusNextElem(elem, rootElem = null) {\n  if (elem) {\n    let nextElem = elem.nextElementSibling;\n\n    if (nextElem) {\n      let focusableElem = nextElem.querySelector(\"[tabindex='0']\");\n\n      if (focusableElem) {\n        focusableElem.focus();\n      } else {\n        focusNextElem(nextElem, rootElem);\n      }\n    } else {\n      if (rootElem) {\n        let nextRootElem = rootElem.nextElementSibling;\n\n        if (nextRootElem) {\n          focusNextTree(nextRootElem, rootElem);\n        }\n      }\n    }\n  }\n}\n\nfunction focusPrevElem(elem, parentRef = null) {\n  if (elem) {\n    let prevElem = elem.previousElementSibling;\n\n    if (prevElem) {\n      let focusableElem = prevElem.querySelector(\"[tabindex='0']\");\n\n      if (focusableElem) {\n        if (focusableElem.getAttribute(\"aria-expanded\") === \"true\") {\n          let lastFocElms = prevElem.querySelectorAll(\"[tabindex='0']\");\n          let arrLen = lastFocElms.length - 1;\n\n          for (let i = arrLen; i >= 0; i--) {\n            if (!!(lastFocElms[i].offsetWidth || lastFocElms[i].offsetHeight || lastFocElms[i].getClientRects().length)) {\n              focusableElem = lastFocElms[i];\n              break;\n            }\n          }\n        }\n\n        focusableElem.focus();\n      } else {\n        focusPrevElem(prevElem, parentRef);\n      }\n    } else {\n      if (parentRef) {\n        parentRef.querySelector(\"[tabindex='0']\").focus();\n      }\n    }\n  }\n}\n\nlet AnimationFrameServiceSingleton = /*#__PURE__*/(() => {\n  class AnimationFrameServiceSingleton {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.frameSource = new Subject();\n      this.tick = this.frameSource.asObservable();\n      this.ngZone.runOutsideAngular(() => {\n        this.animationFrameId = requestAnimationFrame(this.doTick.bind(this));\n      });\n    }\n\n    ngOnDestroy() {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n\n    doTick(frame) {\n      this.frameSource.next(frame);\n      this.ngZone.runOutsideAngular(() => {\n        requestAnimationFrame(this.doTick.bind(this));\n      });\n    }\n\n  }\n\n  AnimationFrameServiceSingleton.ɵfac = function AnimationFrameServiceSingleton_Factory(t) {\n    return new (t || AnimationFrameServiceSingleton)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  AnimationFrameServiceSingleton.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AnimationFrameServiceSingleton,\n    factory: AnimationFrameServiceSingleton.ɵfac\n  });\n  /** @nocollapse */\n\n  return AnimationFrameServiceSingleton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AnimationFrameService = /*#__PURE__*/(() => {\n  class AnimationFrameService {\n    constructor(singleton) {\n      this.singleton = singleton;\n      this.tick = from(this.singleton.tick);\n    }\n\n  }\n\n  AnimationFrameService.ɵfac = function AnimationFrameService_Factory(t) {\n    return new (t || AnimationFrameService)(ɵngcc0.ɵɵinject(AnimationFrameServiceSingleton));\n  };\n\n  AnimationFrameService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AnimationFrameService,\n    factory: AnimationFrameService.ɵfac\n  });\n  /** @nocollapse */\n\n  return AnimationFrameService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // custom deep object merge\n\n\nconst merge$1 = (target, ...objects) => {\n  for (const object of objects) {\n    for (const key in object) {\n      if (object.hasOwnProperty(key)) {\n        // since we're dealing just with JSON this simple check should be enough\n        if (object[key] instanceof Object) {\n          if (!target[key]) {\n            target[key] = {};\n          } // recursively merge into the target\n          // most translations only run 3 or 4 levels deep, so no stack explosions\n\n\n          target[key] = merge$1(target[key], object[key]);\n        } else {\n          target[key] = object[key];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Checks if a given element is scrollable.\n * If the element has an overflow set as part of its computed style it can scroll.\n * @param element the element to check scrollability\n */\n\n\nconst isScrollableElement = element => {\n  const computedStyle = getComputedStyle(element);\n  return computedStyle.overflow === \"auto\" || computedStyle.overflow === \"scroll\" || computedStyle[\"overflow-y\"] === \"auto\" || computedStyle[\"overflow-y\"] === \"scroll\" || computedStyle[\"overflow-x\"] === \"auto\" || computedStyle[\"overflow-x\"] === \"scroll\";\n};\n/**\n * Checks if an element is visible within a container\n * @param element the element to check\n * @param container the container to check\n */\n\n\nconst isVisibleInContainer = (element, container) => {\n  const elementRect = element.getBoundingClientRect();\n  const containerRect = container.getBoundingClientRect(); // If there exists `height: 100%` on the `html` or `body` tag of an application,\n  // it causes the calculation to return true if you need to scroll before the element is seen.\n  // In that case we calculate its visibility based on the window viewport.\n\n  if (container.tagName === \"BODY\" || container.tagName === \"HTML\") {\n    // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in\n    // the screen. This also takes into account partial visibility of an element.\n    const isAboveViewport = elementRect.top < 0 && elementRect.top + element.clientHeight < 0;\n    const isLeftOfViewport = elementRect.left < 0;\n    const isBelowViewport = elementRect.bottom - element.clientHeight > (window.innerHeight || document.documentElement.clientHeight);\n    const isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);\n    const isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);\n    return isVisibleInViewport;\n  }\n\n  return (// This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.\n    elementRect.bottom - element.clientHeight <= containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2 && elementRect.top >= -element.clientHeight\n  );\n};\n\nconst getScrollableParents = node => {\n  const elements = [document.body];\n\n  while (node.parentElement && node !== document.body) {\n    if (isScrollableElement(node)) {\n      elements.push(node);\n    }\n\n    node = node.parentElement;\n  }\n\n  return elements;\n};\n\nconst hasScrollableParents = node => {\n  while (node.parentElement && node !== document.body) {\n    if (isScrollableElement(node)) {\n      return true;\n    }\n\n    node = node.parentElement;\n  }\n\n  return false;\n};\n/**\n * Returns an observable that emits whenever any scrollable parent element scrolls\n *\n * @param node root element to start finding scrolling parents from\n */\n\n\nconst scrollableParentsObservable = node => {\n  const windowScroll = fromEvent(window, \"scroll\", {\n    passive: true\n  }).pipe(map(event => // update the event target to be something useful. In this case `body` is a sensible replacement\n  Object.assign({}, event, {\n    target: document.body\n  })));\n  let observables = [windowScroll]; // walk the parents and subscribe to all the scroll events we can\n\n  while (node.parentElement && node !== document.body) {\n    if (isScrollableElement(node)) {\n      observables.push(fromEvent(node, \"scroll\", {\n        passive: true\n      }));\n    }\n\n    node = node.parentElement;\n  }\n\n  return merge(...observables);\n};\n\nfunction clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction matchesAttr(el, attr, val) {\n  const styles = window.getComputedStyle(el);\n  return val.includes(styles[attr]);\n}\n\nfunction closestAttr(s, t, element) {\n  let el = element;\n\n  if (!element) {\n    return null;\n  }\n\n  do {\n    if (matchesAttr(el, s, t)) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1);\n\n  return null;\n}\n\nlet ElementService = /*#__PURE__*/(() => {\n  class ElementService {\n    constructor(singleton) {\n      this.singleton = singleton;\n      this.tick = from(this.singleton.tick);\n    }\n\n    visibility(target, parentElement = target) {\n      const scrollableParents = getScrollableParents(parentElement);\n      return this.tick.pipe(map(() => {\n        for (const parent of scrollableParents) {\n          if (!isVisibleInContainer(target, parent)) {\n            return {\n              visible: false\n            };\n          }\n        }\n\n        return {\n          visible: true\n        };\n      }));\n    }\n\n  }\n\n  ElementService.ɵfac = function ElementService_Factory(t) {\n    return new (t || ElementService)(ɵngcc0.ɵɵinject(AnimationFrameServiceSingleton));\n  };\n\n  ElementService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ElementService,\n    factory: ElementService.ɵfac\n  });\n  /** @nocollapse */\n\n  return ElementService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst getEventObservable = (targetElement, eventType) => {\n  switch (eventType) {\n    case \"scroll\":\n    case \"resize\":\n    case \"touchstart\":\n    case \"touchmove\":\n    case \"touchend\":\n      return fromEvent(targetElement, eventType, {\n        passive: true\n      });\n\n    default:\n      return fromEvent(targetElement, eventType);\n  }\n};\n\nlet DocumentService = /*#__PURE__*/(() => {\n  class DocumentService {\n    constructor() {\n      this.globalEvents = new Map();\n      this.documentRef = document;\n      this.subscriptions = new Subscription();\n    }\n\n    handleEvent(eventType, callback) {\n      if (!this.globalEvents.has(eventType)) {\n        if (this.documentRef) {\n          this.globalEvents.set(eventType, getEventObservable(this.documentRef, eventType));\n        } else {\n          this.globalEvents.set(eventType, new Observable());\n        }\n      }\n\n      const observable = this.globalEvents.get(eventType);\n      this.subscriptions.add(observable.subscribe(callback));\n    }\n\n    handleClick(callback) {\n      this.handleEvent(\"click\", callback);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.globalEvents = null;\n    }\n\n  }\n\n  DocumentService.ɵfac = function DocumentService_Factory(t) {\n    return new (t || DocumentService)();\n  };\n\n  DocumentService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DocumentService,\n    factory: DocumentService.ɵfac\n  });\n  return DocumentService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet EventService = /*#__PURE__*/(() => {\n  class EventService {\n    constructor(documentService) {\n      this.documentService = documentService;\n      this.subscriptions = new Subscription();\n      this.targets = new WeakMap();\n    }\n\n    on(targetElement, eventType, callback) {\n      if (!this.targets.has(targetElement)) {\n        this.targets.set(targetElement, new Map());\n      }\n\n      const eventMap = this.targets.get(targetElement);\n\n      if (!eventMap.has(eventType)) {\n        eventMap.set(eventType, getEventObservable(targetElement, eventType));\n      }\n\n      const subscription = eventMap.get(eventType).subscribe(callback);\n      this.subscriptions.add(subscription);\n    }\n\n    onDocument(eventType, callback) {\n      this.documentService.handleEvent(eventType, callback);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n  }\n\n  EventService.ɵfac = function EventService_Factory(t) {\n    return new (t || EventService)(ɵngcc0.ɵɵinject(DocumentService));\n  };\n\n  EventService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: EventService,\n    factory: EventService.ɵfac\n  });\n  /** @nocollapse */\n\n  return EventService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // either provides a new instance of DocumentService, or returns the parent\n\n\nfunction DOCUMENT_SERVICE_PROVIDER_FACTORY(parentService) {\n  return parentService || new DocumentService();\n} // DocumentService *must* be a singleton to ensure that we handle events and other document level settings once (and only once)\n\n\nconst DOCUMENT_SERVICE_PROVIDER = {\n  provide: DocumentService,\n  deps: [[new Optional(), new SkipSelf(), DocumentService]],\n  useFactory: DOCUMENT_SERVICE_PROVIDER_FACTORY\n}; // either provides a new instance of AnimationFrameServiceSingleton, or returns the parent\n\nfunction ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY(parentService, ngZone) {\n  return parentService || new AnimationFrameServiceSingleton(ngZone);\n} // AnimationFrameServiceSingleton is a singleton so we don't have a ton of duplicate RAFs firing (better for scheduling)\n\n\nconst ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = {\n  provide: AnimationFrameServiceSingleton,\n  deps: [[new Optional(), new SkipSelf(), AnimationFrameServiceSingleton], NgZone],\n  useFactory: ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY\n};\nlet UtilsModule = /*#__PURE__*/(() => {\n  class UtilsModule {}\n\n  UtilsModule.ɵfac = function UtilsModule_Factory(t) {\n    return new (t || UtilsModule)();\n  };\n\n  UtilsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: UtilsModule\n  });\n  UtilsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [DOCUMENT_SERVICE_PROVIDER, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER, AnimationFrameServiceSingleton, DocumentService, AnimationFrameService, ElementService, EventService]\n  });\n  return UtilsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet _scrollbarWidth = -1;\n\nfunction getScrollbarWidth() {\n  // lets not recreate this whole thing every time\n  if (_scrollbarWidth >= 0) {\n    return _scrollbarWidth;\n  } // do the calculations the first time\n\n\n  const outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.width = \"100px\";\n  outer.style.msOverflowStyle = \"scrollbar\"; // needed for WinJS apps\n\n  document.body.appendChild(outer);\n  const widthNoScroll = outer.offsetWidth; // force scrollbars\n\n  outer.style.overflow = \"scroll\"; // add innerdiv\n\n  const inner = document.createElement(\"div\");\n  inner.style.width = \"100%\";\n  outer.appendChild(inner);\n  const widthWithScroll = inner.offsetWidth; // remove divs\n\n  outer.parentNode.removeChild(outer);\n  _scrollbarWidth = widthNoScroll - widthWithScroll;\n  return _scrollbarWidth;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { HcModeChecker, findNextElem, findPrevElem, focusNextElem, focusNextTree, focusPrevElem, AnimationFrameService, AnimationFrameServiceSingleton, merge$1 as merge, getScrollableParents, hasScrollableParents, isScrollableElement, isVisibleInContainer, scrollableParentsObservable, clone, closestAttr, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY, DOCUMENT_SERVICE_PROVIDER, DOCUMENT_SERVICE_PROVIDER_FACTORY, UtilsModule, getScrollbarWidth, ElementService, EventService, getEventObservable, DocumentService }; //# sourceMappingURL=carbon-components-angular-utils.js.map","map":null,"metadata":{},"sourceType":"module"}