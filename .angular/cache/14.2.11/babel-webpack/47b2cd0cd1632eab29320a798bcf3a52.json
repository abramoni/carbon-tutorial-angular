{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-common.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet tabbableSelector = \"a[href], area[href], input:not([disabled]):not([tabindex=\\'-1\\']), \" + \"button:not([disabled]):not([tabindex=\\'-1\\']),select:not([disabled]):not([tabindex=\\'-1\\']), \" + \"textarea:not([disabled]):not([tabindex=\\'-1\\']), \" + \"iframe, object, embed, *[tabindex]:not([tabindex=\\'-1\\']), *[contenteditable=true]\";\nlet tabbableSelectorIgnoreTabIndex = \"a[href], area[href], input:not([disabled]), \" + \"button:not([disabled]),select:not([disabled]), \" + \"textarea:not([disabled]), \" + \"iframe, object, embed, *[tabindex], *[contenteditable=true]\";\n\nfunction getFocusElementList(element, selector = tabbableSelector) {\n  let elements = element.querySelectorAll(selector);\n  return elements ? Array.prototype.filter.call(elements, el => isVisible(el)) : elements;\n}\n\nfunction isFocusInFirstItem(event, list) {\n  if (list.length > 0) {\n    return (event.target || event.srcElement) === list[0];\n  }\n\n  return false;\n}\n\nfunction isFocusInLastItem(event, list) {\n  if (list.length > 0) {\n    return (event.target || event.srcElement) === list[list.length - 1];\n  }\n\n  return false;\n}\n\nfunction isElementFocused(event, element) {\n  return (event.target || event.srcElement) === element;\n}\n\nfunction focusFirstFocusableElement(list) {\n  if (list.length > 0) {\n    list[0].focus();\n    return true;\n  }\n\n  return false;\n}\n\nfunction focusLastFocusableElement(list) {\n  if (list.length > 0) {\n    list[list.length - 1].focus();\n    return true;\n  }\n\n  return false;\n}\n\nfunction isVisible(element) {\n  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n\nfunction cycleTabs(event, element) {\n  if (event.key === \"Tab\") {\n    let list = getFocusElementList(element);\n    let focusChanged = false;\n\n    if (event.shiftKey) {\n      if (isFocusInFirstItem(event, list) || isElementFocused(event, element)) {\n        focusChanged = focusLastFocusableElement(list);\n      }\n    } else {\n      if (isFocusInLastItem(event, list)) {\n        focusChanged = focusFirstFocusableElement(list);\n      }\n    }\n\n    if (focusChanged) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n}\n/**\n * Does what python's `range` function does, with a slightly different\n * signature because of Typescript limitations.\n *\n * Useful for numbered loops in angular templates, since we can do\n * a normal for loop.\n *\n * @export\n * @param stop Generate numbers up to, but not including this number\n * @param [start=0] Starting number of the sequence\n * @param [step=1] Difference between each number in the sequence\n * @returns an array with resulting numbers\n */\n\n\nfunction range(stop, start = 0, step = 1) {\n  return Array(Math.ceil((stop - start) / step)).fill(0).map((x, i) => i * step + start);\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { cycleTabs, focusFirstFocusableElement, focusLastFocusableElement, getFocusElementList, isElementFocused, isFocusInFirstItem, isFocusInLastItem, isVisible, tabbableSelector, tabbableSelectorIgnoreTabIndex, range }; //# sourceMappingURL=carbon-components-angular-common.js.map","map":null,"metadata":{},"sourceType":"module"}