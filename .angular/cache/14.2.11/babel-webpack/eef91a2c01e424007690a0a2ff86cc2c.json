{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-dialog.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Subscription } from 'rxjs';\nimport { tabbableSelector, cycleTabs, getFocusElementList, isFocusInLastItem, isFocusInFirstItem } from 'carbon-components-angular/common';\nimport Position, { position } from '@carbon/utils-position';\nimport { Injector, ComponentFactoryResolver, Injectable, Component, Input, Output, EventEmitter, ElementRef, ViewChild, HostListener, Optional, Directive, ViewContainerRef, HostBinding, TemplateRef, ContentChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { I18n, I18nModule } from 'carbon-components-angular/i18n';\nimport { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';\nimport { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';\nimport { AnimationFrameService, ElementService, EventService, closestAttr, UtilsModule } from 'carbon-components-angular/utils';\nimport { IconModule } from 'carbon-components-angular/icon';\n/**\n * An enum of the various reasons a dialog may close. For use with `CloseMeta` and `shouldClose`\n *\n * It's expected that `interaction` will be a common closure reason.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'carbon-components-angular/placeholder';\nimport * as ɵngcc2 from 'carbon-components-angular/utils';\nimport * as ɵngcc3 from '@angular/common';\nimport * as ɵngcc4 from 'carbon-components-angular/i18n';\nimport * as ɵngcc5 from 'carbon-components-angular/experimental';\nimport * as ɵngcc6 from 'carbon-components-angular/icon';\nconst _c0 = [\"dialog\"];\n\nfunction Tooltip_3_ng_template_0_Template(rf, ctx) {}\n\nconst _c1 = function (a0) {\n  return {\n    tooltip: a0\n  };\n};\n\nfunction Tooltip_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Tooltip_3_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.dialogConfig.content)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1));\n  }\n}\n\nfunction Tooltip_p_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"p\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r2.dialogConfig.content, \" \");\n  }\n}\n\nconst _c2 = function (a0, a1, a2, a3, a4) {\n  return {\n    \"bx--tooltip--bottom\": a0,\n    \"bx--tooltip--top\": a1,\n    \"bx--tooltip--align-start\": a2,\n    \"bx--tooltip--align-center\": a3,\n    \"bx--tooltip--align-end\": a4\n  };\n};\n\nconst _c3 = [\"*\"];\n\nconst _c4 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    \"bx--tooltip--bottom\": a0,\n    \"bx--tooltip--top\": a1,\n    \"bx--tooltip--left\": a2,\n    \"bx--tooltip--right\": a3,\n    \"bx--tooltip--align-start\": a4,\n    \"bx--tooltip--align-center\": a5,\n    \"bx--tooltip--align-end\": a6\n  };\n};\n\nfunction OverflowMenuPane_ng_template_2_Template(rf, ctx) {}\n\nconst _c5 = function (a0) {\n  return {\n    \"bx--overflow-menu--flip\": a0\n  };\n};\n\nconst _c6 = function (a0) {\n  return {\n    overflowMenu: a0\n  };\n};\n\nfunction OverflowMenuCustomPane_ng_template_2_Template(rf, ctx) {}\n\nfunction OverflowMenu_1_ng_template_0_Template(rf, ctx) {}\n\nfunction OverflowMenu_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, OverflowMenu_1_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.customTrigger);\n  }\n}\n\nfunction OverflowMenu_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0);\n  }\n}\n\nfunction OverflowMenu_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"svg\", 5);\n  }\n}\n\nconst _c7 = function (a0) {\n  return {\n    \"bx--overflow-menu--open\": a0\n  };\n};\n\nfunction OverflowMenuOption_button_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nfunction OverflowMenuOption_button_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 3);\n    ɵngcc0.ɵɵlistener(\"focus\", function OverflowMenuOption_button_0_Template_button_focus_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      const ctx_r5 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r5.onFocus());\n    })(\"blur\", function OverflowMenuOption_button_0_Template_button_blur_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      const ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r7.onBlur());\n    })(\"click\", function OverflowMenuOption_button_0_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r8.onClick());\n    });\n    ɵngcc0.ɵɵtemplate(1, OverflowMenuOption_button_0_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n\n    const _r2 = ɵngcc0.ɵɵreference(3);\n\n    ɵngcc0.ɵɵclassMapInterpolate1(\"bx--overflow-menu-options__btn \", ctx_r0.innerClass, \"\");\n    ɵngcc0.ɵɵproperty(\"tabindex\", ctx_r0.tabIndex)(\"disabled\", ctx_r0.disabled);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r0.title);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\n\nfunction OverflowMenuOption_a_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nfunction OverflowMenuOption_a_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 5);\n    ɵngcc0.ɵɵlistener(\"focus\", function OverflowMenuOption_a_1_Template_a_focus_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r11);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r10.onFocus());\n    })(\"blur\", function OverflowMenuOption_a_1_Template_a_blur_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r11);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r12.onBlur());\n    })(\"click\", function OverflowMenuOption_a_1_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r11);\n      const ctx_r13 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r13.onClick());\n    });\n    ɵngcc0.ɵɵtemplate(1, OverflowMenuOption_a_1_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n\n    const _r2 = ɵngcc0.ɵɵreference(3);\n\n    ɵngcc0.ɵɵclassMapInterpolate1(\"bx--overflow-menu-options__btn \", ctx_r1.innerClass, \"\");\n    ɵngcc0.ɵɵproperty(\"tabindex\", ctx_r1.tabIndex)(\"href\", ctx_r1.href, ɵngcc0.ɵɵsanitizeUrl);\n    ɵngcc0.ɵɵattribute(\"disabled\", ctx_r1.disabled)(\"target\", ctx_r1.target)(\"rel\", ctx_r1.rel)(\"title\", ctx_r1.title);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\n\nfunction OverflowMenuOption_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 6);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nvar CloseReasons = /*#__PURE__*/(() => {\n  (function (CloseReasons) {\n    /**\n     * For when the component is closed by being destroyed\n     */\n    CloseReasons[CloseReasons[\"destroyed\"] = 0] = \"destroyed\";\n    /**\n     * For use in cases where the dialog closes for programmatic reasons other than destruction\n     */\n\n    CloseReasons[CloseReasons[\"programmatic\"] = 1] = \"programmatic\";\n    /**\n     * interaction reasons will also provide a target for the interaction\n     */\n\n    CloseReasons[CloseReasons[\"interaction\"] = 2] = \"interaction\";\n    /**\n     * For use in cases where the dialog closes due to being hidden\n     */\n\n    CloseReasons[CloseReasons[\"hidden\"] = 3] = \"hidden\";\n  })(CloseReasons || (CloseReasons = {}));\n\n  return CloseReasons;\n})();\n\n/**\n * `Dialog` object to be injected into other components.\n */\nclass DialogService {\n  /**\n   * Creates an instance of `DialogService`.\n   */\n  constructor(componentFactoryResolver, injector, placeholderService) {\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.injector = injector;\n    this.placeholderService = placeholderService;\n  }\n  /**\n   * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct\n   */\n\n\n  static closeAll() {\n    DialogService.dialogRefs.forEach(ref => ref.instance.doClose({\n      reason: CloseReasons.programmatic\n    }));\n    DialogService.dialogRefs.clear();\n  }\n  /**\n   * Set the context for the service. For example, the `component` property can be used to set the\n   * default component that should be created by the service, for a given instance of the service.\n   * @param options `{ component: any }` where `component` is a component that extends `dialog.component`\n   */\n\n\n  setContext(options) {\n    this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(options.component);\n  }\n  /**\n   * If `dialogRef` is defined, the Dialog is already open. If\n   * `dialogRef` is undefined, we create the `Dialog` component and reference to it.\n   * A subscription is created to track if the `Dialog` should close.\n   *\n   * @param viewContainer a `ViewContainerRef` to instantiate the component against.\n   * May be `null` if an `ibm-placeholder` exists and `dialogConfig.appendInline` is false\n   * @param dialogConfig the `DialogConfig` for the component\n   */\n\n\n  open(viewContainer, dialogConfig, component) {\n    let componentFactory = this.componentFactory;\n\n    if (component) {\n      componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);\n    }\n\n    let dialogRef;\n\n    if (dialogConfig.appendInline) {\n      // add our component to the view\n      dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);\n    } else if (!this.placeholderService.hasPlaceholderRef()) {\n      dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);\n\n      if (dialogRef) {\n        setTimeout(() => {\n          window.document.querySelector(\"body\").appendChild(dialogRef.location.nativeElement);\n        });\n      }\n    } else {\n      dialogRef = this.placeholderService.createComponent(componentFactory, this.injector);\n    } // keep track of all initialized dialogs\n\n\n    DialogService.dialogRefs.add(dialogRef); // initialize some extra options\n\n    dialogConfig[\"previouslyFocusedElement\"] = document.activeElement;\n    dialogRef.instance.dialogConfig = dialogConfig;\n    dialogRef.instance.elementRef.nativeElement.focus();\n    return dialogRef;\n  }\n  /**\n   * On close of `Dialog` item, sets focus back to previous item, unsets\n   * the current `dialogRef` item. Unsubscribes to the event of `Dialog` close.\n   *\n   * @param dialogRef the dialogRef to close\n   */\n\n\n  close(dialogRef) {\n    // to handle the case where we have a null `this.dialogRef`\n    if (!dialogRef) {\n      return;\n    }\n\n    const elementToFocus = dialogRef.instance.dialogConfig[\"previouslyFocusedElement\"];\n    dialogRef.destroy(); // update the globally tracked dialogRefs\n\n    if (DialogService.dialogRefs.has(dialogRef)) {\n      DialogService.dialogRefs.delete(dialogRef);\n    } // Keeps the focus on the dialog trigger if there are no focusable elements. Change focus to previously focused element\n    // if there are focusable elements in the dialog.\n\n\n    if (!dialogRef.location.nativeElement.querySelectorAll(tabbableSelector)) {\n      elementToFocus.focus();\n    }\n  }\n  /**\n   * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct\n   *\n   * @deprecated since v4. Use the static `DialogService.closeAll` instead\n   */\n\n\n  closeAll() {\n    DialogService.closeAll();\n  }\n  /**\n   * Fix for safari hijacking clicks.\n   *\n   * Runs on `ngOnInit` of every dialog. Ensures we don't have multiple listeners\n   * because having many of them could degrade performance in certain cases (and is\n   * not necessary for our use case)\n   *\n   * This is an internally used function, can change at any point (even get removed)\n   * and changes to it won't be considered a breaking change. Use at your own risk.\n   */\n\n\n  singletonClickListen() {\n    if (!DialogService.listeningForBodyClicks) {\n      document.body.firstElementChild.addEventListener(\"click\", () => null, true);\n      DialogService.listeningForBodyClicks = true;\n    }\n  }\n\n}\n\nDialogService.ɵfac = function DialogService_Factory(t) {\n  return new (t || DialogService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc1.PlaceholderService));\n};\n\nDialogService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DialogService,\n  factory: DialogService.ɵfac\n});\n/**\n * Used in `singletonClickListen`, don't count on its existence and values.\n */\n\nDialogService.listeningForBodyClicks = false;\n/**\n * A set of all known dialog components\n */\n\nDialogService.dialogRefs = new Set();\n/** @nocollapse */\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Implements a `Dialog` that can be positioned anywhere on the page.\n * Used to implement a popover or tooltip.\n */\n\n\nlet Dialog = /*#__PURE__*/(() => {\n  class Dialog {\n    /**\n     * Creates an instance of `Dialog`.\n     * @param elementRef\n     * @param elementService\n     */\n    constructor(elementRef, elementService, animationFrameService = null) {\n      this.elementRef = elementRef;\n      this.elementService = elementService;\n      this.animationFrameService = animationFrameService;\n      /**\n       * Emits event that handles the closing of a `Dialog` object.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Stores the data received from `dialogConfig`.\n       */\n\n      this.data = {};\n      this.visibilitySubscription = new Subscription();\n      this.animationFrameSubscription = new Subscription();\n      /**\n       * Handles offsetting the `Dialog` item based on the defined position\n       * to not obscure the content beneath.\n       */\n\n      this.addGap = {\n        \"left\": pos => position.addOffset(pos, 0, -this.dialogConfig.gap),\n        \"right\": pos => position.addOffset(pos, 0, this.dialogConfig.gap),\n        \"top\": pos => position.addOffset(pos, -this.dialogConfig.gap),\n        \"bottom\": pos => position.addOffset(pos, this.dialogConfig.gap),\n        \"left-bottom\": pos => position.addOffset(pos, 0, -this.dialogConfig.gap),\n        \"right-bottom\": pos => position.addOffset(pos, 0, this.dialogConfig.gap)\n      };\n      /**\n       * Extra placements. Child classes can add to this for use in `placeDialog`.\n       */\n\n      this.placements = {};\n    }\n    /**\n     * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.\n     */\n\n\n    ngOnInit() {\n      this.placement = this.dialogConfig.placement.split(\",\")[0];\n      this.data = this.dialogConfig.data; // run any additional initialization code that consuming classes may have\n\n      this.onDialogInit();\n    }\n    /**\n     * After the DOM is ready, focus is set and dialog is placed\n     * in respect to the parent element.\n     */\n\n\n    ngAfterViewInit() {\n      const dialogElement = this.dialog.nativeElement; // split the wrapper class list and apply separately to avoid IE\n      // 1. throwing an error due to assigning a readonly property (classList)\n      // 2. throwing a SyntaxError due to passing an empty string to `add`\n\n      if (this.dialogConfig.wrapperClass) {\n        for (const extraClass of this.dialogConfig.wrapperClass.split(\" \")) {\n          dialogElement.classList.add(extraClass);\n        }\n      } // only focus the dialog if there are focusable elements within the dialog\n\n\n      if (getFocusElementList(this.dialog.nativeElement).length > 0) {\n        dialogElement.focus();\n      }\n\n      const parentElement = this.dialogConfig.parentRef.nativeElement;\n\n      if (this.animationFrameService) {\n        this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {\n          this.placeDialog();\n        });\n      }\n\n      if (this.dialogConfig.closeWhenHidden) {\n        this.visibilitySubscription = this.elementService.visibility(parentElement, parentElement).subscribe(value => {\n          this.placeDialog();\n\n          if (!value.visible) {\n            this.doClose({\n              reason: CloseReasons.hidden\n            });\n          }\n        });\n      }\n\n      this.placeDialog(); // run afterDialogViewInit on the next tick\n\n      setTimeout(() => this.afterDialogViewInit());\n    }\n    /**\n     * Empty method to be overridden by consuming classes to run any additional initialization code.\n     */\n\n\n    onDialogInit() {}\n    /**\n     * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.\n     * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM\n     */\n\n\n    afterDialogViewInit() {}\n    /**\n     * Uses the position service to position the `Dialog` in screen space\n     */\n\n\n    placeDialog() {\n      const positionService = new Position(this.placements); // helper to find the position based on the current/given environment\n\n      const findPosition = (reference, target, placement) => {\n        let pos;\n\n        if (this.dialogConfig.appendInline) {\n          pos = this.addGap[placement](positionService.findRelative(reference, target, placement));\n        } else {\n          pos = this.addGap[placement](positionService.findAbsolute(reference, target, placement));\n        }\n\n        if (this.dialogConfig.offset) {\n          // Apply vertical and horizontal offsets given through the dialogConfig\n          pos.top = pos.top + this.dialogConfig.offset.y;\n          pos.left = pos.left + this.dialogConfig.offset.x;\n        }\n\n        return pos;\n      };\n\n      let parentEl = this.dialogConfig.parentRef.nativeElement;\n      let el = this.dialog.nativeElement;\n      let dialogPlacement = this.placement; // split always returns an array, so we can just use the auto position logic\n      // for single positions too\n\n      const placements = this.dialogConfig.placement.split(\",\"); // find the best placement\n\n      dialogPlacement = positionService.findBestPlacement(parentEl, el, placements); // calculate the final position\n\n      const pos = findPosition(parentEl, el, dialogPlacement); // update the element\n\n      positionService.setElement(el, pos);\n      setTimeout(() => {\n        this.placement = dialogPlacement;\n      });\n    }\n    /**\n     * Sets up a KeyboardEvent to close `Dialog` with Escape key.\n     * @param event\n     */\n\n\n    escapeClose(event) {\n      switch (event.key) {\n        case \"Esc\": // IE specific value\n\n        case \"Escape\":\n          {\n            event.stopImmediatePropagation();\n            this.doClose({\n              reason: CloseReasons.interaction,\n              target: event.target\n            });\n            break;\n          }\n\n        case \"Tab\":\n          {\n            cycleTabs(event, this.elementRef.nativeElement);\n            break;\n          }\n      }\n    }\n    /**\n     * Sets up a event Listener to close `Dialog` if click event occurs outside\n     * `Dialog` object.\n     * @param event\n     */\n\n\n    clickClose(event) {\n      if (!this.elementRef.nativeElement.contains(event.target) && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {\n        this.doClose({\n          reason: CloseReasons.interaction,\n          target: event.target\n        });\n      }\n    }\n    /**\n     * Closes `Dialog` object by emitting the close event upwards to parents.\n     */\n\n\n    doClose(meta = {\n      reason: CloseReasons.interaction\n    }) {\n      this.close.emit(meta);\n    }\n    /**\n     * At destruction of component, `Dialog` unsubscribes from all the subscriptions.\n     */\n\n\n    ngOnDestroy() {\n      this.visibilitySubscription.unsubscribe();\n\n      if (this.animationFrameSubscription) {\n        this.animationFrameSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  Dialog.ɵfac = function Dialog_Factory(t) {\n    return new (t || Dialog)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8));\n  };\n\n  Dialog.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Dialog,\n    selectors: [[\"ibm-dialog\"]],\n    viewQuery: function Dialog_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dialog = _t.first);\n      }\n    },\n    hostBindings: function Dialog_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function Dialog_keydown_HostBindingHandler($event) {\n          return ctx.escapeClose($event);\n        })(\"click\", function Dialog_click_HostBindingHandler($event) {\n          return ctx.clickClose($event);\n        }, false, ɵngcc0.ɵɵresolveDocument);\n      }\n    },\n    inputs: {\n      dialogConfig: \"dialogConfig\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function Dialog_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return Dialog;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A generic directive that can be inherited from to create dialogs (for example, a tooltip or popover)\n *\n * This class contains the relevant initialization code, specific templates, options, and additional inputs\n * should be specified in the derived class.\n *\n * NOTE: All child classes should add `DialogService` as a provider, otherwise they will lose context that\n * the service relies on.\n */\n\n\nlet DialogDirective = /*#__PURE__*/(() => {\n  class DialogDirective {\n    /**\n     * Creates an instance of DialogDirective.\n     * @param elementRef\n     * @param viewContainerRef\n     * @param dialogService\n     * @param eventService\n     */\n    constructor(elementRef, viewContainerRef, dialogService, eventService) {\n      this.elementRef = elementRef;\n      this.viewContainerRef = viewContainerRef;\n      this.dialogService = dialogService;\n      this.eventService = eventService;\n      /**\n       * Title for the dialog\n       */\n\n      this.title = \"\";\n      /**\n       * Defines how the Dialog is triggered.(Hover and click behave the same on mobile - both respond to a single tap).\n       * Do not add focusable elements if trigger is `hover` or `mouseenter`.\n       */\n\n      this.trigger = \"click\";\n      /**\n       * Defines how the Dialog close event is triggered.\n       *\n       * [See here](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event)\n       * for more on the difference between `mouseleave` and `mouseout`.\n       *\n       * Defaults to `click` when `trigger` is set to `click`.\n       */\n\n      this.closeTrigger = \"mouseleave\";\n      /**\n       * Placement of the dialog, usually relative to the element the directive is on.\n       */\n\n      this.placement = \"left\";\n      /**\n       * Spacing between the dialog and it's triggering element\n       */\n\n      this.gap = 0;\n      /**\n       * Set to `true` to open the dialog next to the triggering component\n       */\n\n      this.appendInline = false;\n      /**\n       * Optional data for templates\n       */\n\n      this.data = {};\n      this.isOpen = false;\n      /**\n       * This prevents the dialog from being toggled\n       */\n\n      this.disabled = false;\n      /**\n       * Emits an event when the dialog is closed\n       */\n\n      this.onClose = new EventEmitter();\n      /**\n       * Emits an event when the dialog is opened\n       */\n\n      this.onOpen = new EventEmitter();\n      /**\n       * Emits an event when the state of `isOpen` changes. Allows `isOpen` to be double bound\n       */\n\n      this.isOpenChange = new EventEmitter();\n      this.role = \"button\";\n      this.hasPopup = true;\n    }\n\n    get ariaOwns() {\n      return this.isOpen ? this.dialogConfig.compID : null;\n    }\n\n    ngOnChanges(changes) {\n      // set the config object (this can [and should!] be added to in child classes depending on what they need)\n      this.dialogConfig = {\n        title: this.title,\n        content: this.ibmDialog,\n        placement: this.placement,\n        parentRef: this.elementRef,\n        gap: this.gap,\n        trigger: this.trigger,\n        closeTrigger: this.closeTrigger,\n        shouldClose: this.shouldClose || (() => true),\n        appendInline: this.appendInline,\n        wrapperClass: this.wrapperClass,\n        data: this.data,\n        offset: this.offset,\n        disabled: this.disabled\n      };\n\n      if (changes.isOpen) {\n        if (changes.isOpen.currentValue) {\n          this.open();\n        } else if (!changes.isOpen.firstChange) {\n          this.close({\n            reason: CloseReasons.programmatic\n          });\n        }\n      } // Run any code a child class may need.\n\n\n      this.onDialogChanges(changes);\n      this.updateConfig();\n    }\n    /**\n     * Sets the config object and binds events for hovering or clicking before\n     * running code from child class.\n     */\n\n\n    ngOnInit() {\n      // fix for safari hijacking clicks\n      this.dialogService.singletonClickListen();\n      const element = this.elementRef.nativeElement;\n      this.eventService.on(element, \"keydown\", event => {\n        // \"Esc\" is an IE specific value\n        if (event.target === this.dialogConfig.parentRef.nativeElement && (event.key === \"Tab\" || event.key === \"Tab\" && event.shiftKey) || event.key === \"Escape\" || event.key === \"Esc\") {\n          this.close({\n            reason: CloseReasons.interaction,\n            target: event.target\n          });\n        }\n      }); // bind events for hovering or clicking the host\n\n      if (this.trigger === \"hover\" || this.trigger === \"mouseenter\") {\n        this.eventService.on(element, \"mouseenter\", this.open.bind(this));\n        this.eventService.on(element, this.closeTrigger, event => {\n          this.close({\n            reason: CloseReasons.interaction,\n            target: event.target\n          });\n        });\n        this.eventService.on(element, \"focus\", this.open.bind(this));\n        this.eventService.on(element, \"blur\", event => {\n          this.close({\n            reason: CloseReasons.interaction,\n            target: event.target\n          });\n        });\n      } else {\n        this.eventService.on(element, \"click\", event => {\n          this.toggle({\n            reason: CloseReasons.interaction,\n            target: event.target\n          });\n        });\n        this.eventService.on(element, \"keydown\", event => {\n          // \"Spacebar\" is an IE specific value\n          if (event.key === \"Enter\" || event.key === \" \" || event.key === \"Spacebar\") {\n            setTimeout(() => {\n              this.open();\n            });\n          }\n        });\n      }\n\n      DialogDirective.dialogCounter++;\n      this.dialogConfig.compID = \"dialog-\" + DialogDirective.dialogCounter; // run any code a child class may need\n\n      this.onDialogInit();\n      this.updateConfig();\n    }\n    /**\n     * When the host dies, kill the popover.\n     * - Useful for use in a modal or similar.\n     */\n\n\n    ngOnDestroy() {\n      this.close({\n        reason: CloseReasons.destroyed\n      });\n    }\n    /**\n     * Helper method to call dialogService 'open'.\n     * - Enforce accessibility by updating an aria attr for nativeElement.\n     */\n\n\n    open() {\n      // don't allow dialogs to be opened if they're already open\n      if (this.dialogRef || this.disabled) {\n        return;\n      } // actually open the dialog, emit events, and set the open state\n\n\n      this.dialogRef = this.dialogService.open(this.viewContainerRef, this.dialogConfig);\n      this.isOpen = true;\n      this.onOpen.emit();\n      this.isOpenChange.emit(true); // Handles emitting all the close events to clean everything up\n      // Also enforce accessibility on close by updating an aria attr on the nativeElement.\n\n      this.dialogRef.instance.close.subscribe(meta => {\n        if (!this.dialogRef) {\n          return;\n        }\n\n        if (this.dialogConfig.shouldClose && this.dialogConfig.shouldClose(meta)) {\n          // close the dialog, emit events, and clear out the open states\n          this.dialogService.close(this.dialogRef);\n          this.dialogRef = null;\n          this.isOpen = false;\n          this.onClose.emit();\n          this.isOpenChange.emit(false);\n        }\n      });\n      return this.dialogRef;\n    }\n    /**\n     * Helper method to toggle the open state of the dialog\n     */\n\n\n    toggle(meta = {\n      reason: CloseReasons.interaction\n    }) {\n      if (!this.isOpen) {\n        this.open();\n      } else {\n        this.close(meta);\n      }\n    }\n    /**\n     * Helper method to close the dialogRef.\n     */\n\n\n    close(meta = {\n      reason: CloseReasons.interaction\n    }) {\n      if (this.dialogRef) {\n        this.dialogRef.instance.doClose(meta);\n      }\n    }\n    /**\n     * Empty method for child classes to override and specify additional init steps.\n     * Run after DialogDirective completes it's ngOnInit.\n     */\n\n\n    onDialogInit() {}\n    /**\n     * Empty method for child to override and specify additional on changes steps.\n     * run after DialogDirective completes it's ngOnChanges.\n     */\n\n\n    onDialogChanges(_changes) {}\n\n    updateConfig() {}\n\n  }\n\n  DialogDirective.ɵfac = function DialogDirective_Factory(t) {\n    return new (t || DialogDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DialogService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService));\n  };\n\n  DialogDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DialogDirective,\n    selectors: [[\"\", \"ibmDialog\", \"\"]],\n    hostVars: 4,\n    hostBindings: function DialogDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.isOpen)(\"role\", ctx.role)(\"aria-haspopup\", ctx.hasPopup)(\"aria-owns\", ctx.ariaOwns);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      trigger: \"trigger\",\n      closeTrigger: \"closeTrigger\",\n      placement: \"placement\",\n      gap: \"gap\",\n      appendInline: \"appendInline\",\n      data: \"data\",\n      isOpen: \"isOpen\",\n      disabled: \"disabled\",\n      ibmDialog: \"ibmDialog\",\n      offset: \"offset\",\n      wrapperClass: \"wrapperClass\",\n      shouldClose: \"shouldClose\"\n    },\n    outputs: {\n      onClose: \"onClose\",\n      onOpen: \"onOpen\",\n      isOpenChange: \"isOpenChange\"\n    },\n    exportAs: [\"ibmDialog\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([DialogService]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  DialogDirective.dialogCounter = 0;\n  /** @nocollapse */\n\n  return DialogDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Extend the `Dialog` component to create a tooltip for exposing content.\n */\n\n\nlet Tooltip = /*#__PURE__*/(() => {\n  class Tooltip extends Dialog {\n    constructor(elementRef, elementService, animationFrameService = null) {\n      super(elementRef, elementService, animationFrameService);\n      this.elementRef = elementRef;\n      this.elementService = elementService;\n      this.animationFrameService = animationFrameService;\n      this.style = \"inline-block\";\n      /**\n       * Value is set to `true` if the `Tooltip` is to display a `TemplateRef` instead of a string.\n       */\n\n      this.hasContentTemplate = false;\n      /**\n       * Sets the role of the tooltip. If there's no focusable content we leave it as a `tooltip`,\n       * if there _is_ focusable content we switch to the interactive `dialog` role.\n       */\n\n      this.role = \"tooltip\";\n    }\n    /**\n     * Check whether there is a template for the `Tooltip` content.\n     */\n\n\n    onDialogInit() {\n      this.addGap[\"bottom\"] = pos => {\n        const adjustedOffset = this.getAdjustOffset();\n        return position.addOffset(pos, 3 + adjustedOffset.top, 0 + adjustedOffset.left);\n      };\n\n      this.addGap[\"top\"] = pos => {\n        const adjustedOffset = this.getAdjustOffset();\n        return position.addOffset(pos, -10 + adjustedOffset.top, 0 + adjustedOffset.left);\n      };\n\n      this.addGap[\"left\"] = pos => {\n        const adjustedOffset = this.getAdjustOffset();\n        return position.addOffset(pos, -3 + adjustedOffset.top, -6 + adjustedOffset.left);\n      };\n\n      this.addGap[\"right\"] = pos => {\n        const adjustedOffset = this.getAdjustOffset();\n        return position.addOffset(pos, -3 + adjustedOffset.top, 6 + adjustedOffset.left);\n      };\n\n      this.hasContentTemplate = this.dialogConfig.content instanceof TemplateRef;\n    }\n\n    getAdjustOffset() {\n      const closestWithPos = closestAttr(\"position\", [\"relative\", \"fixed\", \"absolute\"], this.elementRef.nativeElement.parentElement);\n      const topPos = closestWithPos ? closestWithPos.getBoundingClientRect().top * -1 : 0;\n      const leftPos = closestWithPos ? closestWithPos.getBoundingClientRect().left * -1 : 0;\n      return {\n        top: topPos,\n        left: leftPos\n      };\n    }\n\n    afterDialogViewInit() {\n      const focusableElements = getFocusElementList(this.dialog.nativeElement);\n\n      if (focusableElements.length > 0) {\n        this.role = \"dialog\";\n        focusableElements[0].focus();\n      }\n    }\n\n  }\n\n  Tooltip.ɵfac = function Tooltip_Factory(t) {\n    return new (t || Tooltip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8));\n  };\n\n  Tooltip.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Tooltip,\n    selectors: [[\"ibm-tooltip\"]],\n    hostVars: 2,\n    hostBindings: function Tooltip_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.style);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[1, \"bx--tooltip\", \"bx--tooltip--shown\", 3, \"id\"], [\"dialog\", \"\"], [\"aria-hidden\", \"true\", 1, \"bx--tooltip__caret\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function Tooltip_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵelement(2, \"span\", 2);\n        ɵngcc0.ɵɵtemplate(3, Tooltip_3_Template, 1, 4, null, 3);\n        ɵngcc0.ɵɵtemplate(4, Tooltip_p_4_Template, 2, 1, \"p\", 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.dialogConfig.compID);\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"data-floating-menu-direction\", ctx.placement);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.hasContentTemplate);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.hasContentTemplate);\n      }\n    },\n    dependencies: [ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return Tooltip;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TooltipDefinition = /*#__PURE__*/(() => {\n  class TooltipDefinition {\n    constructor() {\n      this.id = `definition-tooltip-${TooltipDefinition.tooltipItemCount++}`;\n      /**\n       * The placement in which the `TooltipDefinition` appears.\n       * Set to `\"top\"` to have it positioned above the trigger text\n       */\n\n      this.placement = \"bottom\";\n      this.alignment = \"start\";\n      this.className = true;\n      this.accessibility = true;\n    }\n\n  }\n\n  TooltipDefinition.ɵfac = function TooltipDefinition_Factory(t) {\n    return new (t || TooltipDefinition)();\n  };\n\n  TooltipDefinition.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TooltipDefinition,\n    selectors: [[\"ibm-tooltip-definition\"]],\n    hostVars: 4,\n    hostBindings: function TooltipDefinition_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--tooltip--definition\", ctx.className)(\"bx--tooltip--a11y\", ctx.accessibility);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      placement: \"placement\",\n      alignment: \"alignment\",\n      content: \"content\"\n    },\n    ngContentSelectors: _c3,\n    decls: 4,\n    vars: 10,\n    consts: [[\"type\", \"button\", 1, \"bx--tooltip__trigger\", \"bx--tooltip--a11y\", \"bx--tooltip__trigger--definition\", 3, \"ngClass\"], [\"role\", \"tooltip\", 1, \"bx--assistive-text\", 3, \"id\"]],\n    template: function TooltipDefinition_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"button\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 1);\n        ɵngcc0.ɵɵtext(3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction5(4, _c2, ctx.placement === \"bottom\", ctx.placement === \"top\", ctx.alignment === \"start\", ctx.alignment === \"center\", ctx.alignment === \"end\"));\n        ɵngcc0.ɵɵattribute(\"aria-describedby\", ctx.id);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.id);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate(ctx.content);\n      }\n    },\n    dependencies: [ɵngcc3.NgClass],\n    encapsulation: 2\n  });\n  TooltipDefinition.tooltipItemCount = 0;\n  return TooltipDefinition;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TooltipIcon = /*#__PURE__*/(() => {\n  class TooltipIcon {\n    constructor() {\n      /**\n       * The placement in which the `TooltipIcon` appears.\n       * Set to `\"top\"` to have it positioned above the icon\n       */\n      this.placement = \"bottom\";\n      this.alignment = \"start\";\n      this.className = true;\n    }\n\n  }\n\n  TooltipIcon.ɵfac = function TooltipIcon_Factory(t) {\n    return new (t || TooltipIcon)();\n  };\n\n  TooltipIcon.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TooltipIcon,\n    selectors: [[\"ibm-tooltip-icon\"]],\n    hostVars: 2,\n    hostBindings: function TooltipIcon_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--tooltip-icon\", ctx.className);\n      }\n    },\n    inputs: {\n      placement: \"placement\",\n      alignment: \"alignment\",\n      content: \"content\"\n    },\n    ngContentSelectors: _c3,\n    decls: 4,\n    vars: 10,\n    consts: [[\"type\", \"button\", 1, \"bx--tooltip__trigger\", \"bx--tooltip--a11y\", 3, \"ngClass\"], [1, \"bx--assistive-text\"]],\n    template: function TooltipIcon_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"button\", 0)(1, \"span\", 1);\n        ɵngcc0.ɵɵtext(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction7(2, _c4, ctx.placement === \"bottom\", ctx.placement === \"top\", ctx.placement === \"left\", ctx.placement === \"right\", ctx.alignment === \"start\", ctx.alignment === \"center\", ctx.alignment === \"end\"));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵtextInterpolate(ctx.content);\n      }\n    },\n    dependencies: [ɵngcc3.NgClass],\n    encapsulation: 2\n  });\n  return TooltipIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive for extending `Dialog` to create tooltips.\n *\n * [See demo](../../?path=/story/components-tooltip--basic)\n *\n * class: TooltipDirective (extends PopoverDirective)\n *\n *\n * selector: `nTooltip`\n *\n *\n * ```html\n * <button nTooltip=\"I am a tooltip\" placement=\"right\" trigger=\"mouseenter\" type=\"danger\">Tooltip Right</button>\n * <button nTooltip=\"I am a tooltip\" type=\"warning\">Tooltip Top warning on click</button>\n * ```\n *\n * <example-url>../../iframe.html?id=components-tooltip--basic</example-url>\n */\n\n\nlet TooltipDirective = /*#__PURE__*/(() => {\n  class TooltipDirective extends DialogDirective {\n    /**\n     * Creates an instance of `TooltipDirective`.\n     */\n    constructor(elementRef, viewContainerRef, dialogService, eventService) {\n      super(elementRef, viewContainerRef, dialogService, eventService);\n      this.elementRef = elementRef;\n      this.viewContainerRef = viewContainerRef;\n      this.dialogService = dialogService;\n      this.eventService = eventService;\n      /**\n       * Set tooltip type to reflect 'warning' or 'error' styles.\n       */\n      // tslint:disable-next-line:no-input-rename\n\n      this.tooltipType = \"\";\n      this.tabIndex = 0;\n      this.className = true;\n      dialogService.setContext({\n        component: Tooltip\n      });\n    }\n\n    get descriptorId() {\n      return this.isOpen ? this.dialogConfig.compID : null;\n    }\n\n    updateConfig() {\n      this.dialogConfig.content = this.ibmTooltip;\n      this.dialogConfig.type = this.tooltipType;\n      this.dialogConfig.offset = this.offset;\n    }\n\n  }\n\n  TooltipDirective.ɵfac = function TooltipDirective_Factory(t) {\n    return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DialogService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService));\n  };\n\n  TooltipDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TooltipDirective,\n    selectors: [[\"\", \"ibmTooltip\", \"\"]],\n    hostVars: 4,\n    hostBindings: function TooltipDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"tabindex\", ctx.tabIndex);\n        ɵngcc0.ɵɵattribute(\"aria-describedby\", ctx.descriptorId);\n        ɵngcc0.ɵɵclassProp(\"bx--tooltip__trigger\", ctx.className);\n      }\n    },\n    inputs: {\n      tooltipType: [\"tooltip-type\", \"tooltipType\"],\n      ibmTooltip: \"ibmTooltip\"\n    },\n    exportAs: [\"ibmTooltip\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([DialogService]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return TooltipDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that creates a tooltip `Dialog` for exposing truncated text.\n *\n * class: EllipsisTooltip (extends PopoverDirective)\n *\n * selector: `nEllipsisTooltip`\n *\n * ```html\n * <div class=\"ellipsis\" nEllipsisTooltip>Tooltip for ellipsis because I can and I am really really long</div>\n * ```\n */\n\n\nlet EllipsisTooltip = /*#__PURE__*/(() => {\n  class EllipsisTooltip extends TooltipDirective {\n    /**\n     * If text is truncated, this appends the text to the dialog as content.\n     * @returns null\n     * @memberof EllipsisTooltip\n     */\n    updateTooltipContent() {\n      if (this.elementRef.nativeElement.scrollWidth <= this.elementRef.nativeElement.offsetWidth) {\n        this.disabled = true;\n        return;\n      }\n\n      this.disabled = false;\n      this.dialogConfig.content = this.elementRef.nativeElement.innerText;\n    }\n\n    onClick() {\n      if (this.trigger === \"click\") {\n        this.updateTooltipContent();\n      }\n    }\n\n    onHover() {\n      if (this.trigger === \"hover\" || this.trigger === \"mouseenter\") {\n        this.updateTooltipContent();\n      }\n    }\n\n    onFocus() {\n      this.updateTooltipContent();\n    }\n\n  }\n\n  EllipsisTooltip.ɵfac = /*@__PURE__*/function () {\n    let ɵEllipsisTooltip_BaseFactory;\n    return function EllipsisTooltip_Factory(t) {\n      return (ɵEllipsisTooltip_BaseFactory || (ɵEllipsisTooltip_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(EllipsisTooltip)))(t || EllipsisTooltip);\n    };\n  }();\n\n  EllipsisTooltip.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: EllipsisTooltip,\n    selectors: [[\"\", \"ibmEllipsisTooltip\", \"\"]],\n    hostBindings: function EllipsisTooltip_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function EllipsisTooltip_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"mouseenter\", function EllipsisTooltip_mouseenter_HostBindingHandler() {\n          return ctx.onHover();\n        })(\"focus\", function EllipsisTooltip_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        });\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([DialogService]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return EllipsisTooltip;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Extend the `Dialog` component to create an overflow menu.\n *\n * Not used directly. See overflow-menu.component and overflow-menu.directive for more\n */\n\n\nlet OverflowMenuPane = /*#__PURE__*/(() => {\n  class OverflowMenuPane extends Dialog {\n    constructor(elementRef, i18n, experimental, animationFrameService = null, // mark `elementService` as optional since making it mandatory would be a breaking change\n    elementService = null) {\n      super(elementRef, elementService, animationFrameService);\n      this.elementRef = elementRef;\n      this.i18n = i18n;\n      this.experimental = experimental;\n      this.animationFrameService = animationFrameService;\n      this.elementService = elementService;\n    }\n\n    onDialogInit() {\n      const positionOverflowMenu = pos => {\n        let offset;\n        /*\n        * 20 is half the width of the overflow menu trigger element.\n        * we also move the element by half of it's own width, since\n        * position service will try and center everything\n        */\n\n        const closestRel = closestAttr(\"position\", [\"relative\", \"fixed\", \"absolute\"], this.elementRef.nativeElement);\n        const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;\n        const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;\n        offset = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;\n\n        if (this.dialogConfig.flip) {\n          return position.addOffset(pos, topFix, -offset + leftFix);\n        }\n\n        return position.addOffset(pos, topFix, offset + leftFix);\n      };\n\n      this.addGap[\"bottom\"] = positionOverflowMenu;\n      this.addGap[\"top\"] = positionOverflowMenu;\n\n      if (!this.dialogConfig.menuLabel) {\n        this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;\n      }\n    }\n\n    hostkeys(event) {\n      const listItems = this.listItems();\n\n      switch (event.key) {\n        case \"Down\": // IE specific value\n\n        case \"ArrowDown\":\n          event.preventDefault();\n\n          if (!isFocusInLastItem(event, listItems)) {\n            const index = listItems.findIndex(item => item === event.target);\n            listItems[index + 1].focus();\n          } else {\n            listItems[0].focus();\n          }\n\n          break;\n\n        case \"Up\": // IE specific value\n\n        case \"ArrowUp\":\n          event.preventDefault();\n\n          if (!isFocusInFirstItem(event, listItems)) {\n            const index = listItems.findIndex(item => item === event.target);\n            listItems[index - 1].focus();\n          } else {\n            listItems[listItems.length - 1].focus();\n          }\n\n          break;\n\n        case \"Home\":\n          event.preventDefault();\n          listItems[0].focus();\n          break;\n\n        case \"End\":\n          event.preventDefault();\n          listItems[listItems.length - 1].focus();\n          break;\n\n        case \"Esc\": // IE specific value\n\n        case \"Escape\":\n        case \"Tab\":\n          event.stopImmediatePropagation();\n          this.doClose({\n            reason: CloseReasons.interaction,\n            target: event.target\n          });\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    onClose(event) {\n      this.doClose({\n        reason: CloseReasons.interaction,\n        target: event.target\n      });\n    }\n\n    afterDialogViewInit() {\n      const focusElementList = this.listItems();\n      focusElementList.forEach(button => {\n        // Allows user to set tabindex to 0.\n        if (button.getAttribute(\"tabindex\") === null) {\n          button.tabIndex = -1;\n        }\n      });\n\n      if (focusElementList[0]) {\n        focusElementList[0].tabIndex = 0;\n        focusElementList[0].focus();\n      }\n    }\n\n    listItems() {\n      const selector = \".bx--overflow-menu-options__option:not([disabled]) .bx--overflow-menu-options__btn\";\n      return Array.from(this.elementRef.nativeElement.querySelectorAll(selector));\n    }\n\n  }\n\n  OverflowMenuPane.ɵfac = function OverflowMenuPane_Factory(t) {\n    return new (t || OverflowMenuPane)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ExperimentalService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService, 8));\n  };\n\n  OverflowMenuPane.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: OverflowMenuPane,\n    selectors: [[\"ibm-overflow-menu-pane\"]],\n    hostBindings: function OverflowMenuPane_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function OverflowMenuPane_keydown_HostBindingHandler($event) {\n          return ctx.hostkeys($event);\n        });\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 11,\n    consts: [[\"role\", \"menu\", 1, \"bx--overflow-menu-options\", \"bx--overflow-menu-options--open\", 3, \"ngClass\", \"click\"], [\"dialog\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function OverflowMenuPane_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0, 1);\n        ɵngcc0.ɵɵlistener(\"click\", function OverflowMenuPane_Template_ul_click_0_listener($event) {\n          return ctx.onClose($event);\n        });\n        ɵngcc0.ɵɵtemplate(2, OverflowMenuPane_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c5, ctx.dialogConfig.flip));\n        ɵngcc0.ɵɵattribute(\"id\", ctx.dialogConfig.compID)(\"aria-label\", ctx.dialogConfig.menuLabel)(\"data-floating-menu-direction\", ctx.placement ? ctx.placement : null)(\"aria-label\", ctx.dialogConfig.menuLabel);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.dialogConfig.content)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(9, _c6, ctx));\n      }\n    },\n    dependencies: [ɵngcc3.NgClass, ɵngcc3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return OverflowMenuPane;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet OverflowMenuCustomPane = /*#__PURE__*/(() => {\n  class OverflowMenuCustomPane extends Dialog {\n    constructor(elementRef, i18n, animationFrameService = null, // mark `elementService` as optional since making it mandatory would be a breaking change\n    elementService = null) {\n      super(elementRef, elementService, animationFrameService);\n      this.elementRef = elementRef;\n      this.i18n = i18n;\n      this.animationFrameService = animationFrameService;\n      this.elementService = elementService;\n    }\n\n    onClick(event) {\n      this.doClose({\n        reason: CloseReasons.interaction,\n        target: event.target\n      });\n    }\n\n    onDialogInit() {\n      const positionOverflowMenu = pos => {\n        let offset;\n        /*\n        * 20 is half the width of the overflow menu trigger element.\n        * we also move the element by half of it's own width, since\n        * position service will try and center everything\n        */\n\n        const closestRel = closestAttr(\"position\", [\"relative\", \"fixed\", \"absolute\"], this.elementRef.nativeElement);\n        const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;\n        const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;\n        offset = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;\n\n        if (this.dialogConfig.flip) {\n          return position.addOffset(pos, topFix, -offset + leftFix);\n        }\n\n        return position.addOffset(pos, topFix, offset + leftFix);\n      };\n\n      this.addGap[\"bottom\"] = positionOverflowMenu;\n      this.addGap[\"top\"] = positionOverflowMenu;\n\n      if (!this.dialogConfig.menuLabel) {\n        this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;\n      }\n    }\n\n  }\n\n  OverflowMenuCustomPane.ɵfac = function OverflowMenuCustomPane_Factory(t) {\n    return new (t || OverflowMenuCustomPane)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService, 8));\n  };\n\n  OverflowMenuCustomPane.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: OverflowMenuCustomPane,\n    selectors: [[\"ibm-overflow-custom-menu-pane\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 11,\n    consts: [[\"role\", \"menu\", 1, \"bx--overflow-menu-options\", \"bx--overflow-menu-options--open\", 3, \"ngClass\", \"click\"], [\"dialog\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function OverflowMenuCustomPane_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵlistener(\"click\", function OverflowMenuCustomPane_Template_div_click_0_listener($event) {\n          return ctx.onClick($event);\n        });\n        ɵngcc0.ɵɵtemplate(2, OverflowMenuCustomPane_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c5, ctx.dialogConfig.flip));\n        ɵngcc0.ɵɵattribute(\"id\", ctx.dialogConfig.compID)(\"aria-label\", ctx.dialogConfig.menuLabel)(\"data-floating-menu-direction\", ctx.placement ? ctx.placement : null)(\"aria-label\", ctx.dialogConfig.menuLabel);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.dialogConfig.content)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(9, _c6, ctx));\n      }\n    },\n    dependencies: [ɵngcc3.NgClass, ɵngcc3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return OverflowMenuCustomPane;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive for extending `Dialog` to create overflow menus.\n *\n * class: OverflowMenuDirective (extends DialogDirective)\n *\n *\n * selector: `ibmOverflowMenu`\n *\n *\n * ```html\n * <div [ibmOverflowMenu]=\"templateRef\"></div>\n * <ng-template #templateRef>\n * \t<!-- overflow menu options here -->\n * </ng-template>\n * ```\n *\n * ```html\n * <div [ibmOverflowMenu]=\"templateRef\" [customPane]=\"true\"></div>\n * <ng-template #templateRef>\n *  <!-- custom content goes here -->\n * </ng-template>\n * ```\n */\n\n\nlet OverflowMenuDirective = /*#__PURE__*/(() => {\n  class OverflowMenuDirective extends DialogDirective {\n    /**\n     * Creates an instance of `OverflowMenuDirective`.\n     */\n    constructor(elementRef, viewContainerRef, dialogService, eventService) {\n      super(elementRef, viewContainerRef, dialogService, eventService);\n      this.elementRef = elementRef;\n      this.viewContainerRef = viewContainerRef;\n      this.dialogService = dialogService;\n      this.eventService = eventService;\n      /**\n       * Controls wether the overflow menu is flipped\n       */\n\n      this.flip = false;\n      /**\n       * Classes to add to the dialog container\n       */\n\n      this.wrapperClass = \"\";\n      /**\n       * Set to true to for custom content\n       */\n\n      this.customPane = false;\n    }\n\n    ngAfterContentInit() {\n      this.dialogService.setContext({\n        component: this.customPane ? OverflowMenuCustomPane : OverflowMenuPane\n      });\n    }\n\n    updateConfig() {\n      this.dialogConfig.content = this.ibmOverflowMenu;\n      this.dialogConfig.flip = this.flip;\n      this.dialogConfig.offset = this.offset;\n      this.dialogConfig.wrapperClass = this.wrapperClass;\n    }\n\n    hostkeys(event) {\n      switch (event.key) {\n        case \"Enter\":\n        case \" \":\n          event.preventDefault();\n          break;\n      }\n    }\n\n  }\n\n  OverflowMenuDirective.ɵfac = function OverflowMenuDirective_Factory(t) {\n    return new (t || OverflowMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DialogService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService));\n  };\n\n  OverflowMenuDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: OverflowMenuDirective,\n    selectors: [[\"\", \"ibmOverflowMenu\", \"\"]],\n    hostBindings: function OverflowMenuDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function OverflowMenuDirective_keydown_HostBindingHandler($event) {\n          return ctx.hostkeys($event);\n        });\n      }\n    },\n    inputs: {\n      flip: \"flip\",\n      wrapperClass: \"wrapperClass\",\n      customPane: \"customPane\",\n      ibmOverflowMenu: \"ibmOverflowMenu\",\n      offset: \"offset\"\n    },\n    exportAs: [\"ibmOverflowMenu\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([DialogService]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return OverflowMenuDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The OverFlow menu component encapsulates the OverFlowMenu directive, and the menu iconography into one convienent component\n *\n * [See demo](../../?path=/story/components-overflow-menu--basic)\n *\n * html:\n * ```\n * <ibm-overflow-menu>\n *\t<ibm-overflow-menu-option>Option 1</ibm-overflow-menu-option>\n *\t<ibm-overflow-menu-option>Option 2</ibm-overflow-menu-option>\n * </ibm-overflow-menu>\n * ```\n *\n * <example-url>../../iframe.html?id=components-overflow-menu--basic</example-url>\n */\n\n\nlet OverflowMenu = /*#__PURE__*/(() => {\n  class OverflowMenu {\n    constructor(elementRef, i18n) {\n      this.elementRef = elementRef;\n      this.i18n = i18n;\n      this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;\n      this.flip = false;\n      this.placement = \"bottom\";\n      this.open = false;\n      this.openChange = new EventEmitter();\n      this.wrapperClass = \"\";\n      /**\n       * This appends additional classes to the overflow trigger/button.\n       */\n\n      this.triggerClass = \"\";\n    }\n\n    handleOpenChange(event) {\n      this.open = event;\n      this.openChange.emit(event);\n    }\n\n  }\n\n  OverflowMenu.ɵfac = function OverflowMenu_Factory(t) {\n    return new (t || OverflowMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.I18n));\n  };\n\n  OverflowMenu.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: OverflowMenu,\n    selectors: [[\"ibm-overflow-menu\"]],\n    contentQueries: function OverflowMenu_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, OverflowMenuDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overflowMenuDirective = _t.first);\n      }\n    },\n    inputs: {\n      buttonLabel: \"buttonLabel\",\n      flip: \"flip\",\n      placement: \"placement\",\n      open: \"open\",\n      wrapperClass: \"wrapperClass\",\n      triggerClass: \"triggerClass\",\n      customTrigger: \"customTrigger\",\n      offset: \"offset\"\n    },\n    outputs: {\n      openChange: \"openChange\"\n    },\n    ngContentSelectors: _c3,\n    decls: 6,\n    vars: 15,\n    consts: [[\"aria-haspopup\", \"true\", \"type\", \"button\", 1, \"bx--overflow-menu\", 3, \"ibmOverflowMenu\", \"ngClass\", \"flip\", \"isOpen\", \"offset\", \"wrapperClass\", \"placement\", \"isOpenChange\"], [4, \"ngIf\", \"ngIfElse\"], [\"options\", \"\"], [\"defaultIcon\", \"\"], [3, \"ngTemplateOutlet\"], [\"ibmIcon\", \"overflow-menu--vertical\", \"size\", \"16\", 1, \"bx--overflow-menu__icon\"]],\n    template: function OverflowMenu_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"button\", 0);\n        ɵngcc0.ɵɵlistener(\"isOpenChange\", function OverflowMenu_Template_button_isOpenChange_0_listener($event) {\n          return ctx.handleOpenChange($event);\n        });\n        ɵngcc0.ɵɵtemplate(1, OverflowMenu_1_Template, 1, 1, null, 1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(2, OverflowMenu_ng_template_2_Template, 1, 0, \"ng-template\", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(4, OverflowMenu_ng_template_4_Template, 1, 0, \"ng-template\", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(3);\n\n        const _r3 = ɵngcc0.ɵɵreference(5);\n\n        ɵngcc0.ɵɵclassMapInterpolate1(\"bx--overflow-menu \", ctx.triggerClass, \"\");\n        ɵngcc0.ɵɵproperty(\"ibmOverflowMenu\", _r1)(\"ngClass\", ɵngcc0.ɵɵpureFunction1(13, _c7, ctx.open))(\"flip\", ctx.flip)(\"isOpen\", ctx.open)(\"offset\", ctx.offset)(\"wrapperClass\", ctx.wrapperClass)(\"placement\", ctx.placement);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.buttonLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.customTrigger)(\"ngIfElse\", _r3);\n      }\n    },\n    dependencies: [ɵngcc3.NgClass, ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet, ɵngcc6.IconDirective, OverflowMenuDirective],\n    styles: [\"\\n\\t\\t.bx--overflow-menu--open {\\n\\t\\t\\topacity: 1\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\tRotate the overflow menu container as well as the icon, since\\n\\t\\twe calculate our menu position based on the container, not the icon.\\n\\t\\t*/\\n\\t\\t.bx--data-table-v2 .bx--overflow-menu {\\n\\t\\t\\ttransform: rotate(90deg);\\n\\t\\t}\\n\\n\\t\\t.bx--data-table-v2 .bx--overflow-menu__icon {\\n\\t\\t\\ttransform: rotate(180deg);\\n\\t\\t}\\n\\t\"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return OverflowMenu;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Available HTML anchor targets\n */\n\n\nvar Target = /*#__PURE__*/(() => {\n  (function (Target) {\n    Target[\"self\"] = \"_self\";\n    Target[\"blank\"] = \"_blank\";\n    Target[\"parent\"] = \"_parent\";\n    Target[\"top\"] = \"_top\";\n  })(Target || (Target = {}));\n\n  return Target;\n})();\n\n/**\n * Security HTML anchor rel when target is set\n */\nconst REL = \"noreferrer noopener\";\n/**\n * `OverflowMenuOption` represents a single option in an overflow menu\n *\n * Presently it has three possible states - normal, disabled, and danger:\n * ```\n * <ibm-overflow-menu-option>Simple option</ibm-overflow-menu-option>\n * <ibm-overflow-menu-option disabled=\"true\">Disabled</ibm-overflow-menu-option>\n * <ibm-overflow-menu-option type=\"danger\">Danger option</ibm-overflow-menu-option>\n * ```\n *\n * For content that expands beyond the overflow menu `OverflowMenuOption` automatically adds a title attribute.\n */\n\nlet OverflowMenuOption = /*#__PURE__*/(() => {\n  class OverflowMenuOption {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.optionClass = true;\n      this.role = \"presentation\";\n      /**\n       * Set to `true` to display a dividing line above this option\n       */\n\n      this.divider = false;\n      /**\n       * toggles between `normal` and `danger` states\n       */\n\n      this.type = \"normal\";\n      /**\n       * disable/enable interactions\n       */\n\n      this.disabled = false;\n      /**\n       * Apply a custom class to the inner button/anchor\n       */\n\n      this.innerClass = \"\";\n      this.selected = new EventEmitter();\n      this.tabIndex = -1; // note: title must be a real attribute (i.e. not a getter) as of Angular@6 due to\n      // change after checked errors\n\n      this.title = null;\n    }\n\n    get isDanger() {\n      return this.type === \"danger\";\n    }\n\n    get isDisabled() {\n      return this.disabled;\n    }\n    /**\n     * Allows to add a target to the anchor\n     */\n\n\n    set target(value) {\n      if (!Object.values(Target).includes(value)) {\n        console.warn(`\\`target\\` must have one of the following values: ${Object.values(Target).join(\", \")}.\nPlease use the \\`Target\\` enum exported by carbon-components-angular`);\n        return;\n      }\n\n      this._target = value;\n    }\n\n    get target() {\n      return this._target;\n    }\n    /**\n     * rel only returns its value if target is defined\n     */\n\n\n    get rel() {\n      return this._target ? REL : null;\n    }\n\n    onClick() {\n      this.selected.emit();\n    }\n\n    onFocus() {\n      setTimeout(() => this.tabIndex = 0);\n    }\n\n    onBlur() {\n      setTimeout(() => this.tabIndex = -1);\n    }\n\n    ngAfterViewInit() {\n      const button = this.elementRef.nativeElement.querySelector(\"button, a\");\n      const textContainer = button.querySelector(\".bx--overflow-menu-options__option-content\");\n\n      if (textContainer.scrollWidth > textContainer.offsetWidth) {\n        this.title = button.textContent;\n      }\n    }\n\n  }\n\n  OverflowMenuOption.ɵfac = function OverflowMenuOption_Factory(t) {\n    return new (t || OverflowMenuOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  OverflowMenuOption.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: OverflowMenuOption,\n    selectors: [[\"ibm-overflow-menu-option\"]],\n    hostVars: 9,\n    hostBindings: function OverflowMenuOption_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role);\n        ɵngcc0.ɵɵclassProp(\"bx--overflow-menu-options__option\", ctx.optionClass)(\"bx--overflow-menu--divider\", ctx.divider)(\"bx--overflow-menu-options__option--danger\", ctx.isDanger)(\"bx--overflow-menu-options__option--disabled\", ctx.isDisabled);\n      }\n    },\n    inputs: {\n      divider: \"divider\",\n      type: \"type\",\n      disabled: \"disabled\",\n      innerClass: \"innerClass\",\n      target: \"target\",\n      href: \"href\"\n    },\n    outputs: {\n      selected: \"selected\"\n    },\n    ngContentSelectors: _c3,\n    decls: 4,\n    vars: 2,\n    consts: [[\"role\", \"menuitem\", 3, \"class\", \"tabindex\", \"disabled\", \"focus\", \"blur\", \"click\", 4, \"ngIf\"], [\"role\", \"menuitem\", 3, \"class\", \"tabindex\", \"href\", \"focus\", \"blur\", \"click\", 4, \"ngIf\"], [\"tempOutlet\", \"\"], [\"role\", \"menuitem\", 3, \"tabindex\", \"disabled\", \"focus\", \"blur\", \"click\"], [4, \"ngTemplateOutlet\"], [\"role\", \"menuitem\", 3, \"tabindex\", \"href\", \"focus\", \"blur\", \"click\"], [1, \"bx--overflow-menu-options__option-content\"]],\n    template: function OverflowMenuOption_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, OverflowMenuOption_button_0_Template, 2, 7, \"button\", 0);\n        ɵngcc0.ɵɵtemplate(1, OverflowMenuOption_a_1_Template, 2, 10, \"a\", 1);\n        ɵngcc0.ɵɵtemplate(2, OverflowMenuOption_ng_template_2_Template, 2, 0, \"ng-template\", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.href);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.href);\n      }\n    },\n    dependencies: [ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return OverflowMenuOption;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // modules\n\n\nlet DialogModule = /*#__PURE__*/(() => {\n  class DialogModule {}\n\n  DialogModule.ɵfac = function DialogModule_Factory(t) {\n    return new (t || DialogModule)();\n  };\n\n  DialogModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DialogModule\n  });\n  DialogModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [DialogService],\n    imports: [CommonModule, I18nModule, PlaceholderModule, ExperimentalModule, UtilsModule, IconModule]\n  });\n  return DialogModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DialogModule, {\n    declarations: function () {\n      return [Dialog, Tooltip, TooltipDefinition, TooltipIcon, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, TooltipDirective, EllipsisTooltip, OverflowMenuDirective, OverflowMenuOption];\n    },\n    imports: function () {\n      return [CommonModule, I18nModule, PlaceholderModule, ExperimentalModule, UtilsModule, IconModule];\n    },\n    exports: function () {\n      return [Dialog, Tooltip, TooltipDefinition, TooltipIcon, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, TooltipDirective, EllipsisTooltip, OverflowMenuDirective, OverflowMenuOption];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DialogService, Dialog, DialogDirective, Tooltip, TooltipDefinition, TooltipIcon, TooltipDirective, EllipsisTooltip, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, OverflowMenuDirective, OverflowMenuOption, CloseReasons, DialogModule }; //# sourceMappingURL=carbon-components-angular-dialog.js.map","map":null,"metadata":{},"sourceType":"module"}