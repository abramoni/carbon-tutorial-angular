{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-datepicker.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport rangePlugin from 'flatpickr/dist/plugins/rangePlugin';\nimport flatpickr from 'flatpickr';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport languages__default from 'flatpickr/dist/l10n/index';\nimport { DatePickerInputModule } from 'carbon-components-angular/datepicker-input';\nimport { Component, Input, Output, EventEmitter, ViewEncapsulation, ElementRef, HostListener, ViewChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { UtilsModule } from 'carbon-components-angular/utils';\nimport { I18n, I18nModule } from 'carbon-components-angular/i18n';\n/**\n * This is from carbon-components.\n * We need it to format the month select according to specs.\n * Carbon currently doesn't expose this as a seperate package,\n * and we don't import the carbon-components js (on purpose)\n * so some copy pasta is required\n *\n * ref: https://github.com/carbon-design-system/carbon/blob/\n * \tf06f38f0c2ef624e409a3d5711e897a79f4c88fc/packages/components/src/components/date-picker/date-picker.js#L52-L123\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'carbon-components-angular/i18n';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from 'carbon-components-angular/datepicker-input';\nconst _c0 = [\"input\"];\nconst _c1 = [\"rangeInput\"];\n\nfunction DatePicker_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2)(1, \"ibm-date-picker-input\", 3, 6);\n    ɵngcc0.ɵɵlistener(\"valueChange\", function DatePicker_div_5_Template_ibm_date_picker_input_valueChange_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r4);\n      const ctx_r3 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r3.onRangeValueChange($event));\n    })(\"click\", function DatePicker_div_5_Template_ibm_date_picker_input_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r4);\n\n      const _r2 = ɵngcc0.ɵɵreference(2);\n\n      const ctx_r5 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r5.openCalendar(_r2));\n    });\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"label\", ctx_r1.rangeLabel)(\"placeholder\", ctx_r1.placeholder)(\"pattern\", ctx_r1.inputPattern)(\"id\", ctx_r1.id + \"-rangeInput\")(\"size\", ctx_r1.size)(\"type\", ctx_r1.range ? \"range\" : \"single\")(\"hasIcon\", ctx_r1.range ? true : null)(\"disabled\", ctx_r1.disabled)(\"invalid\", ctx_r1.rangeInvalid)(\"invalidText\", ctx_r1.rangeInvalidText)(\"warn\", ctx_r1.rangeWarn)(\"warnText\", ctx_r1.rangeWarnText)(\"skeleton\", ctx_r1.skeleton)(\"helperText\", ctx_r1.rangeHelperText);\n  }\n}\n\nconst _c2 = function (a0, a1, a2, a3) {\n  return {\n    \"bx--date-picker--range\": a0,\n    \"bx--date-picker--single\": a1,\n    \"bx--date-picker--light\": a2,\n    \"bx--skeleton\": a3\n  };\n};\n\nconst monthToStr = (monthNumber, shorthand, locale) => locale.months[shorthand ? \"shorthand\" : \"longhand\"][monthNumber];\n\nconst config = {\n  selectorInit: \"[data-date-picker]\",\n  selectorDatePickerInput: \"[data-date-picker-input]\",\n  selectorDatePickerInputFrom: \"[data-date-picker-input-from]\",\n  selectorDatePickerInputTo: \"[data-date-picker-input-to]\",\n  selectorDatePickerIcon: \"[data-date-picker-icon]\",\n  selectorFlatpickrMonthYearContainer: \".flatpickr-current-month\",\n  selectorFlatpickrYearContainer: \".numInputWrapper\",\n  selectorFlatpickrCurrentMonth: \".cur-month\",\n  classCalendarContainer: `bx--date-picker__calendar`,\n  classMonth: `bx--date-picker__month`,\n  classWeekdays: `bx--date-picker__weekdays`,\n  classDays: `bx--date-picker__days`,\n  classWeekday: `bx--date-picker__weekday`,\n  classDay: `bx--date-picker__day`,\n  classFocused: `bx--focused`,\n  classVisuallyHidden: `bx--visually-hidden`,\n  classFlatpickrCurrentMonth: \"cur-month\",\n  attribType: \"data-date-picker-type\",\n  dateFormat: \"m/d/Y\",\n  shorthand: false\n};\n\nconst carbonFlatpickrMonthSelectPlugin = fp => {\n  const setupElements = () => {\n    if (!fp.monthElements || !fp.yearElements) {\n      return;\n    }\n\n    fp.monthElements.forEach(elem => {\n      if (!elem.parentNode) {\n        return;\n      }\n\n      elem.parentNode.removeChild(elem);\n    });\n    fp.monthElements.splice(0, fp.monthElements.length, ...fp.monthElements.map(() => {\n      // eslint-disable-next-line no-underscore-dangle\n      const monthElement = fp._createElement(\"span\", config.classFlatpickrCurrentMonth);\n\n      monthElement.textContent = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);\n      fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));\n      return monthElement;\n    }));\n  };\n\n  const updateCurrentMonth = () => {\n    if (!fp.yearElements) {\n      return;\n    }\n\n    const monthStr = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);\n    fp.yearElements.forEach(elem => {\n      const currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);\n      Array.prototype.forEach.call(currentMonthContainer.querySelectorAll(\".cur-month\"), monthElement => {\n        monthElement.textContent = monthStr;\n      });\n    });\n  };\n\n  const register = () => {\n    fp.loadedPlugins.push(\"carbonFlatpickrMonthSelectPlugin\");\n  };\n\n  return {\n    onMonthChange: updateCurrentMonth,\n    onValueUpdate: updateCurrentMonth,\n    onOpen: updateCurrentMonth,\n    onReady: [setupElements, updateCurrentMonth, register]\n  };\n};\n/**\n * [See demo](../../?path=/story/components-date-picker--single)\n *\n * <example-url>../../iframe.html?id=components-date-picker--single</example-url>\n */\n\n\nlet DatePicker = /*#__PURE__*/(() => {\n  class DatePicker {\n    constructor(elementRef, i18n) {\n      this.elementRef = elementRef;\n      this.i18n = i18n;\n      /**\n       * Select calendar range mode\n       */\n\n      this.range = false;\n      /**\n       * Format of date\n       *\n       * For reference: https://flatpickr.js.org/formatting/\n       */\n\n      this.dateFormat = \"m/d/Y\";\n      /**\n       * Language of the flatpickr calendar.\n       *\n       * For reference of the possible locales:\n       * https://github.com/flatpickr/flatpickr/blob/master/src/l10n/index.ts\n       */\n\n      this.language = \"en\";\n      this.placeholder = \"mm/dd/yyyy\";\n      /**\n       * Aria label added to datepicker's calendar container.\n       */\n\n      this.ariaLabel = \"calendar container\";\n      /**\n       * The pattern for the underlying input element\n       * @deprecated as of v4 - switch to inputPattern\n       */\n\n      this.pattern = \"^\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}$\";\n      this.id = `datepicker-${DatePicker.datePickerCount++}`;\n      this.theme = \"dark\";\n      this.disabled = false;\n      /**\n       * Set to `true` to display the invalid state.\n       */\n\n      this.invalid = false;\n      /**\n        * Set to `true` to show a warning (contents set by warningText)\n        */\n\n      this.warn = false;\n      this.size = \"md\";\n      /**\n       * Set to `true` to display the invalid state for the second datepicker input.\n       */\n\n      this.rangeInvalid = false;\n      /**\n        * Set to `true` to show a warning in the second datepicker input (contents set by rangeWarningText)\n        */\n\n      this.rangeWarn = false;\n      this.skeleton = false;\n      this.plugins = [];\n      this.valueChange = new EventEmitter();\n      /**\n       * We are overriding onClose event even if users pass it via flatpickr options\n       * Emits an event when date picker closes\n       */\n\n      this.onClose = new EventEmitter();\n      this._value = [];\n      this._flatpickrOptions = {\n        allowInput: true\n      };\n      this.flatpickrBaseOptions = {\n        mode: \"single\",\n        dateFormat: \"m/d/Y\",\n        plugins: this.plugins,\n        onOpen: () => {\n          this.updateClassNames();\n          this.updateAttributes();\n          this.updateCalendarListeners();\n        },\n        onClose: date => {\n          // This makes sure that the `flatpickrInstance selectedDates` are in sync with the values of\n          // the inputs when the calendar closes.\n          if (this.range && this.flatpickrInstance) {\n            if (this.flatpickrInstance.selectedDates.length !== 2) {\n              // we could `this.flatpickrInstance.clear()` but it insists on opening the second picker\n              // in some cases, so instead we do this\n              this.setDateValues([]);\n              this.doSelect([]);\n              return;\n            }\n\n            const inputValue = this.input.input.nativeElement.value;\n            const rangeInputValue = this.rangeInput.input.nativeElement.value;\n\n            if (inputValue || rangeInputValue) {\n              const parseDate = date => this.flatpickrInstance.parseDate(date, this.dateFormat);\n\n              this.setDateValues([parseDate(inputValue), parseDate(rangeInputValue)]);\n              this.doSelect(this.flatpickrInstance.selectedDates);\n            }\n          }\n\n          this.onClose.emit(date);\n        },\n        onDayCreate: (_dObj, _dStr, _fp, dayElem) => {\n          dayElem.classList.add(\"bx--date-picker__day\");\n        },\n        nextArrow: this.rightArrowHTML(),\n        prevArrow: this.leftArrowHTML(),\n        value: this.value\n      };\n      this.flatpickrInstance = null;\n\n      this.onTouched = () => {};\n\n      this.propagateChange = _ => {};\n\n      this.preventCalendarClose = event => event.stopPropagation();\n    }\n    /**\n     * The pattern for the underlying input element\n     */\n\n\n    set inputPattern(value) {\n      this.pattern = value;\n    }\n\n    get inputPattern() {\n      return this.pattern;\n    }\n\n    set value(v) {\n      if (!v) {\n        v = [];\n      }\n\n      this._value = v;\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    set flatpickrOptions(options) {\n      this._flatpickrOptions = Object.assign({}, this._flatpickrOptions, options);\n    }\n\n    get flatpickrOptions() {\n      const plugins = [...this.plugins, carbonFlatpickrMonthSelectPlugin];\n\n      if (this.range) {\n        plugins.push(rangePlugin({\n          input: `#${this.id}-rangeInput`,\n          position: \"left\"\n        }));\n      }\n\n      return Object.assign({}, this._flatpickrOptions, this.flatpickrBaseOptions, {\n        mode: this.range ? \"range\" : \"single\",\n        plugins,\n        dateFormat: this.dateFormat,\n        locale: languages__default[this.language]\n      });\n    }\n\n    ngOnInit() {\n      // if i18n is set to anything other than en we'll want to change the language\n      // otherwise we'll just use the local setting\n      if (this.i18n.getLocale() !== \"en\") {\n        this.i18n.getLocaleObservable().subscribe(locale => {\n          this.language = locale;\n          this.resetFlatpickrInstance();\n        });\n      }\n    }\n\n    ngOnChanges(changes) {\n      // Reset the flatpickr instance on input changes that affect flatpickr.\n      const flatpickrChangeKeys = [\"range\", \"dateFormat\", \"language\", \"id\", \"value\", \"plugins\", \"flatpickrOptions\"];\n      const changeKeys = Object.keys(changes);\n\n      if (changeKeys.some(key => flatpickrChangeKeys.includes(key))) {\n        this.resetFlatpickrInstance(changes.value);\n      }\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.addInputListeners();\n      }, 0);\n    } // because the actual view may be delayed in loading (think projection into a tab pane)\n    // and because we rely on a library that operates outside the Angular view of the world\n    // we need to keep trying to load the library, until the relevant DOM is actually live\n\n\n    ngAfterViewChecked() {\n      if (!this.isFlatpickrLoaded()) {\n        /// @ts-ignore ts is unhappy with the below call to `flatpickr`\n        this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions); // if (and only if) the initialization succeeded, we can set the date values\n\n        if (this.isFlatpickrLoaded()) {\n          if (this.value.length > 0) {\n            this.setDateValues(this.value);\n          }\n        }\n      }\n    }\n\n    ngAfterContentInit() {\n      languages__default.en.weekdays.shorthand = languages__default.en.weekdays.longhand.map(day => {\n        if (day === \"Thursday\") {\n          return \"Th\";\n        }\n\n        return day.charAt(0);\n      });\n    }\n\n    onFocus() {\n      // Updates the month manually when calendar mode is range because month\n      // will not update properly without manually updating them on focus.\n      if (this.range) {\n        if (this.rangeInput.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[1]) {\n          const currentMonth = this.flatpickrInstance.selectedDates[1].getMonth();\n          this.flatpickrInstance.changeMonth(currentMonth, false);\n        } else if (this.input.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[0]) {\n          const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();\n          this.flatpickrInstance.changeMonth(currentMonth, false);\n        }\n      }\n    }\n\n    onFocusOut() {\n      this.onTouched();\n    }\n    /**\n     * Writes a value from the model to the component. Expects the value to be `null` or `(Date | string)[]`\n     * @param value value received from the model\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n      setTimeout(() => {\n        if (this.isFlatpickrLoaded() && this.flatpickrInstance.config) {\n          this.setDateValues(this.value);\n        }\n      });\n    }\n    /**\n     * `ControlValueAccessor` method to programmatically disable the DatePicker.\n     *\n     * ex: `this.formGroup.get(\"myDatePicker\").disable();`\n     *\n     * @param isDisabled `true` to disable the DatePicker\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * Cleans up our flatpickr instance\n     */\n\n\n    ngOnDestroy() {\n      if (!this.isFlatpickrLoaded()) {\n        return;\n      }\n\n      this.flatpickrInstance.destroy();\n    }\n    /**\n     * Handles the `valueChange` event from the primary/single input\n     */\n\n\n    onValueChange(event) {\n      if (this.isFlatpickrLoaded()) {\n        const date = this.flatpickrInstance.parseDate(event, this.dateFormat);\n\n        if (this.range) {\n          this.setDateValues([date, this.flatpickrInstance.selectedDates[1]]);\n        } else {\n          this.setDateValues([date]);\n        }\n\n        this.doSelect(this.flatpickrInstance.selectedDates);\n      }\n    }\n    /**\n     * Handles the `valueChange` event from the range input\n     */\n\n\n    onRangeValueChange(event) {\n      if (this.isFlatpickrLoaded() && this.flatpickrInstance.isOpen) {\n        const date = this.flatpickrInstance.parseDate(event, this.dateFormat);\n        this.setDateValues([this.flatpickrInstance.selectedDates[0], date]);\n        this.doSelect(this.flatpickrInstance.selectedDates);\n      }\n    }\n    /**\n     * Handles opening the calendar \"properly\" when the calendar icon is clicked.\n     */\n\n\n    openCalendar(datepickerInput) {\n      if (this.range) {\n        datepickerInput.input.nativeElement.click(); // If the first input's calendar icon is clicked when calendar is in range mode, then\n        // the month and year needs to be manually changed to the current selected month and\n        // year otherwise the calendar view will not be updated upon opening.\n\n        if (datepickerInput === this.input && this.flatpickrInstance.selectedDates[0]) {\n          const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();\n          this.flatpickrInstance.currentYear = this.flatpickrInstance.selectedDates[0].getFullYear();\n          this.flatpickrInstance.changeMonth(currentMonth, false);\n        }\n      } else {\n        // Single-mode flatpickr handles mousedown but not click, so nativeElement.click() won't\n        // work when the calendar icon is clicked. In this case we simply use flatpickr.open().\n        this.flatpickrInstance.open();\n      }\n    }\n\n    updateCalendarListeners() {\n      const calendarContainer = document.querySelectorAll(\".flatpickr-calendar\");\n      Array.from(calendarContainer).forEach(calendar => {\n        calendar.removeEventListener(\"click\", this.preventCalendarClose);\n        calendar.addEventListener(\"click\", this.preventCalendarClose);\n      });\n    }\n    /**\n     * Handles the initialization of event listeners for the datepicker input and range input fields.\n     */\n\n\n    addInputListeners() {\n      if (!this.isFlatpickrLoaded()) {\n        return;\n      } // Allows focus transition from the datepicker input or range input field to\n      // flatpickr calendar using a keyboard.\n\n\n      const addFocusCalendarListener = element => {\n        element.addEventListener(\"keydown\", event => {\n          if (event.key === \"ArrowDown\") {\n            if (!this.flatpickrInstance.isOpen) {\n              this.flatpickrInstance.open();\n            }\n\n            const calendarContainer = this.flatpickrInstance.calendarContainer;\n            const dayElement = calendarContainer && calendarContainer.querySelector(\".flatpickr-day[tabindex]\");\n\n            if (dayElement) {\n              dayElement.focus(); // If the user manually inputs a value into the date field and presses arrow down,\n              // datepicker input onchange will be triggered when focus is removed from it and\n              // `flatpickrInstance.setDate` and `flatpickrInstance.changeMonth` will be invoked\n              // which will automatically change focus to the beginning of the document.\n\n              if (document.activeElement !== dayElement && this.flatpickrInstance.selectedDateElem) {\n                this.flatpickrInstance.selectedDateElem.focus();\n              }\n            }\n          }\n        });\n      };\n\n      if (this.input && this.input.input) {\n        addFocusCalendarListener(this.input.input.nativeElement);\n      }\n\n      if (this.rangeInput && this.rangeInput.input) {\n        addFocusCalendarListener(this.rangeInput.input.nativeElement);\n      }\n    }\n    /**\n     * Resets the flatpickr instance while keeping the date values (or updating them if newDates is provided)\n     *\n     * Used to pick up input changes or locale changes.\n     *\n     * @param newDates An optional SimpleChange of date values\n     */\n\n\n    resetFlatpickrInstance(newDates) {\n      if (this.isFlatpickrLoaded()) {\n        let dates = this.flatpickrInstance.selectedDates;\n\n        if (newDates && this.didDateValueChange(newDates.currentValue, newDates.previousValue)) {\n          dates = newDates.currentValue;\n        } // only reset the flatpickr instance on Input changes\n\n\n        this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);\n        this.setDateValues(dates);\n      }\n    }\n    /**\n     * Carbon uses a number of specific classnames for parts of the flatpickr - this idempotent method applies them if needed.\n     */\n\n\n    updateClassNames() {\n      if (!this.elementRef) {\n        return;\n      } // get all the possible flatpickrs in the document - we need to add classes to (potentially) all of them\n\n\n      const calendarContainer = document.querySelectorAll(\".flatpickr-calendar\");\n      const monthContainer = document.querySelectorAll(\".flatpickr-month\");\n      const weekdaysContainer = document.querySelectorAll(\".flatpickr-weekdays\");\n      const weekdayContainer = document.querySelectorAll(\".flatpickr-weekday\");\n      const daysContainer = document.querySelectorAll(\".flatpickr-days\");\n      const dayContainer = document.querySelectorAll(\".flatpickr-day\"); // add classes to lists of elements\n\n      const addClassIfNotExists = (classname, elementList) => {\n        Array.from(elementList).forEach(element => {\n          if (!element.classList.contains(classname)) {\n            element.classList.add(classname);\n          }\n        });\n      }; // add classes (but only if they don't exist, small perf win)\n\n\n      addClassIfNotExists(\"bx--date-picker__calendar\", calendarContainer);\n      addClassIfNotExists(\"bx--date-picker__month\", monthContainer);\n      addClassIfNotExists(\"bx--date-picker__weekdays\", weekdaysContainer);\n      addClassIfNotExists(\"bx--date-picker__days\", daysContainer); // add weekday classes and format the text\n\n      Array.from(weekdayContainer).forEach(element => {\n        element.innerHTML = element.innerHTML.replace(/\\s+/g, \"\");\n        element.classList.add(\"bx--date-picker__weekday\");\n      }); // add day classes and special case the \"today\" element based on `this.value`\n\n      Array.from(dayContainer).forEach(element => {\n        element.classList.add(\"bx--date-picker__day\");\n\n        if (!this.value) {\n          return;\n        }\n\n        if (element.classList.contains(\"today\") && this.value.length > 0) {\n          element.classList.add(\"no-border\");\n        } else if (element.classList.contains(\"today\") && this.value.length === 0) {\n          element.classList.remove(\"no-border\");\n        }\n      });\n    }\n\n    updateAttributes() {\n      const calendarContainer = document.querySelectorAll(\".flatpickr-calendar\");\n      Array.from(calendarContainer).forEach(calendar => {\n        calendar.setAttribute(\"role\", \"region\");\n        calendar.setAttribute(\"aria-label\", this.ariaLabel);\n      });\n    }\n    /**\n     * Applies the given date value array to both the flatpickr instance and the `input`(s)\n     * @param dates the date values to apply\n     */\n\n\n    setDateValues(dates) {\n      if (this.isFlatpickrLoaded()) {\n        const singleInput = this.elementRef.nativeElement.querySelector(`#${this.id}-input`);\n        const rangeInput = this.elementRef.nativeElement.querySelector(`#${this.id}-rangeInput`); // `flatpickrInstance.setDate` removes the focus on the selected date element and will\n        // automatically change focus to the beginning of the document. If a selected date is\n        // focused before `flatpickrInstance.setDate` is invoked then it should remain focused.\n\n        let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement; // set the date on the instance\n\n        this.flatpickrInstance.setDate(dates);\n\n        if (shouldRefocusDateElement) {\n          this.flatpickrInstance.selectedDateElem.focus();\n        } // we can either set a date value or an empty string, so we start with an empty string\n\n\n        let singleDate = \"\"; // if date is a string, parse and format\n\n        if (typeof this.flatpickrInstance.selectedDates[0] === \"string\") {\n          singleDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);\n          singleDate = this.flatpickrInstance.formatDate(singleDate, this.dateFormat); // if date is not a string we can assume it's a Date and we should format\n        } else if (!!this.flatpickrInstance.selectedDates[0]) {\n          singleDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);\n        }\n\n        if (rangeInput) {\n          // we can either set a date value or an empty string, so we start with an empty string\n          let rangeDate = \"\"; // if date is a string, parse and format\n\n          if (typeof this.flatpickrInstance.selectedDates[1] === \"string\") {\n            rangeDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[1].toString(), this.dateFormat);\n            rangeDate = this.flatpickrInstance.formatDate(rangeDate, this.dateFormat); // if date is not a string we can assume it's a Date and we should format\n          } else if (!!this.flatpickrInstance.selectedDates[1]) {\n            rangeDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[1], this.dateFormat);\n          }\n\n          setTimeout(() => {\n            // apply the values\n            rangeInput.value = rangeDate;\n            singleInput.value = singleDate;\n          });\n        }\n      }\n    }\n\n    doSelect(selectedValue) {\n      // In range mode, if a date is selected from the first calendar that is from the previous month,\n      // the month will not be updated on the calendar until the calendar is re-opened.\n      // This will make sure the calendar is updated with the correct month.\n      if (this.range && this.flatpickrInstance.selectedDates[0]) {\n        const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth(); // `flatpickrInstance.changeMonth` removes the focus on the selected date element and will\n        // automatically change focus to the beginning of the document. If a selected date is\n        // focused before `flatpickrInstance.changeMonth` is invoked then it should remain focused.\n\n        let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;\n        this.flatpickrInstance.changeMonth(currentMonth, false);\n\n        if (shouldRefocusDateElement) {\n          this.flatpickrInstance.selectedDateElem.focus();\n        }\n      }\n\n      this.valueChange.emit(selectedValue);\n      this.propagateChange(selectedValue);\n    }\n\n    didDateValueChange(currentValue, previousValue) {\n      return currentValue[0] !== previousValue[0] || currentValue[1] !== previousValue[1];\n    }\n    /**\n     * More advanced checking of the loaded state of flatpickr\n     */\n\n\n    isFlatpickrLoaded() {\n      // cast the instance to a boolean, and some method that has to exist for the library to be loaded in this case `setDate`\n      return !!this.flatpickrInstance && !!this.flatpickrInstance.setDate;\n    }\n    /**\n     * Right arrow HTML passed to flatpickr\n     */\n\n\n    rightArrowHTML() {\n      return `\n\t\t\t<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n\t\t\t\t<polygon points=\"11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 \"/>\n\t\t\t\t<rect width=\"16\" height=\"16\" style=\"fill:none\" />\n\t\t\t</svg>`;\n    }\n    /**\n     * Left arrow HTML passed to flatpickr\n     */\n\n\n    leftArrowHTML() {\n      return `\n\t\t\t<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n\t\t\t\t<polygon points=\"5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 \"/>\n\t\t\t\t<rect width=\"16\" height=\"16\" style=\"fill:none\" />\n\t\t\t</svg>`;\n    }\n\n  }\n\n  DatePicker.ɵfac = function DatePicker_Factory(t) {\n    return new (t || DatePicker)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  DatePicker.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DatePicker,\n    selectors: [[\"ibm-date-picker\"]],\n    viewQuery: function DatePicker_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeInput = _t.first);\n      }\n    },\n    hostBindings: function DatePicker_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focusin\", function DatePicker_focusin_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"focusout\", function DatePicker_focusout_HostBindingHandler() {\n          return ctx.onFocusOut();\n        });\n      }\n    },\n    inputs: {\n      range: \"range\",\n      dateFormat: \"dateFormat\",\n      language: \"language\",\n      placeholder: \"placeholder\",\n      ariaLabel: \"ariaLabel\",\n      pattern: \"pattern\",\n      id: \"id\",\n      theme: \"theme\",\n      disabled: \"disabled\",\n      invalid: \"invalid\",\n      warn: \"warn\",\n      size: \"size\",\n      rangeInvalid: \"rangeInvalid\",\n      rangeWarn: \"rangeWarn\",\n      skeleton: \"skeleton\",\n      plugins: \"plugins\",\n      inputPattern: \"inputPattern\",\n      value: \"value\",\n      flatpickrOptions: \"flatpickrOptions\",\n      label: \"label\",\n      helperText: \"helperText\",\n      rangeHelperText: \"rangeHelperText\",\n      rangeLabel: \"rangeLabel\",\n      invalidText: \"invalidText\",\n      warnText: \"warnText\",\n      rangeInvalidText: \"rangeInvalidText\",\n      rangeWarnText: \"rangeWarnText\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onClose: \"onClose\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: DatePicker,\n      multi: true\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 6,\n    vars: 21,\n    consts: [[1, \"bx--form-item\"], [1, \"bx--date-picker\", 3, \"ngClass\"], [1, \"bx--date-picker-container\"], [3, \"label\", \"placeholder\", \"pattern\", \"id\", \"size\", \"type\", \"hasIcon\", \"disabled\", \"invalid\", \"invalidText\", \"warn\", \"warnText\", \"skeleton\", \"helperText\", \"valueChange\", \"click\"], [\"input\", \"\"], [\"class\", \"bx--date-picker-container\", 4, \"ngIf\"], [\"rangeInput\", \"\"]],\n    template: function DatePicker_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r6 = ɵngcc0.ɵɵgetCurrentView();\n\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"div\", 2)(3, \"ibm-date-picker-input\", 3, 4);\n        ɵngcc0.ɵɵlistener(\"valueChange\", function DatePicker_Template_ibm_date_picker_input_valueChange_3_listener($event) {\n          return ctx.onValueChange($event);\n        })(\"click\", function DatePicker_Template_ibm_date_picker_input_click_3_listener() {\n          ɵngcc0.ɵɵrestoreView(_r6);\n\n          const _r0 = ɵngcc0.ɵɵreference(4);\n\n          return ɵngcc0.ɵɵresetView(ctx.openCalendar(_r0));\n        });\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(5, DatePicker_div_5_Template, 3, 14, \"div\", 5);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction4(16, _c2, ctx.range, !ctx.range, ctx.theme === \"light\", ctx.skeleton));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"label\", ctx.label)(\"placeholder\", ctx.placeholder)(\"pattern\", ctx.inputPattern)(\"id\", ctx.id + \"-input\")(\"size\", ctx.size)(\"type\", ctx.range ? \"range\" : \"single\")(\"hasIcon\", ctx.range ? false : true)(\"disabled\", ctx.disabled)(\"invalid\", ctx.invalid)(\"invalidText\", ctx.invalidText)(\"warn\", ctx.warn)(\"warnText\", ctx.warnText)(\"skeleton\", ctx.skeleton)(\"helperText\", ctx.helperText);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.range);\n      }\n    },\n    dependencies: [ɵngcc2.NgClass, ɵngcc2.NgIf, ɵngcc3.DatePickerInput],\n    styles: [\".dayContainer {\\n\\t\\t\\tjustify-content: initial;\\n\\t\\t}\"],\n    encapsulation: 2\n  });\n  DatePicker.datePickerCount = 0;\n  /** @nocollapse */\n\n  return DatePicker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DatePickerModule = /*#__PURE__*/(() => {\n  class DatePickerModule {}\n\n  DatePickerModule.ɵfac = function DatePickerModule_Factory(t) {\n    return new (t || DatePickerModule)();\n  };\n\n  DatePickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DatePickerModule\n  });\n  DatePickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule, DatePickerInputModule, UtilsModule, I18nModule, DatePickerInputModule]\n  });\n  return DatePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DatePickerModule, {\n    declarations: function () {\n      return [DatePicker];\n    },\n    imports: function () {\n      return [CommonModule, DatePickerInputModule, UtilsModule, I18nModule];\n    },\n    exports: function () {\n      return [DatePicker, DatePickerInputModule];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DatePicker, DatePickerModule }; //# sourceMappingURL=carbon-components-angular-datepicker.js.map","map":null,"metadata":{},"sourceType":"module"}