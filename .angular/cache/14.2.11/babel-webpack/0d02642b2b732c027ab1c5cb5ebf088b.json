{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-tabs.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Subscription } from 'rxjs';\nimport { Component, Input, Output, EventEmitter, TemplateRef, HostBinding, ViewChild, ElementRef, HostListener, ContentChildren, ChangeDetectorRef, ViewChildren, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { EventService, UtilsModule } from 'carbon-components-angular/utils';\nimport { I18n, I18nModule } from 'carbon-components-angular/i18n';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from 'carbon-components-angular/utils';\nimport * as ɵngcc3 from 'carbon-components-angular/i18n';\n\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\n\nfunction Tab_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx_r0.active ? null : \"none\"));\n    ɵngcc0.ɵɵattribute(\"tabindex\", ctx_r0.tabIndex)(\"aria-labelledby\", ctx_r0.id + \"-header\");\n  }\n}\n\nconst _c1 = [\"*\"];\nconst _c2 = [\"tabItem\"];\n\nconst _c3 = function (a0, a1) {\n  return {\n    \"bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected\": a0,\n    \"bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled\": a1\n  };\n};\n\nconst _c4 = [\"tabList\"];\nconst _c5 = [\"rightOverflowNavButton\"];\nconst _c6 = [\"leftOverflowNavButton\"];\n\nfunction TabHeaderGroup_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵnamespaceHTML();\n    ɵngcc0.ɵɵelement(0, \"div\", 13);\n  }\n}\n\nfunction TabHeaderGroup_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.contentBefore);\n  }\n}\n\nfunction TabHeaderGroup_ng_container_12_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.contentAfter);\n  }\n}\n\nfunction TabHeaderGroup_div_13_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 15);\n  }\n}\n\nconst _c7 = function (a0, a1) {\n  return {\n    \"bx--skeleton\": a0,\n    \"bx--tabs--container bx--tabs--scrollable--container\": a1\n  };\n};\n\nconst _c8 = function (a0, a1) {\n  return {\n    \"bx--tab--overflow-nav-button\": a0,\n    \"bx--tab--overflow-nav-button--hidden\": a1\n  };\n};\n\nconst _c9 = [\"tabsScrollable\"];\n\nfunction TabHeaders_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵnamespaceHTML();\n    ɵngcc0.ɵɵelement(0, \"div\", 15);\n  }\n}\n\nfunction TabHeaders_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.contentBefore);\n  }\n}\n\nfunction TabHeaders_li_11_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r9 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", tab_r9.heading, \" \");\n  }\n}\n\nfunction TabHeaders_li_11_4_ng_template_0_Template(rf, ctx) {}\n\nconst _c10 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction TabHeaders_li_11_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TabHeaders_li_11_4_ng_template_0_Template, 0, 0, \"ng-template\", 21);\n  }\n\n  if (rf & 2) {\n    const tab_r9 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", tab_r9.heading)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c10, tab_r9.context));\n  }\n}\n\nfunction TabHeaders_li_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 17);\n    ɵngcc0.ɵɵlistener(\"click\", function TabHeaders_li_11_Template_li_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r18);\n      const tab_r9 = restoredCtx.$implicit;\n      const i_r10 = restoredCtx.index;\n\n      const _r11 = ɵngcc0.ɵɵreference(2);\n\n      const ctx_r17 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r17.selectTab(_r11, tab_r9, i_r10));\n    });\n    ɵngcc0.ɵɵelementStart(1, \"button\", 18, 19);\n    ɵngcc0.ɵɵlistener(\"focus\", function TabHeaders_li_11_Template_button_focus_1_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r18);\n      const i_r10 = restoredCtx.index;\n\n      const _r11 = ɵngcc0.ɵɵreference(2);\n\n      const ctx_r19 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r19.onTabFocus(_r11, i_r10));\n    })(\"click\", function TabHeaders_li_11_Template_button_click_1_listener($event) {\n      return $event.preventDefault();\n    });\n    ɵngcc0.ɵɵtemplate(3, TabHeaders_li_11_ng_container_3_Template, 2, 1, \"ng-container\", 20);\n    ɵngcc0.ɵɵtemplate(4, TabHeaders_li_11_4_Template, 1, 4, null, 20);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const tab_r9 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(9, _c3, tab_r9.active, tab_r9.disabled));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵpropertyInterpolate1(\"id\", \"\", tab_r9.id, \"-header\");\n    ɵngcc0.ɵɵproperty(\"title\", tab_r9.title ? tab_r9.title : tab_r9.heading);\n    ɵngcc0.ɵɵattribute(\"aria-selected\", tab_r9.active)(\"tabindex\", tab_r9.active ? 0 : -1)(\"aria-controls\", tab_r9.id)(\"aria-disabled\", tab_r9.disabled);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !tab_r9.headingIsTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", tab_r9.headingIsTemplate);\n  }\n}\n\nfunction TabHeaders_ng_container_13_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.contentAfter);\n  }\n}\n\nfunction TabHeaders_div_14_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 22);\n  }\n}\n\nfunction Tabs_ibm_tab_headers_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ibm-tab-headers\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n\n    const _r1 = ɵngcc0.ɵɵreference(3);\n\n    const _r3 = ɵngcc0.ɵɵreference(5);\n\n    ɵngcc0.ɵɵproperty(\"skeleton\", ctx_r0.skeleton)(\"tabs\", ctx_r0.tabs)(\"followFocus\", ctx_r0.followFocus)(\"cacheActive\", ctx_r0.cacheActive)(\"contentBefore\", _r1)(\"contentAfter\", _r3)(\"ariaLabel\", ctx_r0.ariaLabel)(\"ariaLabelledby\", ctx_r0.ariaLabelledby)(\"type\", ctx_r0.type);\n  }\n}\n\nfunction Tabs_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0, 1);\n  }\n}\n\nfunction Tabs_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0, 2);\n  }\n}\n\nfunction Tabs_ibm_tab_headers_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ibm-tab-headers\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"skeleton\", ctx_r5.skeleton)(\"tabs\", ctx_r5.tabs)(\"cacheActive\", ctx_r5.cacheActive)(\"type\", ctx_r5.type);\n  }\n}\n\nconst _c11 = [\"*\", [[\"\", \"before\", \"\"]], [[\"\", \"after\", \"\"]]];\nconst _c12 = [\"*\", \"[before]\", \"[after]\"];\nlet nextId = 0;\n/**\n* The `Tab` component is a child of the `Tabs` component.\n* It represents one `Tab` item and its content within a panel of other `Tab` items.\n*\n*\n* `Tab` takes a string or `TemplateRef` for the header, and any content for the body of the tab.\n* Disabled states should be handled by the application (ie. switch to the tab, but display some\n* indication as to _why_ the tab is disabled).\n*\n* When the tab is selected the `select` output will be triggered.\n* The `select` output will also be triggered for the active tab when the tabs are loaded or updated.\n*\n*\n* Tab with string header:\n*\n* ```html\n* <ibm-tab heading='tab1'>\n* \ttab 1 content\n* </ibm-tab>\n* ```\n*\n* Tab with custom header:\n*\n* ```html\n* <ng-template #tabHeading>\n* \t<svg ibmIcon=\"facebook\"\n* \t\tsize=\"sm\"\n* \t\tstyle=\"margin-right: 7px;\">\n* \t</svg>\n* \tHello Tab 1\n* </ng-template>\n* <ibm-tabs>\n* \t<ibm-tab [heading]=\"tabHeading\">\n* \t\tTab 1 content <svg ibmIcon=\"alert\" size=\"lg\"></svg>\n* \t</ibm-tab>\n* \t<ibm-tab heading='Tab2'>\n* \t\tTab 2 content\n* \t</ibm-tab>\n* \t<ibm-tab heading='Tab3'>\n* \t\tTab 3 content\n* \t</ibm-tab>\n* </ibm-tabs>\n* ```\n*/\n\nlet Tab = /*#__PURE__*/(() => {\n  class Tab {\n    constructor() {\n      /**\n       * Boolean value reflects if the `Tab` is using a custom template for the heading.\n       * Default value is false.\n       */\n      this.headingIsTemplate = false;\n      /**\n       * Indicates whether the `Tab` is active/selected.\n       * Determines whether it's `TabPanel` is rendered.\n       */\n\n      this.active = false;\n      /**\n       * Indicates whether or not the `Tab` item is disabled.\n       */\n\n      this.disabled = false;\n      this.tabIndex = 0; // do we need id's?\n\n      /**\n       * Sets the id of the `Tab`. Will be uniquely generated if not provided.\n       */\n\n      this.id = `n-tab-${nextId++}`;\n      /**\n       * Value 'selected' to be emitted after a new `Tab` is selected.\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * Used to set the id property on the element.\n       */\n\n      this.attrClass = this.id;\n      this._cacheActive = false;\n    }\n    /**\n     * Set to true to have Tab items cached and not reloaded on tab switching.\n     */\n\n\n    set cacheActive(shouldCache) {\n      this._cacheActive = shouldCache;\n    }\n\n    get cacheActive() {\n      return this._cacheActive;\n    }\n    /**\n     * Checks for custom heading template on initialization and updates the value\n     * of the boolean 'headingIsTemplate'.\n     */\n\n\n    ngOnInit() {\n      if (this.heading instanceof TemplateRef) {\n        this.headingIsTemplate = true;\n      }\n    }\n    /**\n     * Emit the status of the `Tab`, specifically 'select' and 'selected' properties.\n     */\n\n\n    doSelect() {\n      this.selected.emit();\n    }\n    /**\n    * Returns value indicating whether this `Tab` should be rendered in a `TabPanel`.\n    */\n\n\n    shouldRender() {\n      return this.active || this.cacheActive;\n    }\n\n  }\n\n  Tab.ɵfac = function Tab_Factory(t) {\n    return new (t || Tab)();\n  };\n\n  Tab.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Tab,\n    selectors: [[\"ibm-tab\"]],\n    hostVars: 1,\n    hostBindings: function Tab_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.attrClass);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      disabled: \"disabled\",\n      tabIndex: \"tabIndex\",\n      id: \"id\",\n      cacheActive: \"cacheActive\",\n      heading: \"heading\",\n      title: \"title\",\n      context: \"context\"\n    },\n    outputs: {\n      selected: \"selected\"\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[\"role\", \"tabpanel\", \"class\", \"bx--tab-content\", \"aria-live\", \"polite\", 3, \"ngStyle\", 4, \"ngIf\"], [\"role\", \"tabpanel\", \"aria-live\", \"polite\", 1, \"bx--tab-content\", 3, \"ngStyle\"]],\n    template: function Tab_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, Tab_div_0_Template, 2, 5, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.shouldRender());\n      }\n    },\n    dependencies: [ɵngcc1.NgIf, ɵngcc1.NgStyle],\n    encapsulation: 2\n  });\n  return Tab;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TabHeader = /*#__PURE__*/(() => {\n  class TabHeader {\n    constructor() {\n      /**\n       * Indicates whether the `Tab` is active/selected.\n       * Determines whether it's `TabPanel` is rendered.\n       */\n      this.active = false;\n      /**\n       * Indicates whether or not the `Tab` item is disabled.\n       */\n\n      this.disabled = false;\n      /**\n       * Value 'selected' to be emitted after a new `Tab` is selected.\n       */\n\n      this.selected = new EventEmitter();\n      this._cacheActive = false;\n    }\n    /**\n     * Set to 'true' to have pane reference cached and not reloaded on tab switching.\n     */\n\n\n    set cacheActive(shouldCache) {\n      this._cacheActive = shouldCache; // Updates the pane references associated with the tab header when cache active is changed.\n\n      if (this.paneReference) {\n        this.paneReference.cacheActive = this.cacheActive;\n      }\n    }\n\n    set paneTabIndex(tabIndex) {\n      if (this.paneReference) {\n        this.paneReference.tabIndex = tabIndex;\n      }\n    }\n\n    get cacheActive() {\n      return this._cacheActive;\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.title = this.title ? this.title : this.tabItem.nativeElement.textContent;\n      });\n    }\n\n    selectTab() {\n      this.tabItem.nativeElement.focus();\n\n      if (!this.disabled) {\n        this.selected.emit();\n        this.active = true;\n\n        if (this.paneReference) {\n          this.paneReference.active = true;\n        }\n      }\n    }\n\n  }\n\n  TabHeader.ɵfac = function TabHeader_Factory(t) {\n    return new (t || TabHeader)();\n  };\n\n  TabHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TabHeader,\n    selectors: [[\"ibm-tab-header\"]],\n    viewQuery: function TabHeader_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c2, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabItem = _t.first);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      disabled: \"disabled\",\n      cacheActive: \"cacheActive\",\n      paneTabIndex: \"paneTabIndex\",\n      title: \"title\",\n      paneReference: \"paneReference\"\n    },\n    outputs: {\n      selected: \"selected\"\n    },\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 7,\n    consts: [[\"role\", \"presentation\", 1, \"bx--tabs--scrollable__nav-item\", 3, \"ngClass\", \"click\"], [\"draggable\", \"false\", \"href\", \"javascript:void(0)\", \"role\", \"tab\", 1, \"bx--tabs--scrollable__nav-link\", 3, \"title\"], [\"tabItem\", \"\"]],\n    template: function TabHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"li\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function TabHeader_Template_li_click_0_listener() {\n          return ctx.selectTab();\n        });\n        ɵngcc0.ɵɵelementStart(1, \"button\", 1, 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(4, _c3, ctx.active, ctx.disabled));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"title\", ctx.title);\n        ɵngcc0.ɵɵattribute(\"aria-selected\", ctx.active)(\"tabindex\", ctx.active ? 0 : -1);\n      }\n    },\n    dependencies: [ɵngcc1.NgClass],\n    encapsulation: 2\n  });\n  return TabHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TabHeaderGroup = /*#__PURE__*/(() => {\n  class TabHeaderGroup {\n    constructor(elementRef, changeDetectorRef, eventService) {\n      this.elementRef = elementRef;\n      this.changeDetectorRef = changeDetectorRef;\n      this.eventService = eventService;\n      /**\n       * Set to `true` to put tabs in a loading state.\n       */\n\n      this.skeleton = false;\n      /**\n       * Set to 'true' to have all pane references associated with each tab header\n       * in the tab header group cached and not reloaded on tab switching.\n       */\n\n      this.cacheActive = false;\n      this.isNavigation = false;\n      this.type = \"default\";\n      /**\n       * Keeps track of all the subscriptions to the tab header selection events.\n       */\n\n      this.selectedSubscriptionTracker = new Subscription();\n      /**\n       * Controls the manual focusing done by tabbing through headings.\n       */\n\n      this.currentSelectedIndex = 0; // width of the overflow buttons\n\n      this.OVERFLOW_BUTTON_OFFSET = 40;\n      this._cacheActive = false;\n    }\n\n    get hasHorizontalOverflow() {\n      const tabList = this.headerContainer.nativeElement;\n      return tabList.scrollWidth > tabList.clientWidth;\n    }\n\n    get leftOverflowNavButtonHidden() {\n      const tabList = this.headerContainer.nativeElement;\n      return !this.hasHorizontalOverflow || !tabList.scrollLeft;\n    }\n\n    get rightOverflowNavButtonHidden() {\n      const tabList = this.headerContainer.nativeElement;\n      return !this.hasHorizontalOverflow || tabList.scrollLeft + tabList.clientWidth === tabList.scrollWidth;\n    } // keyboard accessibility\n\n    /**\n     * Controls the keydown events used for tabbing through the headings.\n     */\n\n\n    keyboardInput(event) {\n      let tabHeadersArray = Array.from(this.tabHeaderQuery);\n\n      if (event.key === \"Right\" || event.key === \"ArrowRight\") {\n        if (this.currentSelectedIndex < tabHeadersArray.length - 1) {\n          event.preventDefault();\n\n          if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex + 1].disabled) {\n            tabHeadersArray[this.currentSelectedIndex + 1].selectTab();\n          } else {\n            tabHeadersArray[this.currentSelectedIndex + 1].tabItem.nativeElement.focus();\n            this.currentSelectedIndex++;\n          }\n        } else {\n          event.preventDefault();\n\n          if (this.followFocus && !tabHeadersArray[0].disabled) {\n            tabHeadersArray[0].selectTab();\n          } else {\n            tabHeadersArray[0].tabItem.nativeElement.focus();\n            this.currentSelectedIndex = 0;\n          }\n        }\n      }\n\n      if (event.key === \"Left\" || event.key === \"ArrowLeft\") {\n        if (this.currentSelectedIndex > 0) {\n          event.preventDefault();\n\n          if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex - 1].disabled) {\n            tabHeadersArray[this.currentSelectedIndex - 1].selectTab();\n          } else {\n            tabHeadersArray[this.currentSelectedIndex - 1].tabItem.nativeElement.focus();\n            this.currentSelectedIndex--;\n          }\n        } else {\n          event.preventDefault();\n\n          if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {\n            tabHeadersArray[tabHeadersArray.length - 1].selectTab();\n          } else {\n            tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();\n            this.currentSelectedIndex = tabHeadersArray.length - 1;\n          }\n        }\n      }\n\n      if (event.key === \"Home\") {\n        event.preventDefault();\n\n        if (this.followFocus && !tabHeadersArray[0].disabled) {\n          tabHeadersArray[0].selectTab();\n        } else {\n          tabHeadersArray[0].tabItem.nativeElement.focus();\n          this.currentSelectedIndex = 0;\n        }\n      }\n\n      if (event.key === \"End\") {\n        event.preventDefault();\n\n        if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {\n          tabHeadersArray[tabHeadersArray.length - 1].selectTab();\n        } else {\n          tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();\n          this.currentSelectedIndex = tabHeadersArray.length - 1;\n        }\n      } // `\"Spacebar\"` is IE11 specific value\n\n\n      if ((event.key === \" \" || event.key === \"Spacebar\") && !this.followFocus) {\n        tabHeadersArray[this.currentSelectedIndex].selectTab();\n      }\n    }\n\n    ngOnInit() {\n      this.eventService.on(window, \"resize\", () => this.handleScroll());\n    }\n\n    ngAfterContentInit() {\n      this.selectedSubscriptionTracker.unsubscribe();\n\n      if (this.tabHeaderQuery) {\n        this.tabHeaderQuery.toArray().forEach(tabHeader => {\n          tabHeader.cacheActive = this.cacheActive;\n          tabHeader.paneTabIndex = this.isNavigation ? null : 0;\n        });\n      }\n\n      const selectedSubscriptions = this.tabHeaderQuery.toArray().forEach(tabHeader => {\n        tabHeader.selected.subscribe(() => {\n          this.currentSelectedIndex = this.tabHeaderQuery.toArray().indexOf(tabHeader); // The Filter takes the current selected tab out, then all other headers are\n          // deactivated and their associated pane references are also deactivated.\n\n          this.tabHeaderQuery.toArray().filter(header => header !== tabHeader).forEach(filteredHeader => {\n            filteredHeader.active = false;\n\n            if (filteredHeader.paneReference) {\n              filteredHeader.paneReference.active = false;\n            }\n          });\n        });\n      });\n      this.selectedSubscriptionTracker.add(selectedSubscriptions);\n      setTimeout(() => this.tabHeaderQuery.toArray()[this.currentSelectedIndex].selectTab());\n    }\n\n    ngOnChanges(changes) {\n      if (this.tabHeaderQuery) {\n        if (changes.cacheActive) {\n          this.tabHeaderQuery.toArray().forEach(tabHeader => tabHeader.cacheActive = this.cacheActive);\n        }\n\n        if (changes.isNavigation) {\n          this.tabHeaderQuery.toArray().forEach(tabHeader => tabHeader.paneTabIndex = this.isNavigation ? null : 0);\n        }\n      }\n    }\n\n    getSelectedTab() {\n      const selected = this.tabHeaderQuery.toArray()[this.currentSelectedIndex];\n\n      if (selected) {\n        return selected;\n      }\n\n      return {\n        headingIsTemplate: false,\n        heading: \"\"\n      };\n    }\n\n    handleScroll() {\n      this.changeDetectorRef.markForCheck();\n    }\n\n    handleOverflowNavClick(direction, multiplier = 15) {\n      const tabList = this.headerContainer.nativeElement;\n      const {\n        clientWidth,\n        scrollLeft,\n        scrollWidth\n      } = tabList;\n\n      if (direction === 1 && !scrollLeft) {\n        tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;\n      }\n\n      tabList.scrollLeft += direction * multiplier;\n      const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;\n      const rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;\n\n      if (leftEdgeReached) {\n        this.rightOverflowNavButton.nativeElement.focus();\n      }\n\n      if (rightEdgeReached) {\n        this.leftOverflowNavButton.nativeElement.focus();\n      }\n    }\n\n    handleOverflowNavMouseDown(direction) {\n      const tabList = this.headerContainer.nativeElement;\n      this.overflowNavInterval = setInterval(() => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = tabList; // clear interval if scroll reaches left or right edge\n\n        const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;\n        const rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;\n\n        if (leftEdgeReached || rightEdgeReached) {\n          clearInterval(this.overflowNavInterval);\n        } // account for overflow button appearing and causing tablist width change\n\n\n        this.handleOverflowNavClick(direction);\n      });\n    }\n\n    handleOverflowNavMouseUp() {\n      clearInterval(this.overflowNavInterval);\n    }\n\n  }\n\n  TabHeaderGroup.ɵfac = function TabHeaderGroup_Factory(t) {\n    return new (t || TabHeaderGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService));\n  };\n\n  TabHeaderGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TabHeaderGroup,\n    selectors: [[\"ibm-tab-header-group\"]],\n    contentQueries: function TabHeaderGroup_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, TabHeader, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeaderQuery = _t);\n      }\n    },\n    viewQuery: function TabHeaderGroup_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c4, 7);\n        ɵngcc0.ɵɵviewQuery(_c5, 7);\n        ɵngcc0.ɵɵviewQuery(_c6, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOverflowNavButton = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOverflowNavButton = _t.first);\n      }\n    },\n    hostBindings: function TabHeaderGroup_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function TabHeaderGroup_keydown_HostBindingHandler($event) {\n          return ctx.keyboardInput($event);\n        });\n      }\n    },\n    inputs: {\n      skeleton: \"skeleton\",\n      cacheActive: \"cacheActive\",\n      isNavigation: \"isNavigation\",\n      type: \"type\",\n      followFocus: \"followFocus\",\n      ariaLabel: \"ariaLabel\",\n      ariaLabelledby: \"ariaLabelledby\",\n      contentAfter: \"contentAfter\",\n      contentBefore: \"contentBefore\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 18,\n    vars: 18,\n    consts: [[\"role\", \"navigation\", 1, \"bx--tabs\", \"bx--tabs--scrollable\", 3, \"ngClass\"], [\"type\", \"button\", 3, \"ngClass\", \"click\", \"mousedown\", \"mouseup\"], [\"leftOverflowNavButton\", \"\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"fill\", \"currentColor\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\"], [\"d\", \"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z\"], [\"class\", \"bx--tabs__overflow-indicator--left\", 4, \"ngIf\"], [\"role\", \"tablist\", 1, \"bx--tabs--scrollable__nav\", 3, \"scroll\"], [\"tabList\", \"\"], [\"role\", \"presentation\"], [3, \"ngTemplateOutlet\", 4, \"ngIf\"], [\"class\", \"bx--tabs__overflow-indicator--right\", 4, \"ngIf\"], [\"rightOverflowNavButton\", \"\"], [\"d\", \"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z\"], [1, \"bx--tabs__overflow-indicator--left\"], [3, \"ngTemplateOutlet\"], [1, \"bx--tabs__overflow-indicator--right\"]],\n    template: function TabHeaderGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"nav\", 0)(1, \"button\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"click\", function TabHeaderGroup_Template_button_click_1_listener() {\n          return ctx.handleOverflowNavClick(-1);\n        })(\"mousedown\", function TabHeaderGroup_Template_button_mousedown_1_listener() {\n          return ctx.handleOverflowNavMouseDown(-1);\n        })(\"mouseup\", function TabHeaderGroup_Template_button_mouseup_1_listener() {\n          return ctx.handleOverflowNavMouseUp();\n        });\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(3, \"svg\", 3);\n        ɵngcc0.ɵɵelement(4, \"path\", 4);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(5, TabHeaderGroup_div_5_Template, 1, 0, \"div\", 5);\n        ɵngcc0.ɵɵnamespaceHTML();\n        ɵngcc0.ɵɵelementStart(6, \"ul\", 6, 7);\n        ɵngcc0.ɵɵlistener(\"scroll\", function TabHeaderGroup_Template_ul_scroll_6_listener() {\n          return ctx.handleScroll();\n        });\n        ɵngcc0.ɵɵelementStart(8, \"li\", 8);\n        ɵngcc0.ɵɵtemplate(9, TabHeaderGroup_ng_container_9_Template, 1, 1, \"ng-container\", 9);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(10);\n        ɵngcc0.ɵɵelementStart(11, \"li\", 8);\n        ɵngcc0.ɵɵtemplate(12, TabHeaderGroup_ng_container_12_Template, 1, 1, \"ng-container\", 9);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(13, TabHeaderGroup_div_13_Template, 1, 0, \"div\", 10);\n        ɵngcc0.ɵɵelementStart(14, \"button\", 1, 11);\n        ɵngcc0.ɵɵlistener(\"click\", function TabHeaderGroup_Template_button_click_14_listener() {\n          return ctx.handleOverflowNavClick(1);\n        })(\"mousedown\", function TabHeaderGroup_Template_button_mousedown_14_listener() {\n          return ctx.handleOverflowNavMouseDown(1);\n        })(\"mouseup\", function TabHeaderGroup_Template_button_mouseup_14_listener() {\n          return ctx.handleOverflowNavMouseUp();\n        });\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(16, \"svg\", 3);\n        ɵngcc0.ɵɵelement(17, \"path\", 12);\n        ɵngcc0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(9, _c7, ctx.skeleton, ctx.type === \"container\"));\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(12, _c8, ctx.hasHorizontalOverflow, ctx.leftOverflowNavButtonHidden));\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.leftOverflowNavButtonHidden);\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.contentBefore);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.contentAfter);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.rightOverflowNavButtonHidden);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(15, _c8, ctx.hasHorizontalOverflow, ctx.rightOverflowNavButtonHidden));\n      }\n    },\n    dependencies: [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TabHeaderGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `TabHeaders` component contains the `Tab` items and controls scroll functionality\n * if content has overflow.\n */\n\n\nlet TabHeaders = /*#__PURE__*/(() => {\n  class TabHeaders {\n    constructor(elementRef, changeDetectorRef, i18n) {\n      this.elementRef = elementRef;\n      this.changeDetectorRef = changeDetectorRef;\n      this.i18n = i18n;\n      /**\n       * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.\n       * Duplicate from `n-tabs` to support standalone headers\n       */\n\n      this.cacheActive = false;\n      /**\n       * Set to `true` to put tabs in a loading state.\n       */\n\n      this.skeleton = false;\n      this.type = \"default\";\n      this.translations = this.i18n.get().PAGINATION;\n      /**\n       * The index of the first visible tab.\n       */\n\n      this.firstVisibleTab = 0; // width of the overflow buttons\n\n      this.OVERFLOW_BUTTON_OFFSET = 40;\n    }\n\n    get hasHorizontalOverflow() {\n      const scrollWidth = this.headerContainer.nativeElement.scrollWidth;\n      const availableWidth = this.tabsScrollable.nativeElement.clientWidth;\n      return scrollWidth > availableWidth;\n    }\n\n    get leftOverflowNavButtonHidden() {\n      const tabList = this.headerContainer.nativeElement;\n      return !this.hasHorizontalOverflow || !tabList.scrollLeft;\n    }\n\n    get rightOverflowNavButtonHidden() {\n      const tabList = this.headerContainer.nativeElement;\n      return !this.hasHorizontalOverflow || tabList.scrollLeft + tabList.clientWidth === tabList.scrollWidth;\n    } // keyboard accessibility\n\n    /**\n     * Controls the keydown events used for tabbing through the headings.\n     */\n\n\n    keyboardInput(event) {\n      let tabsArray = Array.from(this.tabs); // \"Right\" is an ie11 specific value\n\n      if (event.key === \"Right\" || event.key === \"ArrowRight\") {\n        if (this.currentSelectedTab < this.allTabHeaders.length - 1) {\n          event.preventDefault();\n\n          if (this.followFocus) {\n            this.selectTab(event.target, tabsArray[this.currentSelectedTab + 1], this.currentSelectedTab);\n          }\n\n          this.allTabHeaders.toArray()[this.currentSelectedTab + 1].nativeElement.focus();\n        } else {\n          event.preventDefault();\n\n          if (this.followFocus) {\n            this.selectTab(event.target, tabsArray[0], 0);\n          }\n\n          this.allTabHeaders.first.nativeElement.focus();\n        }\n      } // \"Left\" is an ie11 specific value\n\n\n      if (event.key === \"Left\" || event.key === \"ArrowLeft\") {\n        if (this.currentSelectedTab > 0) {\n          event.preventDefault();\n\n          if (this.followFocus) {\n            this.selectTab(event.target, tabsArray[this.currentSelectedTab - 1], this.currentSelectedTab);\n          }\n\n          this.allTabHeaders.toArray()[this.currentSelectedTab - 1].nativeElement.focus();\n        } else {\n          event.preventDefault();\n\n          if (this.followFocus) {\n            this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);\n          }\n\n          this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();\n        }\n      }\n\n      if (event.key === \"Home\") {\n        event.preventDefault();\n\n        if (this.followFocus) {\n          this.selectTab(event.target, tabsArray[0], 0);\n        }\n\n        this.allTabHeaders.toArray()[0].nativeElement.focus();\n      }\n\n      if (event.key === \"End\") {\n        event.preventDefault();\n\n        if (this.followFocus) {\n          this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);\n        }\n\n        this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();\n      } // `\"Spacebar\"` is IE11 specific value\n\n\n      if ((event.key === \" \" || event.key === \"Spacebar\") && !this.followFocus) {\n        this.selectTab(event.target, tabsArray[this.currentSelectedTab], this.currentSelectedTab);\n      }\n    }\n\n    ngOnInit() {\n      // Update scroll on resize\n      this.resizeObserver = new ResizeObserver(() => {\n        // Need to explicitly trigger change detection since this runs outside Angular zone\n        this.changeDetectorRef.detectChanges();\n      });\n      this.resizeObserver.observe(this.tabsScrollable.nativeElement);\n    }\n\n    ngOnDestroy() {\n      this.resizeObserver.unobserve(this.tabsScrollable.nativeElement);\n    }\n\n    ngAfterContentInit() {\n      if (!this.tabInput) {\n        this.tabs = this.tabQuery;\n      } else {\n        this.tabs = this.tabInput;\n      }\n\n      this.tabs.forEach(tab => tab.cacheActive = this.cacheActive);\n      this.tabs.changes.subscribe(() => {\n        this.setFirstTab();\n      });\n      this.setFirstTab();\n    }\n\n    ngOnChanges(changes) {\n      if (this.tabs && changes.cacheActive) {\n        this.tabs.forEach(tab => tab.cacheActive = this.cacheActive);\n      }\n    }\n    /**\n     * Controls manually focusing tabs.\n     */\n\n\n    onTabFocus(ref, index) {\n      this.currentSelectedTab = index; // reset scroll left because we're already handling it\n\n      this.headerContainer.nativeElement.parentElement.scrollLeft = 0;\n    }\n\n    getSelectedTab() {\n      const selected = this.tabs.find(tab => tab.active);\n\n      if (selected) {\n        return selected;\n      }\n\n      return {\n        headingIsTemplate: false,\n        heading: \"\"\n      };\n    }\n    /**\n     * Selects `Tab` 'tab' and moves it into view on the view DOM if it is not already.\n     */\n\n\n    selectTab(ref, tab, tabIndex) {\n      if (tab.disabled) {\n        return;\n      }\n\n      this.currentSelectedTab = tabIndex;\n      this.tabs.forEach(_tab => _tab.active = false);\n      tab.active = true;\n      tab.doSelect();\n    }\n\n    handleScroll() {\n      this.changeDetectorRef.markForCheck();\n    }\n\n    handleOverflowNavClick(direction, multiplier = 15) {\n      const tabList = this.headerContainer.nativeElement;\n      const {\n        clientWidth,\n        scrollLeft,\n        scrollWidth\n      } = tabList;\n\n      if (direction === 1 && !scrollLeft) {\n        tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;\n      }\n\n      tabList.scrollLeft += direction * multiplier;\n      const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;\n      const rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;\n\n      if (leftEdgeReached) {\n        this.rightOverflowNavButton.nativeElement.focus();\n      }\n\n      if (rightEdgeReached) {\n        this.leftOverflowNavButton.nativeElement.focus();\n      }\n    }\n\n    handleOverflowNavMouseDown(direction) {\n      const tabList = this.headerContainer.nativeElement;\n      this.overflowNavInterval = setInterval(() => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = tabList; // clear interval if scroll reaches left or right edge\n\n        const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;\n        const rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;\n\n        if (leftEdgeReached || rightEdgeReached) {\n          clearInterval(this.overflowNavInterval);\n        } // account for overflow button appearing and causing tablist width change\n\n\n        this.handleOverflowNavClick(direction);\n      });\n    }\n\n    handleOverflowNavMouseUp() {\n      clearInterval(this.overflowNavInterval);\n    }\n    /**\n     * Determines which `Tab` is initially selected.\n     */\n\n\n    setFirstTab() {\n      setTimeout(() => {\n        let firstTab = this.tabs.find(tab => tab.active);\n\n        if (!firstTab && this.tabs.first) {\n          firstTab = this.tabs.first;\n          firstTab.active = true;\n        }\n\n        if (firstTab) {\n          firstTab.doSelect();\n        }\n      });\n    }\n\n  }\n\n  TabHeaders.ɵfac = function TabHeaders_Factory(t) {\n    return new (t || TabHeaders)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n));\n  };\n\n  TabHeaders.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TabHeaders,\n    selectors: [[\"ibm-tab-headers\"]],\n    contentQueries: function TabHeaders_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, Tab, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabQuery = _t);\n      }\n    },\n    viewQuery: function TabHeaders_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c9, 7);\n        ɵngcc0.ɵɵviewQuery(_c4, 7);\n        ɵngcc0.ɵɵviewQuery(_c5, 7);\n        ɵngcc0.ɵɵviewQuery(_c6, 7);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabsScrollable = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOverflowNavButton = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOverflowNavButton = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.allTabHeaders = _t);\n      }\n    },\n    hostBindings: function TabHeaders_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function TabHeaders_keydown_HostBindingHandler($event) {\n          return ctx.keyboardInput($event);\n        });\n      }\n    },\n    inputs: {\n      cacheActive: \"cacheActive\",\n      skeleton: \"skeleton\",\n      type: \"type\",\n      translations: \"translations\",\n      tabInput: [\"tabs\", \"tabInput\"],\n      followFocus: \"followFocus\",\n      ariaLabel: \"ariaLabel\",\n      ariaLabelledby: \"ariaLabelledby\",\n      contentBefore: \"contentBefore\",\n      contentAfter: \"contentAfter\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 19,\n    vars: 21,\n    consts: [[\"role\", \"navigation\", 1, \"bx--tabs--scrollable\", 3, \"ngClass\"], [\"tabsScrollable\", \"\"], [\"type\", \"button\", 3, \"title\", \"ngClass\", \"click\", \"mousedown\", \"mouseup\"], [\"leftOverflowNavButton\", \"\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"fill\", \"currentColor\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\"], [\"d\", \"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z\"], [\"class\", \"bx--tabs__overflow-indicator--left\", 4, \"ngIf\"], [\"role\", \"tablist\", 1, \"bx--tabs--scrollable__nav\", 3, \"scroll\"], [\"tabList\", \"\"], [\"role\", \"presentation\"], [3, \"ngTemplateOutlet\", 4, \"ngIf\"], [\"class\", \"bx--tabs--scrollable__nav-item\", \"role\", \"presentation\", 3, \"ngClass\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"bx--tabs__overflow-indicator--right\", 4, \"ngIf\"], [\"rightOverflowNavButton\", \"\"], [\"d\", \"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z\"], [1, \"bx--tabs__overflow-indicator--left\"], [3, \"ngTemplateOutlet\"], [\"role\", \"presentation\", 1, \"bx--tabs--scrollable__nav-item\", 3, \"ngClass\", \"click\"], [\"type\", \"button\", \"draggable\", \"false\", \"href\", \"#\", \"role\", \"tab\", 1, \"bx--tabs--scrollable__nav-link\", 3, \"id\", \"title\", \"focus\", \"click\"], [\"tabItem\", \"\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"bx--tabs__overflow-indicator--right\"]],\n    template: function TabHeaders_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"nav\", 0, 1)(2, \"button\", 2, 3);\n        ɵngcc0.ɵɵlistener(\"click\", function TabHeaders_Template_button_click_2_listener() {\n          return ctx.handleOverflowNavClick(-1);\n        })(\"mousedown\", function TabHeaders_Template_button_mousedown_2_listener() {\n          return ctx.handleOverflowNavMouseDown(-1);\n        })(\"mouseup\", function TabHeaders_Template_button_mouseup_2_listener() {\n          return ctx.handleOverflowNavMouseUp();\n        });\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(4, \"svg\", 4);\n        ɵngcc0.ɵɵelement(5, \"path\", 5);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(6, TabHeaders_div_6_Template, 1, 0, \"div\", 6);\n        ɵngcc0.ɵɵnamespaceHTML();\n        ɵngcc0.ɵɵelementStart(7, \"ul\", 7, 8);\n        ɵngcc0.ɵɵlistener(\"scroll\", function TabHeaders_Template_ul_scroll_7_listener() {\n          return ctx.handleScroll();\n        });\n        ɵngcc0.ɵɵelementStart(9, \"li\", 9);\n        ɵngcc0.ɵɵtemplate(10, TabHeaders_ng_container_10_Template, 1, 1, \"ng-container\", 10);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(11, TabHeaders_li_11_Template, 5, 12, \"li\", 11);\n        ɵngcc0.ɵɵelementStart(12, \"li\", 9);\n        ɵngcc0.ɵɵtemplate(13, TabHeaders_ng_container_13_Template, 1, 1, \"ng-container\", 10);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(14, TabHeaders_div_14_Template, 1, 0, \"div\", 12);\n        ɵngcc0.ɵɵelementStart(15, \"button\", 2, 13);\n        ɵngcc0.ɵɵlistener(\"click\", function TabHeaders_Template_button_click_15_listener() {\n          return ctx.handleOverflowNavClick(1);\n        })(\"mousedown\", function TabHeaders_Template_button_mousedown_15_listener() {\n          return ctx.handleOverflowNavMouseDown(1);\n        })(\"mouseup\", function TabHeaders_Template_button_mouseup_15_listener() {\n          return ctx.handleOverflowNavMouseUp();\n        });\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(17, \"svg\", 4);\n        ɵngcc0.ɵɵelement(18, \"path\", 14);\n        ɵngcc0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(12, _c7, ctx.skeleton, ctx.type === \"container\"));\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"title\", ctx.translations.PREVIOUS)(\"ngClass\", ɵngcc0.ɵɵpureFunction2(15, _c8, ctx.hasHorizontalOverflow, ctx.leftOverflowNavButtonHidden));\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.leftOverflowNavButtonHidden);\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.contentBefore);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tabs);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.contentAfter);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.rightOverflowNavButtonHidden);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"title\", ctx.translations.NEXT)(\"ngClass\", ɵngcc0.ɵɵpureFunction2(18, _c8, ctx.hasHorizontalOverflow, ctx.rightOverflowNavButtonHidden));\n      }\n    },\n    dependencies: [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TabHeaders;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Build out your application's tabs using this component.\n * This is the parent of the `Tab` and `TabHeader` components.\n *\n * [See demo](../../?path=/story/components-tabs--basic)\n *\n * `Tabs` expects a set of `n-tab` elements\n *\n * ```html\n * <ibm-tabs>\n * \t<ibm-tab heading='tab1'>\n * \t\ttab 1 content\n * \t</ibm-tab>\n * \t<ibm-tab heading='tab1'>\n * \t\ttab 2 content\n * \t</ibm-tab>\n * \t<!-- ... -->\n * \t<ibm-tab heading='tab1'>\n * \t\ttab n content\n * \t</ibm-tab>\n * </ibm-tabs>\n * ```\n *\n * <example-url>../../iframe.html?id=components-tabs--basic</example-url>\n */\n\n\nlet Tabs = /*#__PURE__*/(() => {\n  class Tabs {\n    constructor() {\n      /**\n       * Takes either the string value 'top' or 'bottom' to place TabHeader\n       * relative to the `TabPanel`s.\n       */\n      this.position = \"top\";\n      /**\n       * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.\n       */\n\n      this.cacheActive = false;\n      /**\n       * Set to 'true' to have tabs automatically activated and have their content displayed when they receive focus.\n       */\n\n      this.followFocus = true;\n      /**\n       * Set to `true` to put tabs in a loading state.\n       */\n\n      this.skeleton = false;\n      /**\n       * Set to `true` to have the tabIndex of the all tabpanels be -1.\n       */\n\n      this.isNavigation = false;\n      /**\n       * Sets the type of the `TabHeader`s\n       */\n\n      this.type = \"default\";\n    }\n    /**\n     * After content is initialized update `Tab`s to cache (if turned on) and set the initial\n     * selected Tab item.\n     */\n\n\n    ngAfterContentInit() {\n      if (this.tabHeaders) {\n        this.tabHeaders.cacheActive = this.cacheActive;\n      }\n\n      this.tabs.forEach(tab => {\n        tab.tabIndex = this.isNavigation ? null : 0;\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (this.tabHeaders && changes.cacheActive) {\n        this.tabHeaders.cacheActive = this.cacheActive;\n      }\n\n      if (this.tabs && changes.isNavigation) {\n        this.tabs.forEach(tab => {\n          tab.tabIndex = this.isNavigation ? null : 0;\n        });\n      }\n    }\n    /**\n     * true if the n-tab's are passed directly to the component as children\n     */\n\n\n    hasTabHeaders() {\n      return this.tabs.length > 0;\n    }\n\n  }\n\n  Tabs.ɵfac = function Tabs_Factory(t) {\n    return new (t || Tabs)();\n  };\n\n  Tabs.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Tabs,\n    selectors: [[\"ibm-tabs\"]],\n    contentQueries: function Tabs_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, TabHeaders, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, Tab, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeaders = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);\n      }\n    },\n    inputs: {\n      position: \"position\",\n      cacheActive: \"cacheActive\",\n      followFocus: \"followFocus\",\n      skeleton: \"skeleton\",\n      isNavigation: \"isNavigation\",\n      type: \"type\",\n      ariaLabel: \"ariaLabel\",\n      ariaLabelledby: \"ariaLabelledby\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c12,\n    decls: 7,\n    vars: 2,\n    consts: [[3, \"skeleton\", \"tabs\", \"followFocus\", \"cacheActive\", \"contentBefore\", \"contentAfter\", \"ariaLabel\", \"ariaLabelledby\", \"type\", 4, \"ngIf\"], [\"before\", \"\"], [\"after\", \"\"], [3, \"skeleton\", \"tabs\", \"cacheActive\", \"type\", 4, \"ngIf\"], [3, \"skeleton\", \"tabs\", \"followFocus\", \"cacheActive\", \"contentBefore\", \"contentAfter\", \"ariaLabel\", \"ariaLabelledby\", \"type\"], [3, \"skeleton\", \"tabs\", \"cacheActive\", \"type\"]],\n    template: function Tabs_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c11);\n        ɵngcc0.ɵɵtemplate(0, Tabs_ibm_tab_headers_0_Template, 1, 9, \"ibm-tab-headers\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵtemplate(2, Tabs_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(4, Tabs_ng_template_4_Template, 1, 0, \"ng-template\", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(6, Tabs_ibm_tab_headers_6_Template, 1, 4, \"ibm-tab-headers\", 3);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.hasTabHeaders() && ctx.position === \"top\");\n        ɵngcc0.ɵɵadvance(6);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.hasTabHeaders() && ctx.position === \"bottom\");\n      }\n    },\n    dependencies: [ɵngcc1.NgIf, TabHeaders],\n    encapsulation: 2\n  });\n  return Tabs;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TabsModule = /*#__PURE__*/(() => {\n  class TabsModule {}\n\n  TabsModule.ɵfac = function TabsModule_Factory(t) {\n    return new (t || TabsModule)();\n  };\n\n  TabsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TabsModule\n  });\n  TabsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule, UtilsModule, I18nModule]\n  });\n  return TabsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, {\n    declarations: function () {\n      return [Tabs, Tab, TabHeaders, TabHeader, TabHeaderGroup];\n    },\n    imports: function () {\n      return [CommonModule, UtilsModule, I18nModule];\n    },\n    exports: function () {\n      return [Tabs, Tab, TabHeaders, TabHeader, TabHeaderGroup];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TabHeaderGroup, TabHeader, TabHeaders, Tab, Tabs, TabsModule }; //# sourceMappingURL=carbon-components-angular-tabs.js.map","map":null,"metadata":{},"sourceType":"module"}