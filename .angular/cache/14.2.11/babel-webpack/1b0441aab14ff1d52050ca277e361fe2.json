{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-radio.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Component, Input, HostBinding, Output, EventEmitter, ContentChildren, forwardRef, HostListener, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n/**\n * Used to emit changes performed on a `Radio`.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction Radio_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"input\", 4);\n    ɵngcc0.ɵɵlistener(\"change\", function Radio_input_0_Template_input_change_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r2.onChange($event));\n    })(\"click\", function Radio_input_0_Template_input_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r4.onClick($event));\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"checked\", ctx_r0.checked)(\"disabled\", ctx_r0.disabled || ctx_r0.disabledFromGroup)(\"name\", ctx_r0.name)(\"id\", ctx_r0.id)(\"required\", ctx_r0.required)(\"value\", ctx_r0.value);\n    ɵngcc0.ɵɵattribute(\"aria-labelledby\", ctx_r0.ariaLabelledby);\n  }\n}\n\nfunction Radio_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 5);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    \"bx--skeleton\": a0\n  };\n};\n\nconst _c1 = [\"*\"];\n\nconst _c2 = function (a0, a1) {\n  return {\n    \"bx--radio-button-group--vertical\": a0,\n    \"bx--radio-button-group--label-left\": a1\n  };\n};\n\nclass RadioChange {\n  constructor(source, value) {\n    this.source = source;\n    this.value = value;\n  }\n\n}\n/**\n * class: Radio (extends Checkbox)\n *\n * selector: `n-radio`\n *\n * source: `src/forms/radio.component.ts`\n *\n * ```html\n * <ibm-radio [(ngModel)]=\"radioState\">Radio</ibm-radio>\n * ```\n *\n * Also see: [`RadioGroup`](#ibm-radio-group)\n */\n\n\nlet Radio = /*#__PURE__*/(() => {\n  class Radio {\n    constructor() {\n      this.checked = false;\n      this.name = \"\";\n      this.disabled = false;\n      this.labelPlacement = \"right\";\n      /**\n       * Used to set the `aria-label` attribute on the input label.\n       */\n\n      this.ariaLabel = \"\";\n      /**\n       * Sets the HTML required attribute\n       */\n\n      this.required = false;\n      /**\n       * The value of the `Radio`.\n       */\n\n      this.value = \"\";\n      /**\n       * Set to `true` for a loading table.\n       */\n\n      this.skeleton = false;\n      /**\n       * The id for the `Radio`.\n       */\n\n      this.id = `radio-${Radio.radioCount++}`;\n      /**\n       * emits when the state of the radio changes\n       */\n\n      this.change = new EventEmitter();\n      this.hostClass = true;\n      /**\n       * Reflects whether or not the input is disabled at `RadioGroup` level.\n       */\n\n      this.disabledFromGroup = false;\n      this._labelledby = \"\";\n      /**\n       * Handler provided by the `RadioGroup` to bubble events up\n       */\n\n      this.radioChangeHandler = event => {};\n    }\n\n    set ariaLabelledby(value) {\n      this._labelledby = value;\n    }\n\n    get ariaLabelledby() {\n      if (this._labelledby) {\n        return this._labelledby;\n      }\n\n      return `label-${this.id}`;\n    }\n\n    get labelLeft() {\n      return this.labelPlacement === \"left\";\n    }\n    /**\n     * Synchronizes with the `RadioGroup` in the event of a changed `Radio`.\n     * Emits the changes of both the `RadioGroup` and `Radio`.\n     */\n\n\n    onChange(event) {\n      event.stopPropagation();\n    }\n\n    onClick(event) {\n      this.checked = event.target.checked;\n      const radioEvent = new RadioChange(this, this.value);\n      this.change.emit(radioEvent);\n      this.radioChangeHandler(radioEvent);\n    }\n    /**\n     * Method called by `RadioGroup` with a callback function to bubble `RadioChange` events\n     * @param fn callback that expects a `RadioChange` as an argument\n     */\n\n\n    registerRadioChangeHandler(fn) {\n      this.radioChangeHandler = fn;\n    }\n\n    setDisabledFromGroup(disabled) {\n      this.disabledFromGroup = disabled;\n    }\n\n  }\n\n  Radio.ɵfac = function Radio_Factory(t) {\n    return new (t || Radio)();\n  };\n\n  Radio.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Radio,\n    selectors: [[\"ibm-radio\"]],\n    hostVars: 4,\n    hostBindings: function Radio_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--radio-button-wrapper\", ctx.hostClass)(\"bx--radio-button-wrapper--label-left\", ctx.labelLeft);\n      }\n    },\n    inputs: {\n      checked: \"checked\",\n      name: \"name\",\n      disabled: \"disabled\",\n      labelPlacement: \"labelPlacement\",\n      ariaLabel: \"ariaLabel\",\n      required: \"required\",\n      value: \"value\",\n      skeleton: \"skeleton\",\n      id: \"id\",\n      ariaLabelledby: \"ariaLabelledby\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: Radio,\n      multi: true\n    }])],\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 8,\n    consts: [[\"class\", \"bx--radio-button\", \"type\", \"radio\", 3, \"checked\", \"disabled\", \"name\", \"id\", \"required\", \"value\", \"change\", \"click\", 4, \"ngIf\"], [\"class\", \"bx--radio-button bx--skeleton\", 4, \"ngIf\"], [1, \"bx--radio-button__label\", 3, \"ngClass\", \"for\", \"id\"], [1, \"bx--radio-button__appearance\"], [\"type\", \"radio\", 1, \"bx--radio-button\", 3, \"checked\", \"disabled\", \"name\", \"id\", \"required\", \"value\", \"change\", \"click\"], [1, \"bx--radio-button\", \"bx--skeleton\"]],\n    template: function Radio_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, Radio_input_0_Template, 1, 7, \"input\", 0);\n        ɵngcc0.ɵɵtemplate(1, Radio_div_1_Template, 1, 0, \"div\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"label\", 2);\n        ɵngcc0.ɵɵelement(3, \"span\", 3);\n        ɵngcc0.ɵɵprojection(4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.skeleton);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵpropertyInterpolate1(\"id\", \"label-\", ctx.id, \"\");\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(6, _c0, ctx.skeleton))(\"for\", ctx.id);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n      }\n    },\n    dependencies: [ɵngcc1.NgClass, ɵngcc1.NgIf],\n    encapsulation: 2\n  });\n  /**\n   * Used to dynamically create unique ids for the `Radio`.\n   */\n\n  Radio.radioCount = 0;\n  return Radio;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * [See demo](../../?path=/story/components-radio--basic)\n *\n * class: RadioGroup\n *\n * selector: `ibm-radio-group`\n *\n * source: `src/forms/radio.component.ts`\n *\n *\n * Ex:\n * ```html\n * <ibm-radio-group [(ngModel)]=\"radio\">\n * \t<ibm-radio *ngFor=\"let one of manyRadios\" [value]=\"one\">\n *\t\tRadio {{one}}\n * \t</ibm-radio>\n * </ibm-radio-group>\n *\n * Radio selected: {{radio}}\n * ```\n *\n * ```typescript\n * manyRadios = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\"];\n * ```\n *\n * Also see: [`Radio`](#ibm-radio)\n *\n * <example-url>../../iframe.html?id=components-radio--basic</example-url>\n */\n\n\nlet RadioGroup = /*#__PURE__*/(() => {\n  class RadioGroup {\n    constructor() {\n      this.orientation = \"horizontal\";\n      this.labelPlacement = \"right\";\n      /**\n       * Emits event notifying other classes of a change using a `RadioChange` class.\n       */\n\n      this.change = new EventEmitter();\n      /**\n       * Binds 'bx--form-item' value to the class for `RadioGroup`.\n       */\n\n      this.radioButtonGroupClass = true;\n      /**\n       * To track whether the `RadioGroup` has been initialized.\n       */\n\n      this.isInitialized = false;\n      /**\n       * Reflects whether or not the input is disabled and cannot be selected.\n       */\n\n      this._disabled = false;\n      /**\n       * Reflects whether or not the dropdown is loading.\n       */\n\n      this._skeleton = false;\n      /**\n       * The value of the selected option within the `RadioGroup`.\n       */\n\n      this._value = null;\n      /**\n       * The `Radio` within the `RadioGroup` that is selected.\n       */\n\n      this._selected = null;\n      /**\n       * The name attribute associated with the `RadioGroup`.\n       */\n\n      this._name = `radio-group-${RadioGroup.radioGroupCount++}`;\n      /**\n       * Needed to properly implement ControlValueAccessor.\n       */\n\n      this.onTouched = () => {};\n      /**\n       * Method set in registerOnChange to propagate changes back to the form.\n       */\n\n\n      this.propagateChange = _ => {};\n    }\n    /**\n     * Sets the passed in `Radio` item as the selected input within the `RadioGroup`.\n     */\n\n\n    set selected(selected) {\n      const alreadySelected = (this._selected && this._selected.value) === (selected && selected.value);\n\n      if (alreadySelected) {\n        // no need to redo\n        return;\n      }\n\n      if (this._selected) {\n        this._selected.checked = false;\n      }\n\n      this._selected = selected;\n      this.value = selected ? selected.value : null;\n      this.checkSelectedRadio();\n    }\n    /**\n     * Returns the `Radio` that is selected within the `RadioGroup`.\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\n     * Sets the value/state of the selected `Radio` within the `RadioGroup` to the passed in value.\n     */\n\n\n    set value(newValue) {\n      if (this._value !== newValue) {\n        this._value = newValue;\n        this.updateSelectedRadioFromValue();\n        this.checkSelectedRadio();\n      }\n    }\n    /**\n     * Returns the value/state of the selected `Radio` within the `RadioGroup`.\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Replaces the name associated with the `RadioGroup` with the provided parameter.\n     */\n\n\n    set name(name) {\n      this._name = name;\n      this.updateRadios();\n    }\n    /**\n     * Returns the associated name of the `RadioGroup`.\n     */\n\n\n    get name() {\n      return this._name;\n    }\n    /**\n     * Set to true to disable the whole radio group\n     */\n\n\n    set disabled(disabled) {\n      this._disabled = disabled;\n      this.updateRadios();\n    }\n    /**\n     * Returns the disabled value for the `RadioGroup`.\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Returns the skeleton value in the `RadioGroup` if there is one.\n     */\n\n\n    get skeleton() {\n      return this._skeleton;\n    }\n    /**\n     * Sets the skeleton value for all `Radio` to the skeleton value of `RadioGroup`.\n     */\n\n\n    set skeleton(value) {\n      this._skeleton = value;\n      this.updateChildren();\n    }\n    /**\n     * Updates the selected `Radio` to be checked (selected).\n     */\n\n\n    checkSelectedRadio() {\n      if (this.selected && !this._selected.checked) {\n        this.selected.checked = true;\n      }\n    }\n    /**\n     * Use the value of the `RadioGroup` to update the selected radio to the right state (selected state).\n     */\n\n\n    updateSelectedRadioFromValue() {\n      let alreadySelected = this._selected != null && this._selected.value === this._value;\n\n      if (this.radios && !alreadySelected) {\n        if (this.selected && this.value) {\n          this.selected.checked = false;\n        }\n\n        this._selected = null;\n        this.radios.forEach(radio => {\n          if (radio.checked || radio.value === this._value) {\n            this._selected = radio;\n          }\n        });\n\n        if (this.selected && !this.value) {\n          this._value = this.selected.value;\n        }\n      }\n    }\n    /**\n     * `ControlValueAccessor` method to programmatically disable the `RadioGroup`.\n     *\n     * ex: `this.formGroup.get(\"myRadioGroup\").disable();`\n     *\n     * @param isDisabled `true` to disable the inputs\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * Creates a class of `RadioChange` to emit the change in the `RadioGroup`.\n     */\n\n\n    emitChangeEvent(event) {\n      this.change.emit(event);\n      this.propagateChange(event.value);\n      this.onTouched();\n    }\n    /**\n     * Synchronizes radio properties.\n     */\n\n\n    updateRadios() {\n      if (this.radios) {\n        setTimeout(() => {\n          this.radios.forEach(radio => {\n            radio.name = this.name;\n            radio.setDisabledFromGroup(this.disabled);\n\n            if (this.labelPlacement === \"left\") {\n              radio.labelPlacement = \"left\";\n            }\n          });\n        });\n      }\n    }\n    /**\n     * Updates the value of the `RadioGroup` using the provided parameter.\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n      setTimeout(() => {\n        this.updateSelectedRadioFromValue();\n        this.checkSelectedRadio();\n      });\n    }\n\n    ngAfterContentInit() {\n      this.radios.changes.subscribe(() => {\n        this.updateRadios();\n        this.updateRadioChangeHandler();\n      });\n      this.updateChildren();\n      this.updateRadioChangeHandler();\n    }\n\n    ngAfterViewInit() {\n      this.updateRadios();\n    }\n    /**\n     * Used to set method to propagate changes back to the form.\n     */\n\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n    /**\n     * Registers a callback to be triggered when the control has been touched.\n     * @param fn Callback to be triggered when the checkbox is touched.\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    focusOut() {\n      this.onTouched();\n    }\n\n    updateChildren() {\n      if (this.radios) {\n        this.radios.forEach(child => child.skeleton = this.skeleton);\n      }\n    }\n\n    updateRadioChangeHandler() {\n      this.radios.forEach(radio => {\n        radio.registerRadioChangeHandler(event => {\n          if ((this.selected && this.selected.value) === event.value) {\n            // no need to redo\n            return;\n          } // deselect previous radio\n\n\n          if (this.selected) {\n            this.selected.checked = false;\n          } // update selected and value from the event\n\n\n          this._selected = event.source;\n          this._value = event.value; // bubble the event\n\n          this.emitChangeEvent(event);\n        });\n      });\n    }\n\n  }\n\n  RadioGroup.ɵfac = function RadioGroup_Factory(t) {\n    return new (t || RadioGroup)();\n  };\n\n  RadioGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: RadioGroup,\n    selectors: [[\"ibm-radio-group\"]],\n    contentQueries: function RadioGroup_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, Radio, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radios = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function RadioGroup_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focusout\", function RadioGroup_focusout_HostBindingHandler() {\n          return ctx.focusOut();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--form-item\", ctx.radioButtonGroupClass);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      labelPlacement: \"labelPlacement\",\n      selected: \"selected\",\n      value: \"value\",\n      name: \"name\",\n      disabled: \"disabled\",\n      skeleton: \"skeleton\",\n      ariaLabel: \"ariaLabel\",\n      ariaLabelledby: \"ariaLabelledby\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: RadioGroup,\n      multi: true\n    }])],\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 6,\n    consts: [[1, \"bx--radio-button-group\", 3, \"ngClass\"]],\n    template: function RadioGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(3, _c2, ctx.orientation === \"vertical\", ctx.orientation === \"vertical\" && ctx.labelPlacement === \"left\"));\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n      }\n    },\n    dependencies: [ɵngcc1.NgClass],\n    encapsulation: 2\n  });\n  /**\n   * Used for creating the `RadioGroup` 'name' property dynamically.\n   */\n\n  RadioGroup.radioGroupCount = 0;\n  return RadioGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // modules\n\n\nlet RadioModule = /*#__PURE__*/(() => {\n  class RadioModule {}\n\n  RadioModule.ɵfac = function RadioModule_Factory(t) {\n    return new (t || RadioModule)();\n  };\n\n  RadioModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: RadioModule\n  });\n  RadioModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule, FormsModule]\n  });\n  return RadioModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RadioModule, {\n    declarations: function () {\n      return [Radio, RadioGroup];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [Radio, RadioGroup];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { RadioChange, RadioGroup, Radio, RadioModule }; //# sourceMappingURL=carbon-components-angular-radio.js.map","map":null,"metadata":{},"sourceType":"module"}