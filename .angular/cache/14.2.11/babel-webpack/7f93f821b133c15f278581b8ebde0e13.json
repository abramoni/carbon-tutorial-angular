{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-placeholder.js\n *\n * Copyright 2014, 2023 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Injectable, Component, ViewContainerRef, ViewChild, Input, NgModule, SkipSelf, Optional } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * Singleton service used to register the container for out-of-flow components to insert into.\n * Also used to insert/remove components from that view.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"placeholder\"];\nlet PlaceholderService = /*#__PURE__*/(() => {\n  class PlaceholderService {\n    constructor() {\n      /**\n       * Main `ViewContainerRef` to insert components into\n       */\n      this.viewContainerRef = null;\n      /**\n       * Map of id's to secondary `ViewContainerRef`s\n       */\n\n      this.viewContainerMap = new Map();\n    }\n    /**\n     * Used by `Placeholder` to register view-container reference.\n     */\n\n\n    registerViewContainerRef(vcRef, id) {\n      if (id) {\n        this.viewContainerMap.set(id, vcRef);\n      } else {\n        this.viewContainerRef = vcRef;\n      }\n    }\n    /**\n     * Creates and returns component in the view.\n     */\n\n\n    createComponent(componentFactory, injector, id) {\n      if (id) {\n        if (!this.viewContainerMap.has(id)) {\n          console.error(`No view container with id ${id} found`);\n          return;\n        }\n\n        return this.viewContainerMap.get(id).createComponent(componentFactory, this.viewContainerMap.size, injector);\n      }\n\n      if (!this.viewContainerRef) {\n        console.error(\"No view container defined! Likely due to a missing `ibm-placeholder`\");\n        return;\n      }\n\n      return this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, injector);\n    }\n\n    destroyComponent(component) {\n      component.destroy();\n    }\n\n    hasComponentRef(component, id) {\n      if (id) {\n        return !(this.viewContainerMap.get(id).indexOf(component.hostView) < 0);\n      }\n\n      return !(this.viewContainerRef.indexOf(component.hostView) < 0);\n    }\n\n    hasPlaceholderRef(id) {\n      if (id) {\n        return this.viewContainerMap.has(id);\n      }\n\n      return !!this.viewContainerRef;\n    }\n\n    appendElement(element, id) {\n      if (id) {\n        return this.viewContainerMap.get(id).element.nativeElement.appendChild(element);\n      }\n\n      return this.viewContainerRef.element.nativeElement.appendChild(element);\n    }\n\n    removeElement(element, id) {\n      if (id) {\n        return this.viewContainerMap.get(id).element.nativeElement.removeChild(element);\n      }\n\n      return this.viewContainerRef.element.nativeElement.removeChild(element);\n    }\n\n    hasElement(element, id) {\n      if (id) {\n        return this.viewContainerMap.get(id).element.nativeElement.contains(element);\n      }\n\n      return this.viewContainerRef.element.nativeElement.contains(element);\n    }\n\n  }\n\n  PlaceholderService.ɵfac = function PlaceholderService_Factory(t) {\n    return new (t || PlaceholderService)();\n  };\n\n  PlaceholderService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PlaceholderService,\n    factory: PlaceholderService.ɵfac\n  });\n  return PlaceholderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Using a modal, dialog (Tooltip, OverflowMenu), or any other component that draws out of the normal page flow\n * in your application *requires* this component (`ibm-placeholder`).\n * It would generally be placed near the end of your root app component template\n * (app.component.ts or app.component.html) as:\n *\n * ```\n * <ibm-placeholder></ibm-placeholder>\n * ```\n */\n\n\nlet Placeholder = /*#__PURE__*/(() => {\n  class Placeholder {\n    /**\n     * Creates an instance of `Placeholder`.\n     */\n    constructor(placeholderService) {\n      this.placeholderService = placeholderService;\n    }\n    /**\n     * Registers the components view with `PlaceholderService`\n     */\n\n\n    ngOnInit() {\n      // TODO use `id` to register with the placeholderService\n      this.placeholderService.registerViewContainerRef(this.viewContainerRef);\n    }\n\n  }\n\n  Placeholder.ɵfac = function Placeholder_Factory(t) {\n    return new (t || Placeholder)(ɵngcc0.ɵɵdirectiveInject(PlaceholderService));\n  };\n\n  Placeholder.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Placeholder,\n    selectors: [[\"ibm-placeholder\"]],\n    viewQuery: function Placeholder_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    },\n    decls: 2,\n    vars: 0,\n    consts: [[\"placeholder\", \"\"]],\n    template: function Placeholder_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", null, 0);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return Placeholder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // modules\n// either provides a new instance of PlaceholderService, or returns the parent\n\n\nfunction PLACEHOLDER_SERVICE_PROVIDER_FACTORY(parentService) {\n  return parentService || new PlaceholderService();\n} // placeholder service *must* be a singleton to ensure the placeholder viewRef is accessible globally\n\n\nconst PLACEHOLDER_SERVICE_PROVIDER = {\n  provide: PlaceholderService,\n  deps: [[new Optional(), new SkipSelf(), PlaceholderService]],\n  useFactory: PLACEHOLDER_SERVICE_PROVIDER_FACTORY\n};\nlet PlaceholderModule = /*#__PURE__*/(() => {\n  class PlaceholderModule {}\n\n  PlaceholderModule.ɵfac = function PlaceholderModule_Factory(t) {\n    return new (t || PlaceholderModule)();\n  };\n\n  PlaceholderModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: PlaceholderModule\n  });\n  PlaceholderModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [PLACEHOLDER_SERVICE_PROVIDER],\n    imports: [CommonModule]\n  });\n  return PlaceholderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PlaceholderModule, {\n    declarations: function () {\n      return [Placeholder];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [Placeholder];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Placeholder, PLACEHOLDER_SERVICE_PROVIDER_FACTORY, PLACEHOLDER_SERVICE_PROVIDER, PlaceholderModule, PlaceholderService }; //# sourceMappingURL=carbon-components-angular-placeholder.js.map","map":null,"metadata":{},"sourceType":"module"}