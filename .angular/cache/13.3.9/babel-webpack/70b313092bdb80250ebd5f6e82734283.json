{"ast":null,"code":"import * as i1 from 'apollo-angular';\nimport { ApolloModule } from 'apollo-angular';\nimport * as i3 from '@apollo/client/core';\nimport { ApolloError, Observable, ApolloLink, InMemoryCache } from '@apollo/client/core';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, NgModule, Optional, Inject } from '@angular/core';\nimport { print } from 'graphql';\n/**\n * Controller to be injected into tests, that allows for mocking and flushing\n * of operations.\n *\n *\n */\n\nclass ApolloTestingController {}\n\nconst isApolloError = err => err && err.hasOwnProperty('graphQLErrors');\n\nclass TestOperation {\n  constructor(operation, observer) {\n    this.operation = operation;\n    this.observer = observer;\n  }\n\n  flush(result) {\n    if (isApolloError(result)) {\n      this.observer.error(result);\n    } else {\n      const fetchResult = result ? Object.assign({}, result) : result;\n      this.observer.next(fetchResult);\n      this.observer.complete();\n    }\n  }\n\n  flushData(data) {\n    this.flush({\n      data\n    });\n  }\n\n  networkError(error) {\n    const apolloError = new ApolloError({\n      networkError: error\n    });\n    this.flush(apolloError);\n  }\n\n  graphqlErrors(errors) {\n    this.flush({\n      errors\n    });\n  }\n\n}\n/**\n * A testing backend for `Apollo`.\n *\n * `ApolloTestingBackend` works by keeping a list of all open operations.\n * As operations come in, they're added to the list. Users can assert that specific\n * operations were made and then flush them. In the end, a verify() method asserts\n * that no unexpected operations were made.\n */\n\n\nclass ApolloTestingBackend {\n  constructor() {\n    /**\n     * List of pending operations which have not yet been expected.\n     */\n    this.open = [];\n  }\n  /**\n   * Handle an incoming operation by queueing it in the list of open operations.\n   */\n\n\n  handle(op) {\n    return new Observable(observer => {\n      const testOp = new TestOperation(op, observer);\n      this.open.push(testOp);\n    });\n  }\n  /**\n   * Helper function to search for operations in the list of open operations.\n   */\n\n\n  _match(match) {\n    if (typeof match === 'string') {\n      return this.open.filter(testOp => testOp.operation.operationName === match);\n    } else if (typeof match === 'function') {\n      return this.open.filter(testOp => match(testOp.operation));\n    } else {\n      if (this.isDocumentNode(match)) {\n        return this.open.filter(testOp => print(testOp.operation.query) === print(match));\n      }\n\n      return this.open.filter(testOp => this.matchOp(match, testOp));\n    }\n  }\n\n  matchOp(match, testOp) {\n    const variables = JSON.stringify(match.variables);\n    const extensions = JSON.stringify(match.extensions);\n    const sameName = this.compare(match.operationName, testOp.operation.operationName);\n    const sameVariables = this.compare(variables, testOp.operation.variables);\n    const sameQuery = print(testOp.operation.query) === print(match.query);\n    const sameExtensions = this.compare(extensions, testOp.operation.extensions);\n    return sameName && sameVariables && sameQuery && sameExtensions;\n  }\n\n  compare(expected, value) {\n    const prepare = val => typeof val === 'string' ? val : JSON.stringify(val);\n\n    const received = prepare(value);\n    return !expected || received === expected;\n  }\n  /**\n   * Search for operations in the list of open operations, and return all that match\n   * without asserting anything about the number of matches.\n   */\n\n\n  match(match) {\n    const results = this._match(match);\n\n    results.forEach(result => {\n      const index = this.open.indexOf(result);\n\n      if (index !== -1) {\n        this.open.splice(index, 1);\n      }\n    });\n    return results;\n  }\n  /**\n   * Expect that a single outstanding request matches the given matcher, and return\n   * it.\n   *\n   * operations returned through this API will no longer be in the list of open operations,\n   * and thus will not match twice.\n   */\n\n\n  expectOne(match, description) {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n\n    if (matches.length > 1) {\n      throw new Error(`Expected one matching operation for criteria \"${description}\", found ${matches.length} operations.`);\n    }\n\n    if (matches.length === 0) {\n      throw new Error(`Expected one matching operation for criteria \"${description}\", found none.`);\n    }\n\n    return matches[0];\n  }\n  /**\n   * Expect that no outstanding operations match the given matcher, and throw an error\n   * if any do.\n   */\n\n\n  expectNone(match, description) {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n\n    if (matches.length > 0) {\n      throw new Error(`Expected zero matching operations for criteria \"${description}\", found ${matches.length}.`);\n    }\n  }\n  /**\n   * Validate that there are no outstanding operations.\n   */\n\n\n  verify() {\n    const open = this.open;\n\n    if (open.length > 0) {\n      // Show the methods and URLs of open operations in the error, for convenience.\n      const operations = open.map(testOp => testOp.operation.operationName).join(', ');\n      throw new Error(`Expected no open operations, found ${open.length}: ${operations}`);\n    }\n  }\n\n  isDocumentNode(docOrOp) {\n    return !docOrOp.operationName;\n  }\n\n  descriptionFromMatcher(matcher) {\n    if (typeof matcher === 'string') {\n      return `Match operationName: ${matcher}`;\n    } else if (typeof matcher === 'object') {\n      if (this.isDocumentNode(matcher)) {\n        return `Match DocumentNode`;\n      }\n\n      const name = matcher.operationName || '(any)';\n      const variables = JSON.stringify(matcher.variables) || '(any)';\n      return `Match operation: ${name}, variables: ${variables}`;\n    } else {\n      return `Match by function: ${matcher.name}`;\n    }\n  }\n\n}\n\nApolloTestingBackend.ɵfac = function ApolloTestingBackend_Factory(t) {\n  return new (t || ApolloTestingBackend)();\n};\n\nApolloTestingBackend.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ApolloTestingBackend,\n  factory: ApolloTestingBackend.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ApolloTestingBackend, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst APOLLO_TESTING_CACHE = new InjectionToken('apollo-angular/testing cache');\nconst APOLLO_TESTING_NAMED_CACHE = new InjectionToken('apollo-angular/testing named cache');\nconst APOLLO_TESTING_CLIENTS = new InjectionToken('apollo-angular/testing named clients');\n\nfunction addClient(name, op) {\n  op.clientName = name;\n  return op;\n}\n\nclass ApolloTestingModuleCore {\n  constructor(apollo, backend, namedClients, cache, namedCaches) {\n    function createOptions(name, c) {\n      return {\n        link: new ApolloLink(operation => backend.handle(addClient(name, operation))),\n        cache: c || new InMemoryCache({\n          addTypename: false\n        })\n      };\n    }\n\n    apollo.create(createOptions('default', cache));\n\n    if (namedClients && namedClients.length) {\n      namedClients.forEach(name => {\n        const caches = namedCaches && typeof namedCaches === 'object' ? namedCaches : {};\n        apollo.createNamed(name, createOptions(name, caches[name]));\n      });\n    }\n  }\n\n}\n\nApolloTestingModuleCore.ɵfac = function ApolloTestingModuleCore_Factory(t) {\n  return new (t || ApolloTestingModuleCore)(i0.ɵɵinject(i1.Apollo), i0.ɵɵinject(ApolloTestingBackend), i0.ɵɵinject(APOLLO_TESTING_CLIENTS, 8), i0.ɵɵinject(APOLLO_TESTING_CACHE, 8), i0.ɵɵinject(APOLLO_TESTING_NAMED_CACHE, 8));\n};\n\nApolloTestingModuleCore.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ApolloTestingModuleCore,\n  imports: [ApolloModule]\n});\nApolloTestingModuleCore.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [ApolloTestingBackend, {\n    provide: ApolloTestingController,\n    useExisting: ApolloTestingBackend\n  }],\n  imports: [[ApolloModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ApolloTestingModuleCore, [{\n    type: NgModule,\n    args: [{\n      imports: [ApolloModule],\n      providers: [ApolloTestingBackend, {\n        provide: ApolloTestingController,\n        useExisting: ApolloTestingBackend\n      }]\n    }]\n  }], function () {\n    return [{\n      type: i1.Apollo\n    }, {\n      type: ApolloTestingBackend\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [APOLLO_TESTING_CLIENTS]\n      }]\n    }, {\n      type: i3.ApolloCache,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [APOLLO_TESTING_CACHE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [APOLLO_TESTING_NAMED_CACHE]\n      }]\n    }];\n  }, null);\n})();\n\nclass ApolloTestingModule {\n  static withClients(names) {\n    return {\n      ngModule: ApolloTestingModuleCore,\n      providers: [{\n        provide: APOLLO_TESTING_CLIENTS,\n        useValue: names\n      }]\n    };\n  }\n\n}\n\nApolloTestingModule.ɵfac = function ApolloTestingModule_Factory(t) {\n  return new (t || ApolloTestingModule)();\n};\n\nApolloTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ApolloTestingModule,\n  imports: [ApolloTestingModuleCore]\n});\nApolloTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[ApolloTestingModuleCore]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ApolloTestingModule, [{\n    type: NgModule,\n    args: [{\n      imports: [ApolloTestingModuleCore]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { APOLLO_TESTING_CACHE, APOLLO_TESTING_NAMED_CACHE, ApolloTestingController, ApolloTestingModule, TestOperation };","map":{"version":3,"sources":["C:/Users/07545G744/Documents/projects/carbon-tutorial-angular/node_modules/apollo-angular/fesm2015/ngApolloTesting.mjs"],"names":["i1","ApolloModule","i3","ApolloError","Observable","ApolloLink","InMemoryCache","i0","Injectable","InjectionToken","NgModule","Optional","Inject","print","ApolloTestingController","isApolloError","err","hasOwnProperty","TestOperation","constructor","operation","observer","flush","result","error","fetchResult","Object","assign","next","complete","flushData","data","networkError","apolloError","graphqlErrors","errors","ApolloTestingBackend","open","handle","op","testOp","push","_match","match","filter","operationName","isDocumentNode","query","matchOp","variables","JSON","stringify","extensions","sameName","compare","sameVariables","sameQuery","sameExtensions","expected","value","prepare","val","received","results","forEach","index","indexOf","splice","expectOne","description","descriptionFromMatcher","matches","length","Error","expectNone","verify","operations","map","join","docOrOp","matcher","name","ɵfac","ɵprov","type","APOLLO_TESTING_CACHE","APOLLO_TESTING_NAMED_CACHE","APOLLO_TESTING_CLIENTS","addClient","clientName","ApolloTestingModuleCore","apollo","backend","namedClients","cache","namedCaches","createOptions","c","link","addTypename","create","caches","createNamed","Apollo","ɵmod","ɵinj","provide","useExisting","args","imports","providers","undefined","decorators","ApolloCache","ApolloTestingModule","withClients","names","ngModule","useValue"],"mappings":"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","sourcesContent":["import * as i1 from 'apollo-angular';\nimport { ApolloModule } from 'apollo-angular';\nimport * as i3 from '@apollo/client/core';\nimport { ApolloError, Observable, ApolloLink, InMemoryCache } from '@apollo/client/core';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, NgModule, Optional, Inject } from '@angular/core';\nimport { print } from 'graphql';\n\n/**\n * Controller to be injected into tests, that allows for mocking and flushing\n * of operations.\n *\n *\n */\nclass ApolloTestingController {\n}\n\nconst isApolloError = (err) => err && err.hasOwnProperty('graphQLErrors');\nclass TestOperation {\n    constructor(operation, observer) {\n        this.operation = operation;\n        this.observer = observer;\n    }\n    flush(result) {\n        if (isApolloError(result)) {\n            this.observer.error(result);\n        }\n        else {\n            const fetchResult = result ? Object.assign({}, result) : result;\n            this.observer.next(fetchResult);\n            this.observer.complete();\n        }\n    }\n    flushData(data) {\n        this.flush({\n            data,\n        });\n    }\n    networkError(error) {\n        const apolloError = new ApolloError({\n            networkError: error,\n        });\n        this.flush(apolloError);\n    }\n    graphqlErrors(errors) {\n        this.flush({\n            errors,\n        });\n    }\n}\n\n/**\n * A testing backend for `Apollo`.\n *\n * `ApolloTestingBackend` works by keeping a list of all open operations.\n * As operations come in, they're added to the list. Users can assert that specific\n * operations were made and then flush them. In the end, a verify() method asserts\n * that no unexpected operations were made.\n */\nclass ApolloTestingBackend {\n    constructor() {\n        /**\n         * List of pending operations which have not yet been expected.\n         */\n        this.open = [];\n    }\n    /**\n     * Handle an incoming operation by queueing it in the list of open operations.\n     */\n    handle(op) {\n        return new Observable((observer) => {\n            const testOp = new TestOperation(op, observer);\n            this.open.push(testOp);\n        });\n    }\n    /**\n     * Helper function to search for operations in the list of open operations.\n     */\n    _match(match) {\n        if (typeof match === 'string') {\n            return this.open.filter((testOp) => testOp.operation.operationName === match);\n        }\n        else if (typeof match === 'function') {\n            return this.open.filter((testOp) => match(testOp.operation));\n        }\n        else {\n            if (this.isDocumentNode(match)) {\n                return this.open.filter((testOp) => print(testOp.operation.query) === print(match));\n            }\n            return this.open.filter((testOp) => this.matchOp(match, testOp));\n        }\n    }\n    matchOp(match, testOp) {\n        const variables = JSON.stringify(match.variables);\n        const extensions = JSON.stringify(match.extensions);\n        const sameName = this.compare(match.operationName, testOp.operation.operationName);\n        const sameVariables = this.compare(variables, testOp.operation.variables);\n        const sameQuery = print(testOp.operation.query) === print(match.query);\n        const sameExtensions = this.compare(extensions, testOp.operation.extensions);\n        return sameName && sameVariables && sameQuery && sameExtensions;\n    }\n    compare(expected, value) {\n        const prepare = (val) => typeof val === 'string' ? val : JSON.stringify(val);\n        const received = prepare(value);\n        return !expected || received === expected;\n    }\n    /**\n     * Search for operations in the list of open operations, and return all that match\n     * without asserting anything about the number of matches.\n     */\n    match(match) {\n        const results = this._match(match);\n        results.forEach((result) => {\n            const index = this.open.indexOf(result);\n            if (index !== -1) {\n                this.open.splice(index, 1);\n            }\n        });\n        return results;\n    }\n    /**\n     * Expect that a single outstanding request matches the given matcher, and return\n     * it.\n     *\n     * operations returned through this API will no longer be in the list of open operations,\n     * and thus will not match twice.\n     */\n    expectOne(match, description) {\n        description = description || this.descriptionFromMatcher(match);\n        const matches = this.match(match);\n        if (matches.length > 1) {\n            throw new Error(`Expected one matching operation for criteria \"${description}\", found ${matches.length} operations.`);\n        }\n        if (matches.length === 0) {\n            throw new Error(`Expected one matching operation for criteria \"${description}\", found none.`);\n        }\n        return matches[0];\n    }\n    /**\n     * Expect that no outstanding operations match the given matcher, and throw an error\n     * if any do.\n     */\n    expectNone(match, description) {\n        description = description || this.descriptionFromMatcher(match);\n        const matches = this.match(match);\n        if (matches.length > 0) {\n            throw new Error(`Expected zero matching operations for criteria \"${description}\", found ${matches.length}.`);\n        }\n    }\n    /**\n     * Validate that there are no outstanding operations.\n     */\n    verify() {\n        const open = this.open;\n        if (open.length > 0) {\n            // Show the methods and URLs of open operations in the error, for convenience.\n            const operations = open\n                .map((testOp) => testOp.operation.operationName)\n                .join(', ');\n            throw new Error(`Expected no open operations, found ${open.length}: ${operations}`);\n        }\n    }\n    isDocumentNode(docOrOp) {\n        return !docOrOp.operationName;\n    }\n    descriptionFromMatcher(matcher) {\n        if (typeof matcher === 'string') {\n            return `Match operationName: ${matcher}`;\n        }\n        else if (typeof matcher === 'object') {\n            if (this.isDocumentNode(matcher)) {\n                return `Match DocumentNode`;\n            }\n            const name = matcher.operationName || '(any)';\n            const variables = JSON.stringify(matcher.variables) || '(any)';\n            return `Match operation: ${name}, variables: ${variables}`;\n        }\n        else {\n            return `Match by function: ${matcher.name}`;\n        }\n    }\n}\nApolloTestingBackend.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingBackend, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nApolloTestingBackend.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingBackend });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingBackend, decorators: [{\n            type: Injectable\n        }] });\n\nconst APOLLO_TESTING_CACHE = new InjectionToken('apollo-angular/testing cache');\nconst APOLLO_TESTING_NAMED_CACHE = new InjectionToken('apollo-angular/testing named cache');\nconst APOLLO_TESTING_CLIENTS = new InjectionToken('apollo-angular/testing named clients');\nfunction addClient(name, op) {\n    op.clientName = name;\n    return op;\n}\nclass ApolloTestingModuleCore {\n    constructor(apollo, backend, namedClients, cache, namedCaches) {\n        function createOptions(name, c) {\n            return {\n                link: new ApolloLink((operation) => backend.handle(addClient(name, operation))),\n                cache: c ||\n                    new InMemoryCache({\n                        addTypename: false,\n                    }),\n            };\n        }\n        apollo.create(createOptions('default', cache));\n        if (namedClients && namedClients.length) {\n            namedClients.forEach((name) => {\n                const caches = namedCaches && typeof namedCaches === 'object' ? namedCaches : {};\n                apollo.createNamed(name, createOptions(name, caches[name]));\n            });\n        }\n    }\n}\nApolloTestingModuleCore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModuleCore, deps: [{ token: i1.Apollo }, { token: ApolloTestingBackend }, { token: APOLLO_TESTING_CLIENTS, optional: true }, { token: APOLLO_TESTING_CACHE, optional: true }, { token: APOLLO_TESTING_NAMED_CACHE, optional: true }], target: i0.ɵɵFactoryTarget.NgModule });\nApolloTestingModuleCore.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModuleCore, imports: [ApolloModule] });\nApolloTestingModuleCore.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModuleCore, providers: [\n        ApolloTestingBackend,\n        { provide: ApolloTestingController, useExisting: ApolloTestingBackend },\n    ], imports: [[ApolloModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModuleCore, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [ApolloModule],\n                    providers: [\n                        ApolloTestingBackend,\n                        { provide: ApolloTestingController, useExisting: ApolloTestingBackend },\n                    ],\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i1.Apollo }, { type: ApolloTestingBackend }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [APOLLO_TESTING_CLIENTS]\n                    }] }, { type: i3.ApolloCache, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [APOLLO_TESTING_CACHE]\n                    }] }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [APOLLO_TESTING_NAMED_CACHE]\n                    }] }];\n    } });\nclass ApolloTestingModule {\n    static withClients(names) {\n        return {\n            ngModule: ApolloTestingModuleCore,\n            providers: [\n                {\n                    provide: APOLLO_TESTING_CLIENTS,\n                    useValue: names,\n                },\n            ],\n        };\n    }\n}\nApolloTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nApolloTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModule, imports: [ApolloTestingModuleCore] });\nApolloTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModule, imports: [[ApolloTestingModuleCore]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: ApolloTestingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [ApolloTestingModuleCore],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { APOLLO_TESTING_CACHE, APOLLO_TESTING_NAMED_CACHE, ApolloTestingController, ApolloTestingModule, TestOperation };\n"]},"metadata":{},"sourceType":"module"}