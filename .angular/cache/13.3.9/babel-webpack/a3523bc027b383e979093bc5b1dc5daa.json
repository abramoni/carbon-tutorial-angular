{"ast":null,"code":"'use strict';\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  (function (_global) {\n    var AsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this._existingFinishTimer = null;\n        this.entryFunction = null;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n      };\n\n      AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this; // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n        // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n        // microtasks in the proxy zone that now complete as part of this async zone run.\n        // Consider the following scenario:\n        //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n        //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n        //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n        //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n        //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n        //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n        // If the finish timeout from below is already scheduled, terminate the existing scheduled\n        // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n        // want to schedule a new finish callback in case the task state changes again.\n\n\n        if (this._existingFinishTimer !== null) {\n          clearTimeout(this._existingFinishTimer);\n          this._existingFinishTimer = null;\n        }\n\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We wait until the next tick because we would like to catch unhandled promises which could\n          // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n          this.runZone.run(function () {\n            _this._existingFinishTimer = setTimeout(function () {\n              if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                _this.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n\n        return delegate.scheduleTask(target, task);\n      };\n\n      AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      };\n\n      AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.cancelTask(target, task);\n      }; // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n\n\n      AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        if (!this.entryFunction) {\n          this.entryFunction = delegate;\n        }\n\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          // We need to check the delegate is the same as entryFunction or not.\n          // Consider the following case.\n          //\n          // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n          //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n          //   });\n          // });\n          //\n          // We only want to check whether there are async tasks scheduled\n          // for the entry function.\n          if (this._isSync && this.entryFunction === delegate) {\n            this._finishCallbackIfDone();\n          }\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n\n        return false;\n      };\n\n      AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState); // We should only trigger finishCallback when the target zone is the AsyncTestZone\n        // Consider the following cases.\n        //\n        // const childZone = asyncTestZone.fork({\n        //   name: 'child',\n        //   onHasTask: ...\n        // });\n        //\n        // So we have nested zones declared the onHasTask hook, in this case,\n        // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n        // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n        // when the current zone is the same as the target zone.\n\n        if (current !== target) {\n          return;\n        }\n\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n\n          this._finishCallbackIfDone();\n        }\n      };\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function () {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/async-test');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // still this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n});","map":{"version":3,"sources":["C:/Users/07545G744/Documents/projects/carbon-tutorial-angular/node_modules/zone.js/dist/async-test.js"],"names":["factory","define","amd","_global","AsyncTestZoneSpec","finishCallback","failCallback","namePrefix","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","_existingFinishTimer","entryFunction","runZone","Zone","current","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","name","properties","__symbol__","prototype","isUnresolvedChainedPromisePending","_finishCallbackIfDone","_this","clearTimeout","run","setTimeout","patchPromiseForTest","Promise","unPatchPromiseForTest","onScheduleTask","delegate","target","task","type","data","symbolParentUnresolved","scheduleTask","onInvokeTask","applyThis","applyArgs","invokeTask","onCancelTask","cancelTask","onInvoke","parentZoneDelegate","currentZone","targetZone","source","invoke","onHandleError","error","result","handleError","onHasTask","hasTaskState","hasTask","change","microTask","macroTask","window","self","global","__load_patch","api","symbol","asyncTest","fn","jasmine","done","fail","e","runInTestZone","err","Error","context","undefined","ProxyZoneSpec","proxyZoneSpec","get","assertPresent","proxyZone","getZoneWith","previousDelegate","getDelegate","parent","testZoneSpec","setDelegate","runGuarded"],"mappings":"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","sourcesContent":["'use strict';\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n})((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        var AsyncTestZoneSpec = /** @class */ (function () {\n            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this._existingFinishTimer = null;\n                this.entryFunction = null;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n                return this.unresolvedChainedPromiseCount > 0;\n            };\n            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n                var _this = this;\n                // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n                // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n                // microtasks in the proxy zone that now complete as part of this async zone run.\n                // Consider the following scenario:\n                //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n                //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n                //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n                //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n                //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n                //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n                // If the finish timeout from below is already scheduled, terminate the existing scheduled\n                // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n                // want to schedule a new finish callback in case the task state changes again.\n                if (this._existingFinishTimer !== null) {\n                    clearTimeout(this._existingFinishTimer);\n                    this._existingFinishTimer = null;\n                }\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We wait until the next tick because we would like to catch unhandled promises which could\n                    // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n                    this.runZone.run(function () {\n                        _this._existingFinishTimer = setTimeout(function () {\n                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                                _this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            };\n            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            };\n            AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            };\n            AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            };\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                if (!this.entryFunction) {\n                    this.entryFunction = delegate;\n                }\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    // We need to check the delegate is the same as entryFunction or not.\n                    // Consider the following case.\n                    //\n                    // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n                    //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n                    //   });\n                    // });\n                    //\n                    // We only want to check whether there are async tasks scheduled\n                    // for the entry function.\n                    if (this._isSync && this.entryFunction === delegate) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            };\n            AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                var result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            };\n            AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                // We should only trigger finishCallback when the target zone is the AsyncTestZone\n                // Consider the following cases.\n                //\n                // const childZone = asyncTestZone.fork({\n                //   name: 'child',\n                //   onHasTask: ...\n                // });\n                //\n                // So we have nested zones declared the onHasTask hook, in this case,\n                // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n                // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n                // when the current zone is the same as the target zone.\n                if (current !== target) {\n                    return;\n                }\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            };\n            return AsyncTestZoneSpec;\n        }());\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n    Zone.__load_patch('asynctest', function (global, Zone, api) {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, function (err) {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var _this = this;\n                return new Promise(function (finishCallback, failCallback) {\n                    runInTestZone(fn, _this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            var currentZone = Zone.current;\n            var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/async-test');\n            }\n            var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/proxy');\n            }\n            var proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            var previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(function () {\n                var testZoneSpec = new AsyncTestZoneSpec(function () {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // still this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        finishCallback();\n                    });\n                }, function (error) {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n}));\n"]},"metadata":{},"sourceType":"script"}