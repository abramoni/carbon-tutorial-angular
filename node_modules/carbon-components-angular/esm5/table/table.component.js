/**
 *
 * carbon-angular v0.0.0 | table.component.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Component, ApplicationRef, Input, Output, EventEmitter, ElementRef, TemplateRef, HostBinding } from "@angular/core";
import { Subscription, fromEvent } from "rxjs";
import { TableModel } from "./table-model.class";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { getFocusElementList, tabbableSelectorIgnoreTabIndex } from "carbon-components-angular/common";
import { I18n } from "carbon-components-angular/i18n";
import { merge } from "carbon-components-angular/utils";
import { DataGridInteractionModel } from "./data-grid-interaction-model.class";
import { TableDomAdapter } from "./table-adapter.class";
/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/components-table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<ibm-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table [model]="model"></ibm-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <ibm-table [model]="model">No data.</ibm-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <ibm-pagination [model]="model" (selectPage)="selectPage($event)"></ibm-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=components-table--basic</example-url>
 */
var Table = /** @class */ (function () {
    /**
     * Creates an instance of Table.
     */
    function Table(elementRef, applicationRef, i18n) {
        this.elementRef = elementRef;
        this.applicationRef = applicationRef;
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        this.noBorder = true;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Distance (in px) from the bottom that view has to reach before
         * `scrollLoad` event is emitted.
         */
        this.scrollLoadDistance = 0;
        /**
         * Set to `true` to enable users to resize columns.
         *
         * Works for columns with width set in pixels.
         *
         */
        this.columnsResizable = false;
        /**
         * Set to `true` to enable users to drag and drop columns.
         *
         * Changing the column order in table changes table model. Be aware of it when you add additional data
         * to the model.
         *
         */
        this.columnsDraggable = false;
        /**
         * Set to `false` to remove table rows (zebra) stripes.
         */
        this.striped = true;
        /**
         * Allows table content to scroll horizontally
         */
        this.tableContent = true;
        /**
         * Set to `true` to stick the header to the top of the table
         */
        this.stickyHeader = false;
        /**
         * Emits an index of the column that wants to be sorted.
         *
         * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
         * into the model.
         *
         * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
         * to sort the table. This is what you typically want if you're using a backend query to get the sorted
         * data or want to sort data across multiple pages.
         *
         * Usage:
         *
         * ```typescript
         * @Component({
         * 	selector: "app-table",
         * 	template: `
         * 		<ibm-table
         * 			[model]="model"
         * 			(sort)="simpleSort($event)">
         * 			No data.
         * 		</ibm-table>
         * 	`
         * })
         * export class TableApp implements OnInit, OnChanges {
         * 	@Input() model = new TableModel();
         *
         * 	ngOnInit() {
         * 		this.model.header = [
         * 			new TableHeaderItem({ data: "Name" }),
         * 			new TableHeaderItem({ data: "hwer" })
         * 		];
         *
         * 		this.model.data = [
         * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
         * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
         * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
         * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
         * 		];
         * 	}
         *
         * 	simpleSort(index: number) {
         * 		// this function does a simple sort, which is the default for the table and if that's
         * 		// all you want, you don't need to do this.
         *
         * 		// here you can query your backend and update the model.data based on the result
         * 		if (this.model.header[index].sorted) {
         * 			// if already sorted flip sorting direction
         * 			this.model.header[index].ascending = this.model.header[index].descending;
         * 		}
         * 		this.model.sort(index);
         * 	}
         * }
         * ```
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emits when table requires more data to be loaded.
         */
        this.scrollLoad = new EventEmitter();
        /**
         * Controls if all checkboxes are viewed as selected.
         */
        this.selectAllCheckbox = false;
        /**
         * Controls the indeterminate state of the header checkbox.
         */
        this.selectAllCheckboxSomeSelected = false;
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this._isDataGrid = false;
        // flag to prevent getters/setters from querying the view before it's fully instantiated
        this.isViewReady = false;
        this.subscriptions = new Subscription();
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
        this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    Table.skeletonModel = function (rowCount, columnCount) {
        var model = new TableModel();
        var header = new Array();
        var data = new Array();
        var row = new Array();
        for (var i = 0; i < columnCount; i++) {
            header.push(new TableHeaderItem());
            row.push(new TableItem());
        }
        for (var i = 0; i < rowCount - 1; i++) {
            data.push(row);
        }
        model.header = header;
        model.data = data;
        return model;
    };
    Table.setTabIndex = function (element, index) {
        var focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 0) {
            focusElementList[0].tabIndex = index;
        }
        else {
            element.tabIndex = index;
        }
    };
    Table.focus = function (element) {
        var focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 0) {
            focusElementList[0].focus();
        }
        else {
            element.focus();
        }
    };
    Object.defineProperty(Table.prototype, "model", {
        get: function () {
            return this._model;
        },
        /**
         * `TableModel` with data the table is to display.
         */
        set: function (m) {
            var _this = this;
            if (this._model) {
                this.subscriptions.unsubscribe();
                // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions
                // from being added for some reason. When a new model is set, none of the subscriptions would exist.
                this.subscriptions = new Subscription();
            }
            this._model = m;
            var rowsChange = this._model.rowsSelectedChange.subscribe(function () { return _this.updateSelectAllCheckbox(); });
            var dataChange = this._model.dataChange.subscribe(function () {
                if (_this.isDataGrid) {
                    _this.resetTabIndex();
                }
                _this.updateSelectAllCheckbox();
            });
            this.subscriptions.add(rowsChange);
            this.subscriptions.add(dataChange);
            if (this.isDataGrid) {
                var expandedChange = this._model.rowsExpandedChange.subscribe(function () {
                    // Allows the expanded row to have a focus state when it exists in the DOM
                    setTimeout(function () {
                        var expandedRows = _this.elementRef.nativeElement.querySelectorAll(".bx--expandable-row:not(.bx--parent-row)");
                        Array.from(expandedRows).forEach(function (row) {
                            if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {
                                row.firstElementChild.tabIndex = -1;
                            }
                        });
                    });
                });
                this.subscriptions.add(expandedChange);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "isDataGrid", {
        get: function () {
            return this._isDataGrid;
        },
        /**
         * Set to `true` for a data grid with keyboard interactions.
         */
        set: function (value) {
            this._isDataGrid = value;
            if (this.isViewReady) {
                if (value) {
                    this.enableDataGridInteractions();
                }
                else {
                    this.disableDataGridInteractions();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "expandButtonAriaLabel", {
        get: function () {
            return this._expandButtonAriaLabel.value;
        },
        set: function (value) {
            this._expandButtonAriaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "sortDescendingLabel", {
        get: function () {
            return this._sortDescendingLabel.value;
        },
        set: function (value) {
            this._sortDescendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "sortAscendingLabel", {
        get: function () {
            return this._sortAscendingLabel.value;
        },
        set: function (value) {
            this._sortAscendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "translations", {
        /**
         * Expects an object that contains some or all of:
         * ```
         * {
         *		"FILTER": "Filter",
         *		"END_OF_DATA": "You've reached the end of your content",
         *		"SCROLL_TOP": "Scroll to top",
         *		"CHECKBOX_HEADER": "Select all rows",
         *		"CHECKBOX_ROW": "Select row"
         * }
         * ```
         */
        set: function (value) {
            var valueWithDefaults = merge(this.i18n.getMultiple("TABLE"), value);
            this._filterTitle.override(valueWithDefaults.FILTER);
            this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
            this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
            this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
            this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "noData", {
        get: function () {
            return !this.model.data ||
                this.model.data.length === 0 ||
                this.model.data.length === 1 && this.model.data[0].length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Table.prototype.ngAfterViewInit = function () {
        this.isViewReady = true;
        if (this.isDataGrid) {
            this.enableDataGridInteractions();
        }
    };
    Table.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
    };
    Table.prototype.enableDataGridInteractions = function () {
        // if we have an `interactioModel` we've already enabled datagrid
        if (this.interactionModel) {
            return;
        }
        var table = this.elementRef.nativeElement.querySelector("table");
        var tableAdapter = new TableDomAdapter(table);
        var keydownEventStream = fromEvent(table, "keydown");
        var clickEventStream = fromEvent(table, "click");
        this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
        this.positionSubscription = this.interactionModel.position.subscribe(function (event) {
            var _a = tslib_1.__read(event.current, 2), currentRow = _a[0], currentColumn = _a[1];
            var _b = tslib_1.__read(event.previous, 2), previousRow = _b[0], previousColumn = _b[1];
            var currentElement = tableAdapter.getCell(currentRow, currentColumn);
            Table.setTabIndex(currentElement, 0);
            // if the model has just initialized don't focus or reset anything
            if (previousRow === -1 || previousColumn === -1) {
                return;
            }
            // Make the previous cell unfocusable (if it's not the current)
            if (previousRow !== currentRow || previousColumn !== currentColumn) {
                var previousElement = tableAdapter.getCell(previousRow, previousColumn);
                Table.setTabIndex(previousElement, -1);
            }
            Table.focus(currentElement);
        });
        // call this after assigning `this.interactionModel` since it depends on it
        this.resetTabIndex();
    };
    Table.prototype.disableDataGridInteractions = function () {
        // unsubscribe first so we don't cause the focus to fly around
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
        // undo tab indexing (also resets the model)
        this.resetTabIndex(0);
        // null out the model ref
        this.interactionModel = null;
    };
    Table.prototype.onSelectAll = function () {
        this.model.selectAll(true);
        this.selectAll.emit(this.model);
    };
    Table.prototype.onDeselectAll = function () {
        this.model.selectAll(false);
        this.deselectAll.emit(this.model);
    };
    Table.prototype.onSelectRow = function (event) {
        // check for the existence of the selectedRowIndex property
        if (Object.keys(event).includes("selectedRowIndex")) {
            if (this.enableSingleSelect) {
                this.model.selectAll(false);
            }
            this.model.selectRow(event.selectedRowIndex, true);
            this.selectRow.emit(event);
        }
        else {
            this.model.selectRow(event.deselectedRowIndex, false);
            this.deselectRow.emit(event);
        }
    };
    Table.prototype.onRowClick = function (index) {
        this.rowClick.emit(index);
    };
    Table.prototype.updateSelectAllCheckbox = function () {
        var selectedRowsCount = this.model.selectedRowsCount();
        if (selectedRowsCount <= 0) {
            // reset select all checkbox if nothing selected
            this.selectAllCheckbox = false;
            this.selectAllCheckboxSomeSelected = false;
        }
        else if (selectedRowsCount < this.model.data.length) {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = true;
        }
        else {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = false;
        }
    };
    Table.prototype.resetTabIndex = function (newTabIndex) {
        var _this = this;
        if (newTabIndex === void 0) { newTabIndex = -1; }
        // ensure the view is ready for the reset before we preform the actual reset
        setTimeout(function () {
            // reset all the tabIndexes we can find
            var focusElementList = getFocusElementList(_this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
            if (focusElementList) {
                focusElementList.forEach(function (tabbable) {
                    tabbable.tabIndex = newTabIndex;
                });
            }
            // reset interaction model positions and tabIndexes
            if (_this.interactionModel) {
                _this.interactionModel.resetTabIndexes(newTabIndex);
            }
        });
    };
    Table.prototype.columnResizeStart = function (event, column) {
        var _this = this;
        this.columnResizeWidth = parseInt(column.style.width, 10);
        this.columnResizeMouseX = event.clientX;
        event.preventDefault();
        this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe(function (event) {
            _this.columnResizeProgress(event, column);
        });
        this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe(function (event) {
            _this.columnResizeEnd(event, column);
        });
    };
    Table.prototype.columnResizeProgress = function (event, column) {
        var move = event.clientX - this.columnResizeMouseX;
        column.style.width = this.columnResizeWidth + move + "px";
    };
    Table.prototype.columnResizeEnd = function (event, column) {
        this.mouseMoveSubscription.unsubscribe();
        this.mouseUpSubscription.unsubscribe();
    };
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    Table.prototype.onScroll = function (event) {
        var distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
        if (distanceFromBottom <= this.scrollLoadDistance) {
            this.scrollLoad.emit(this.model);
        }
        else {
            this.model.isEnd = false;
        }
    };
    Table.prototype.columnDragStart = function (event, columnIndex) {
        this.isColumnDragging = true;
        this.columnDraggedHoverIndex = columnIndex;
        event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
    };
    Table.prototype.columnDragEnd = function (event, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
    };
    Table.prototype.columnDragEnter = function (event, position, columnIndex) {
        this.columnDraggedPosition = position;
        this.columnDraggedHoverIndex = columnIndex;
    };
    Table.prototype.columnDragLeave = function (event, position, columnIndex) {
        this.columnDraggedPosition = "";
    };
    Table.prototype.columnDragover = function (event, position, columnIndex) {
        this.columnDraggedHoverIndex = columnIndex;
        this.columnDraggedPosition = position;
        // needed to tell browser to allow dropping
        event.preventDefault();
    };
    Table.prototype.columnDrop = function (event, position, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position === "right" ? 1 : 0));
    };
    Table.prototype.doSort = function (index) {
        if (this.sort.observers.length === 0) {
            // no sort provided so do the simple sort
            if (this.model.header[index].sorted) {
                // if already sorted flip sorting direction
                this.model.header[index].ascending = this.model.header[index].descending;
            }
            this.model.sort(index);
        }
        this.sort.emit(index);
    };
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    Table.prototype.scrollToTop = function (event) {
        event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
        this.model.isEnd = false;
    };
    Table.prototype.getSelectionLabelValue = function (row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    };
    Table.prototype.getExpandButtonAriaLabel = function () {
        return this._expandButtonAriaLabel.subject;
    };
    Table.prototype.getSortDescendingLabel = function () {
        return this._sortDescendingLabel.subject;
    };
    Table.prototype.getSortAscendingLabel = function () {
        return this._sortAscendingLabel.subject;
    };
    Table.prototype.getCheckboxHeaderLabel = function () {
        return this._checkboxHeaderLabel.subject;
    };
    Table.prototype.getCheckboxRowLabel = function () {
        return this._checkboxRowLabel.subject;
    };
    Table.prototype.getEndOfDataText = function () {
        return this._endOfDataText.subject;
    };
    Table.prototype.getScrollTopText = function () {
        return this._scrollTopText.subject;
    };
    Table.prototype.getFilterTitle = function () {
        return this._filterTitle.subject;
    };
    Table.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table",
                    template: "\n\t<table\n\t\tibmTable\n\t\t[sortable]=\"sortable\"\n\t\t[noBorder]=\"noBorder\"\n\t\t[ngClass]=\"{'bx--data-table--sticky-header': stickyHeader}\"\n\t\t[size]=\"size\"\n\t\t[striped]=\"striped\"\n\t\t[skeleton]=\"skeleton\"\n\t\t[attr.aria-labelledby]=\"ariaLabelledby\"\n\t\t[attr.aria-describedby]=\"ariaDescribedby\">\n\t\t<thead\n\t\t\tibmTableHead\n\t\t\t[sortable]=\"sortable\"\n\t\t\t(deselectAll)=\"onDeselectAll()\"\n\t\t\t(selectAll)=\"onSelectAll()\"\n\t\t\t(sort)=\"doSort($event)\"\n\t\t\t[checkboxHeaderLabel]=\"getCheckboxHeaderLabel()\"\n\t\t\t[filterTitle]=\"getFilterTitle()\"\n\t\t\t[model]=\"model\"\n\t\t\t[size]=\"size\"\n\t\t\t[selectAllCheckbox]=\"selectAllCheckbox\"\n\t\t\t[selectAllCheckboxSomeSelected]=\"selectAllCheckboxSomeSelected\"\n\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t[skeleton]=\"skeleton\"\n\t\t\t[sortAscendingLabel]=\"sortAscendingLabel\"\n\t\t\t[sortDescendingLabel]=\"sortDescendingLabel\"\n\t\t\t[stickyHeader]=\"stickyHeader\">\n\t\t</thead>\n\t\t<tbody\n\t\t\tibmTableBody\n\t\t\t(deselectRow)=\"onSelectRow($event)\"\n\t\t\t(scroll)=\"onScroll($event)\"\n\t\t\t(selectRow)=\"onSelectRow($event)\"\n\t\t\t[checkboxRowLabel]=\"getCheckboxRowLabel()\"\n\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t(rowClick)=\"onRowClick($event)\"\n\t\t\t[expandButtonAriaLabel]=\"expandButtonAriaLabel\"\n\t\t\t[model]=\"model\"\n\t\t\t[size]=\"size\"\n\t\t\t[ngStyle]=\"{'overflow-y': 'scroll'}\"\n\t\t\t[selectionLabelColumn]=\"selectionLabelColumn\"\n\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t[skeleton]=\"skeleton\"\n\t\t\t*ngIf=\"!noData; else noDataTemplate\">\n\t\t</tbody>\n\t\t<ng-template #noDataTemplate><ng-content></ng-content></ng-template>\n\t\t<tfoot>\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"footerTemplate\">\n\t\t\t</ng-template>\n\t\t\t<tr *ngIf=\"this.model.isLoading\">\n\t\t\t\t<td class=\"table_loading-indicator\">\n\t\t\t\t\t<div class=\"bx--loading bx--loading--small\">\n\t\t\t\t\t\t<svg class=\"bx--loading__svg\" viewBox=\"-75 -75 150 150\">\n\t\t\t\t\t\t\t<circle class=\"bx--loading__stroke\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr *ngIf=\"this.model.isEnd\">\n\t\t\t\t<td class=\"table_end-indicator\">\n\t\t\t\t\t<h5>{{getEndOfDataText() | async}}</h5>\n\t\t\t\t\t<button (click)=\"scrollToTop($event)\" class=\"btn--secondary-sm\">\n\t\t\t\t\t\t{{getScrollTopText() | async}}\n\t\t\t\t\t</button>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tfoot>\n\t</table>\n\t",
                    styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"]
                }] }
    ];
    /** @nocollapse */
    Table.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ApplicationRef },
        { type: I18n }
    ]; };
    Table.propDecorators = {
        ariaLabelledby: [{ type: Input }],
        ariaDescribedby: [{ type: Input }],
        model: [{ type: Input }],
        size: [{ type: Input }],
        skeleton: [{ type: Input }],
        isDataGrid: [{ type: Input }],
        sortable: [{ type: Input }],
        noBorder: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        scrollLoadDistance: [{ type: Input }],
        columnsResizable: [{ type: Input }],
        columnsDraggable: [{ type: Input }],
        expandButtonAriaLabel: [{ type: Input }],
        sortDescendingLabel: [{ type: Input }],
        sortAscendingLabel: [{ type: Input }],
        translations: [{ type: Input }],
        striped: [{ type: Input }],
        tableContent: [{ type: HostBinding, args: ["class.bx--data-table-content",] }],
        stickyHeader: [{ type: HostBinding, args: ["class.bx--data-table_inner-container",] }, { type: Input }],
        footerTemplate: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        sort: [{ type: Output }],
        selectAll: [{ type: Output }],
        deselectAll: [{ type: Output }],
        selectRow: [{ type: Output }],
        deselectRow: [{ type: Output }],
        rowClick: [{ type: Output }],
        scrollLoad: [{ type: Output }]
    };
    return Table;
}());
export { Table };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci90YWJsZS8iLCJzb3VyY2VzIjpbInRhYmxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxjQUFjLEVBQ2QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osVUFBVSxFQUVWLFdBQVcsRUFFWCxXQUFXLEVBQ1gsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFFM0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFL0MsT0FBTyxFQUFFLG1CQUFtQixFQUFFLDhCQUE4QixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDdkcsT0FBTyxFQUFFLElBQUksRUFBZSxNQUFNLGdDQUFnQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN4RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUMvRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHeEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0pHO0FBQ0g7SUFpZEM7O09BRUc7SUFDSCxlQUNXLFVBQXNCLEVBQ3RCLGNBQThCLEVBQzlCLElBQVU7UUFGVixlQUFVLEdBQVYs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QUFDO0lBRUQsbUNBQW1CLEdBQW5CO1FBQ0MsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxnQ0FBZ0IsR0FBaEI7UUFDQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxnQ0FBZ0IsR0FBaEI7UUFDQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO0lBQ3BDLENBQUM7SUFFRCw4QkFBYyxHQUFkO1FBQ0MsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztJQUNsQyxDQUFDOztnQkFudEJELFNBQVMsU0FBQztvQkFDVixRQUFRLEVBQUUsV0FBVztvQkFDckIsUUFBUSxFQUFFLDBpRkF1RVQ7NkJBQ1EsaURBSVI7aUJBQ0Q7Ozs7Z0JBclBBLFVBQVU7Z0JBSlYsY0FBYztnQkFpQk4sSUFBSTs7O2lDQTJSWCxLQUFLO2tDQUlMLEtBQUs7d0JBS0wsS0FBSzt1QkE2Q0wsS0FBSzsyQkFJTCxLQUFLOzZCQUlMLEtBQUs7MkJBZUwsS0FBSzsyQkFFTCxLQUFLO3NDQVNMLEtBQUs7cUNBS0wsS0FBSztxQ0FNTCxLQUFLO21DQVFMLEtBQUs7bUNBU0wsS0FBSzt3Q0FFTCxLQUFLO3NDQU9MLEtBQUs7cUNBT0wsS0FBSzsrQkFvQkwsS0FBSzswQkFhTCxLQUFLOytCQUtMLFdBQVcsU0FBQyw4QkFBOEI7K0JBSzFDLFdBQVcsU0FBQyxzQ0FBc0MsY0FBRyxLQUFLO2lDQUsxRCxLQUFLO3VDQVlMLEtBQUs7dUJBMERMLE1BQU07NEJBT04sTUFBTTs4QkFPTixNQUFNOzRCQU9OLE1BQU07OEJBT04sTUFBTTsyQkFLTixNQUFNOzZCQUtOLE1BQU07O0lBa1RSLFlBQUM7Q0FBQSxBQXB0QkQsSUFvdEJDO1NBcG9CWSxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRBcHBsaWNhdGlvblJlZixcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRFbGVtZW50UmVmLFxuXHRBZnRlclZpZXdJbml0LFxuXHRUZW1wbGF0ZVJlZixcblx0T25EZXN0cm95LFxuXHRIb3N0QmluZGluZ1xufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBmcm9tRXZlbnQsIE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuXG5pbXBvcnQgeyBUYWJsZU1vZGVsIH0gZnJvbSBcIi4vdGFibGUtbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlSGVhZGVySXRlbSB9IGZyb20gXCIuL3RhYmxlLWhlYWRlci1pdGVtLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZUl0ZW0gfSBmcm9tIFwiLi90YWJsZS1pdGVtLmNsYXNzXCI7XG5cbmltcG9ydCB7IGdldEZvY3VzRWxlbWVudExpc3QsIHRhYmJhYmxlU2VsZWN0b3JJZ25vcmVUYWJJbmRleCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHsgSTE4biwgT3ZlcnJpZGFibGUgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5pbXBvcnQgeyBEYXRhR3JpZEludGVyYWN0aW9uTW9kZWwgfSBmcm9tIFwiLi9kYXRhLWdyaWQtaW50ZXJhY3Rpb24tbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlRG9tQWRhcHRlciB9IGZyb20gXCIuL3RhYmxlLWFkYXB0ZXIuY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlUm93U2l6ZSB9IGZyb20gXCIuL3RhYmxlLnR5cGVzXCI7XG5cbi8qKlxuICogQnVpbGQgeW91ciB0YWJsZSB3aXRoIHRoaXMgY29tcG9uZW50IGJ5IGV4dGVuZGluZyB0aGluZ3MgdGhhdCBkaWZmZXIgZnJvbSBkZWZhdWx0LlxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtdGFibGUtLWJhc2ljKVxuICpcbiAqIEluc3RlYWQgb2YgdGhlIHVzdWFsIHdyaXRlLXlvdXItb3duLWh0bWwgYXBwcm9hY2ggeW91IGhhZCB3aXRoIGA8dGFibGU+YCxcbiAqIGNhcmJvbiB0YWJsZSB1c2VzIG1vZGVsLXZpZXctY29udHJvbGxlciBhcHByb2FjaC5cbiAqXG4gKiBIZXJlLCB5b3UgY3JlYXRlIGEgdmlldyAod2l0aCBidWlsdC1pbiBjb250cm9sbGVyKSBhbmQgcHJvdmlkZSBpdCBhIG1vZGVsLlxuICogQ2hhbmdlcyB5b3UgbWFrZSB0byB0aGUgbW9kZWwgYXJlIHJlZmxlY3RlZCBpbiB0aGUgdmlldy4gUHJvdmlkZSBzYW1lIG1vZGVsIHlvdSB1c2VcbiAqIGluIHRoZSB0YWJsZSB0byB0aGUgYDxpYm0tcGFnaW5hdGlvbj5gIGNvbXBvbmVudHMuXG4gKiBUaGV5IHByb3ZpZGUgYSBkaWZmZXJlbnQgdmlldyBvdmVyIHRoZSBzYW1lIGRhdGEuXG4gKlxuICogIyMgQmFzaWMgdXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKiA8aWJtLXRhYmxlIFttb2RlbF09XCJtb2RlbFwiPjwvaWJtLXRhYmxlPlxuICogYGBgXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogcHVibGljIG1vZGVsID0gbmV3IFRhYmxlTW9kZWwoKTtcbiAqXG4gKiB0aGlzLm1vZGVsLmRhdGEgPSBbXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImFzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInF3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiendlclwifSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJic2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJzd2VyXCJ9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXVxuICogXTtcbiAqIGBgYFxuICpcbiAqICMjIEN1c3RvbWl6YXRpb25cbiAqXG4gKiBJZiB5b3UgaGF2ZSBjdXN0b20gZGF0YSBpbiB5b3VyIHRhYmxlLCB5b3UgbmVlZCBhIHdheSB0byBkaXNwbGF5IGl0LiBZb3UgY2FuIGRvIHRoYXRcbiAqIGJ5IHByb3ZpZGluZyBhIHRlbXBsYXRlIHRvIGBUYWJsZUl0ZW1gLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuZy10ZW1wbGF0ZSAjY3VzdG9tVGFibGVJdGVtVGVtcGxhdGUgbGV0LWRhdGE9XCJkYXRhXCI+XG4gKiBcdDxhIFtyb3V0ZXJMaW5rXT1cImRhdGEubGlua1wiPnt7ZGF0YS5uYW1lfX0ge3tkYXRhLnN1cm5hbWV9fTwvYT5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKiBgYGBcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAqXG4gKiB0aGlzLmN1c3RvbU1vZGVsLmRhdGEgPSBbXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImFzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiB7bmFtZTogXCJMZXNzeVwiLCBsaW5rOiBcIi90YWJsZVwifSwgdGVtcGxhdGU6IHRoaXMuY3VzdG9tVGFibGVJdGVtVGVtcGxhdGV9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInN3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiYnNkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IHtuYW1lOiBcIkFsaWNlXCIsIHN1cm5hbWU6IFwiQm9iXCJ9LCB0ZW1wbGF0ZTogdGhpcy5jdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZX0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldLFxuICogXTtcbiAqIGBgYFxuICpcbiAqICMjIyBTb3J0aW5nIGFuZCBmaWx0ZXJpbmdcbiAqXG4gKiBJbiBjYXNlIHlvdSBuZWVkIGN1c3RvbSBzb3J0aW5nIGFuZC9vciBmaWx0ZXJpbmcgeW91IHNob3VsZCBzdWJjbGFzcyBgVGFibGVIZWFkZXJJdGVtYFxuICogYW5kIG92ZXJyaWRlIG5lZWRlZCBmdW5jdGlvbnMuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgRmlsdGVyYWJsZUhlYWRlckl0ZW0gZXh0ZW5kcyBUYWJsZUhlYWRlckl0ZW0ge1xuICogXHQvLyBjdXN0b20gZmlsdGVyIGZ1bmN0aW9uXG4gKiBcdGZpbHRlcihpdGVtOiBUYWJsZUl0ZW0pOiBib29sZWFuIHtcbiAqIFx0XHRpZiAodHlwZW9mIGl0ZW0uZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBpdGVtLmRhdGEudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyRGF0YS5kYXRhLnRvTG93ZXJDYXNlKCkpID49IDAgfHxcbiAqIFx0XHRpdGVtLmRhdGEubmFtZSAmJiBpdGVtLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXJEYXRhLmRhdGEudG9Mb3dlckNhc2UoKSkgPj0gMCB8fFxuICogXHRcdGl0ZW0uZGF0YS5zdXJuYW1lICYmIGl0ZW0uZGF0YS5zdXJuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlckRhdGEuZGF0YS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gKiBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gKiBcdFx0fVxuICogXHRcdHJldHVybiB0cnVlO1xuICogXHR9XG4gKlxuICogXHRzZXQgZmlsdGVyQ291bnQobikge31cbiAqIFx0Z2V0IGZpbHRlckNvdW50KCkge1xuICogXHRcdHJldHVybiAodGhpcy5maWx0ZXJEYXRhICYmIHRoaXMuZmlsdGVyRGF0YS5kYXRhICYmIHRoaXMuZmlsdGVyRGF0YS5kYXRhLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gKiBcdH1cbiAqXG4gKiBcdC8vIHVzZWQgZm9yIGN1c3RvbSBzb3J0aW5nXG4gKiBcdGNvbXBhcmUob25lOiBUYWJsZUl0ZW0sIHR3bzogVGFibGVJdGVtKSB7XG4gKiBcdFx0Y29uc3Qgc3RyaW5nT25lID0gKG9uZS5kYXRhLm5hbWUgfHwgb25lLmRhdGEuc3VybmFtZSB8fCBvbmUuZGF0YSkudG9Mb3dlckNhc2UoKTtcbiAqIFx0XHRjb25zdCBzdHJpbmdUd28gPSAodHdvLmRhdGEubmFtZSB8fCB0d28uZGF0YS5zdXJuYW1lIHx8IHR3by5kYXRhKS50b0xvd2VyQ2FzZSgpO1xuICpcbiAqIFx0XHRpZiAoc3RyaW5nT25lID4gc3RyaW5nVHdvKSB7XG4gKiBcdFx0XHRyZXR1cm4gMTtcbiAqIFx0XHR9IGVsc2UgaWYgKHN0cmluZ09uZSA8IHN0cmluZ1R3bykge1xuICogXHRcdFx0cmV0dXJuIC0xO1xuICogXHRcdH0gZWxzZSB7XG4gKiBcdFx0XHRyZXR1cm4gMDtcbiAqIFx0XHR9XG4gKiBcdH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIElmIHlvdSB3YW50IHRvIGRvIHlvdXIgc29ydGluZyBvbiB0aGUgYmFja2VuZCBvciBxdWVyeSBmb3Igc29ydGVkIGRhdGEgYXMgYSByZXN1bHQgb2YgdXNlclxuICogY2xpY2tpbmcgdGhlIHRhYmxlIGhlYWRlciwgY2hlY2sgdGFibGUgW2Bzb3J0YF0oI3NvcnQpIG91dHB1dCBkb2N1bWVudGF0aW9uXG4gKlxuICogU2VlIGBUYWJsZUhlYWRlckl0ZW1gIGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqICMjIE5vIGRhdGEgdGVtcGxhdGVcbiAqXG4gKiBXaGVuIHRhYmxlIGhhcyBubyBkYXRhIHRvIHNob3csIGl0IGNhbiBzaG93IGEgbWVzc2FnZSB5b3UgcHJvdmlkZSBpdCBpbnN0ZWFkLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tdGFibGUgW21vZGVsXT1cIm1vZGVsXCI+Tm8gZGF0YS48L2libS10YWJsZT5cbiAqIGBgYFxuICpcbiAqIC4uLiB3aWxsIHNob3cgYE5vIGRhdGEuYCBtZXNzYWdlLCBidXQgeW91IGNhbiBnZXQgY3JlYXRpdmUgYW5kIHByb3ZpZGUgYW55IHRlbXBsYXRlIHlvdSB3YW50XG4gKiB0byByZXBsYWNlIHRhYmxlJ3MgZGVmYXVsdCBgdGJvZHlgLlxuICpcbiAqICMjIFVzZSBwYWdpbmF0aW9uIGFzIHRhYmxlIGZvb3RlclxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tcGFnaW5hdGlvbiBbbW9kZWxdPVwibW9kZWxcIiAoc2VsZWN0UGFnZSk9XCJzZWxlY3RQYWdlKCRldmVudClcIj48L2libS1wYWdpbmF0aW9uPlxuICogYGBgXG4gKlxuICogYHNlbGVjdFBhZ2UoKWAgZnVuY3Rpb24gc2hvdWxkIGZldGNoIHRoZSBkYXRhIGZyb20gYmFja2VuZCwgY3JlYXRlIG5ldyBgZGF0YWAsIGFwcGx5IGl0IHRvIGBtb2RlbC5kYXRhYCxcbiAqIGFuZCB1cGRhdGUgYG1vZGVsLmN1cnJlbnRQYWdlYC5cbiAqXG4gKiBJZiB0aGUgZGF0YSB5b3VyIHNlcnZlciByZXR1cm5zIGlzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIG9iamVjdHMsIGl0IHdvdWxkIGxvb2sgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZWxlY3RQYWdlKHBhZ2UpIHtcbiAqIFx0dGhpcy5nZXRQYWdlKHBhZ2UpLnRoZW4oKGRhdGE6IEFycmF5PEFycmF5PGFueT4+KSA9PiB7XG4gKiBcdFx0Ly8gc2V0IHRoZSBkYXRhIGFuZCB1cGRhdGUgcGFnZVxuICogXHRcdHRoaXMubW9kZWwuZGF0YSA9IHRoaXMucHJlcGFyZURhdGEoZGF0YSk7XG4gKiBcdFx0dGhpcy5tb2RlbC5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gKiBcdH0pO1xuICogfVxuICpcbiAqIHByb3RlY3RlZCBwcmVwYXJlRGF0YShkYXRhOiBBcnJheTxBcnJheTxhbnk+Pikge1xuICogXHQvLyBjcmVhdGUgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmljZSBkYXRhXG4gKiBcdGxldCBuZXdEYXRhID0gW107XG4gKiBcdGRhdGEuZm9yRWFjaChkYXRhUm93ID0+IHtcbiAqIFx0XHRsZXQgcm93ID0gW107XG4gKiBcdFx0ZGF0YVJvdy5mb3JFYWNoKGRhdGFFbGVtZW50ID0+IHtcbiAqIFx0XHRcdHJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oe1xuICogXHRcdFx0XHRkYXRhOiBkYXRhRWxlbWVudCxcbiAqIFx0XHRcdFx0dGVtcGxhdGU6IHR5cGVvZiBkYXRhRWxlbWVudCA9PT0gXCJzdHJpbmdcIiA/IHVuZGVmaW5lZCA6IHRoaXMucGFnaW5hdGlvblRhYmxlSXRlbVRlbXBsYXRlXG4gKiBcdFx0XHRcdC8vIHlvdXIgdGVtcGxhdGUgY2FuIGhhbmRsZSBhbGwgdGhlIGRhdGEgdHlwZXMgc28geW91IGRvbid0IGhhdmUgdG8gY29uZGl0aW9uYWxseSBzZXQgaXRcbiAqIFx0XHRcdFx0Ly8geW91IGNhbiBhbHNvIHNldCBkaWZmZXJlbnQgdGVtcGxhdGVzIGZvciBkaWZmZXJlbnQgY29sdW1ucyBiYXNlZCBvbiBpbmRleFxuICogXHRcdFx0fSkpO1xuICogXHRcdH0pO1xuICogXHRcdG5ld0RhdGEucHVzaChyb3cpO1xuICogXHR9KTtcbiAqIFx0cmV0dXJuIG5ld0RhdGE7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9Y29tcG9uZW50cy10YWJsZS0tYmFzaWM8L2V4YW1wbGUtdXJsPlxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiaWJtLXRhYmxlXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDx0YWJsZVxuXHRcdGlibVRhYmxlXG5cdFx0W3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcblx0XHRbbm9Cb3JkZXJdPVwibm9Cb3JkZXJcIlxuXHRcdFtuZ0NsYXNzXT1cInsnYngtLWRhdGEtdGFibGUtLXN0aWNreS1oZWFkZXInOiBzdGlja3lIZWFkZXJ9XCJcblx0XHRbc2l6ZV09XCJzaXplXCJcblx0XHRbc3RyaXBlZF09XCJzdHJpcGVkXCJcblx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0W2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJhcmlhRGVzY3JpYmVkYnlcIj5cblx0XHQ8dGhlYWRcblx0XHRcdGlibVRhYmxlSGVhZFxuXHRcdFx0W3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcblx0XHRcdChkZXNlbGVjdEFsbCk9XCJvbkRlc2VsZWN0QWxsKClcIlxuXHRcdFx0KHNlbGVjdEFsbCk9XCJvblNlbGVjdEFsbCgpXCJcblx0XHRcdChzb3J0KT1cImRvU29ydCgkZXZlbnQpXCJcblx0XHRcdFtjaGVja2JveEhlYWRlckxhYmVsXT1cImdldENoZWNrYm94SGVhZGVyTGFiZWwoKVwiXG5cdFx0XHRbZmlsdGVyVGl0bGVdPVwiZ2V0RmlsdGVyVGl0bGUoKVwiXG5cdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRbc2VsZWN0QWxsQ2hlY2tib3hdPVwic2VsZWN0QWxsQ2hlY2tib3hcIlxuXHRcdFx0W3NlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkXT1cInNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkXCJcblx0XHRcdFtzaG93U2VsZWN0aW9uQ29sdW1uXT1cInNob3dTZWxlY3Rpb25Db2x1bW5cIlxuXHRcdFx0W2VuYWJsZVNpbmdsZVNlbGVjdF09XCJlbmFibGVTaW5nbGVTZWxlY3RcIlxuXHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFtzb3J0QXNjZW5kaW5nTGFiZWxdPVwic29ydEFzY2VuZGluZ0xhYmVsXCJcblx0XHRcdFtzb3J0RGVzY2VuZGluZ0xhYmVsXT1cInNvcnREZXNjZW5kaW5nTGFiZWxcIlxuXHRcdFx0W3N0aWNreUhlYWRlcl09XCJzdGlja3lIZWFkZXJcIj5cblx0XHQ8L3RoZWFkPlxuXHRcdDx0Ym9keVxuXHRcdFx0aWJtVGFibGVCb2R5XG5cdFx0XHQoZGVzZWxlY3RSb3cpPVwib25TZWxlY3RSb3coJGV2ZW50KVwiXG5cdFx0XHQoc2Nyb2xsKT1cIm9uU2Nyb2xsKCRldmVudClcIlxuXHRcdFx0KHNlbGVjdFJvdyk9XCJvblNlbGVjdFJvdygkZXZlbnQpXCJcblx0XHRcdFtjaGVja2JveFJvd0xhYmVsXT1cImdldENoZWNrYm94Um93TGFiZWwoKVwiXG5cdFx0XHRbZW5hYmxlU2luZ2xlU2VsZWN0XT1cImVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHQocm93Q2xpY2spPVwib25Sb3dDbGljaygkZXZlbnQpXCJcblx0XHRcdFtleHBhbmRCdXR0b25BcmlhTGFiZWxdPVwiZXhwYW5kQnV0dG9uQXJpYUxhYmVsXCJcblx0XHRcdFttb2RlbF09XCJtb2RlbFwiXG5cdFx0XHRbc2l6ZV09XCJzaXplXCJcblx0XHRcdFtuZ1N0eWxlXT1cInsnb3ZlcmZsb3cteSc6ICdzY3JvbGwnfVwiXG5cdFx0XHRbc2VsZWN0aW9uTGFiZWxDb2x1bW5dPVwic2VsZWN0aW9uTGFiZWxDb2x1bW5cIlxuXHRcdFx0W3Nob3dTZWxlY3Rpb25Db2x1bW5dPVwic2hvd1NlbGVjdGlvbkNvbHVtblwiXG5cdFx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFx0Km5nSWY9XCIhbm9EYXRhOyBlbHNlIG5vRGF0YVRlbXBsYXRlXCI+XG5cdFx0PC90Ym9keT5cblx0XHQ8bmctdGVtcGxhdGUgI25vRGF0YVRlbXBsYXRlPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L25nLXRlbXBsYXRlPlxuXHRcdDx0Zm9vdD5cblx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldF09XCJmb290ZXJUZW1wbGF0ZVwiPlxuXHRcdFx0PC9uZy10ZW1wbGF0ZT5cblx0XHRcdDx0ciAqbmdJZj1cInRoaXMubW9kZWwuaXNMb2FkaW5nXCI+XG5cdFx0XHRcdDx0ZCBjbGFzcz1cInRhYmxlX2xvYWRpbmctaW5kaWNhdG9yXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1sb2FkaW5nIGJ4LS1sb2FkaW5nLS1zbWFsbFwiPlxuXHRcdFx0XHRcdFx0PHN2ZyBjbGFzcz1cImJ4LS1sb2FkaW5nX19zdmdcIiB2aWV3Qm94PVwiLTc1IC03NSAxNTAgMTUwXCI+XG5cdFx0XHRcdFx0XHRcdDxjaXJjbGUgY2xhc3M9XCJieC0tbG9hZGluZ19fc3Ryb2tlXCIgY3g9XCIwXCIgY3k9XCIwXCIgcj1cIjM3LjVcIiAvPlxuXHRcdFx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvdGQ+XG5cdFx0XHQ8L3RyPlxuXHRcdFx0PHRyICpuZ0lmPVwidGhpcy5tb2RlbC5pc0VuZFwiPlxuXHRcdFx0XHQ8dGQgY2xhc3M9XCJ0YWJsZV9lbmQtaW5kaWNhdG9yXCI+XG5cdFx0XHRcdFx0PGg1Pnt7Z2V0RW5kT2ZEYXRhVGV4dCgpIHwgYXN5bmN9fTwvaDU+XG5cdFx0XHRcdFx0PGJ1dHRvbiAoY2xpY2spPVwic2Nyb2xsVG9Ub3AoJGV2ZW50KVwiIGNsYXNzPVwiYnRuLS1zZWNvbmRhcnktc21cIj5cblx0XHRcdFx0XHRcdHt7Z2V0U2Nyb2xsVG9wVGV4dCgpIHwgYXN5bmN9fVxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0PC90cj5cblx0XHQ8L3Rmb290PlxuXHQ8L3RhYmxlPlxuXHRgLFxuXHRzdHlsZXM6IFtgXG5cdFx0Omhvc3Qge1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0fVxuXHRgXVxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc2tlbGV0b24gbW9kZWwgd2l0aCBhIHJvdyBhbmQgY29sdW1uIGNvdW50IHNwZWNpZmllZCBieSB0aGUgdXNlclxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBgYGB0eXBlc2NyaXB0XG5cdCAqIHRoaXMubW9kZWwgPSBUYWJsZS5za2VsZXRvbk1vZGVsKDUsIDUpO1xuXHQgKiBgYGBcblx0ICovXG5cdHN0YXRpYyBza2VsZXRvbk1vZGVsKHJvd0NvdW50OiBudW1iZXIsIGNvbHVtbkNvdW50OiBudW1iZXIpIHtcblx0XHRjb25zdCBtb2RlbCA9IG5ldyBUYWJsZU1vZGVsKCk7XG5cdFx0bGV0IGhlYWRlciA9IG5ldyBBcnJheTxUYWJsZUhlYWRlckl0ZW0+KCk7XG5cdFx0bGV0IGRhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRsZXQgcm93ID0gbmV3IEFycmF5PFRhYmxlSXRlbT4oKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuXHRcdFx0aGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdHJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oKSk7XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQgLSAxOyBpKyspIHtcblx0XHRcdGRhdGEucHVzaChyb3cpO1xuXHRcdH1cblxuXHRcdG1vZGVsLmhlYWRlciA9IGhlYWRlcjtcblx0XHRtb2RlbC5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gbW9kZWw7XG5cdH1cblxuXHRzdGF0aWMgc2V0VGFiSW5kZXgoZWxlbWVudDogSFRNTEVsZW1lbnQsIGluZGV4OiAtMSB8IDApIHtcblx0XHRjb25zdCBmb2N1c0VsZW1lbnRMaXN0ID0gZ2V0Rm9jdXNFbGVtZW50TGlzdChlbGVtZW50LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXgpO1xuXHRcdGlmIChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkICYmIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYngtLXRhYmxlLXNvcnRcIikgJiYgZm9jdXNFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb2N1c0VsZW1lbnRMaXN0WzBdLnRhYkluZGV4ID0gaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQudGFiSW5kZXggPSBpbmRleDtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgZm9jdXMoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcblx0XHRjb25zdCBmb2N1c0VsZW1lbnRMaXN0ID0gZ2V0Rm9jdXNFbGVtZW50TGlzdChlbGVtZW50LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXgpO1xuXHRcdGlmIChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkICYmIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYngtLXRhYmxlLXNvcnRcIikgJiYgZm9jdXNFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb2N1c0VsZW1lbnRMaXN0WzBdLmZvY3VzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQuZm9jdXMoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSWQgb2YgdGhlIHRhYmxlIGhlYWRlciB0aXRsZSBlbGVtZW50XG5cdCAqL1xuXHRASW5wdXQoKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nO1xuXHQvKipcblx0ICogSWQgb2YgdGhlIHRhYmxlIGhlYWRlciBkZXNjcmlwdGlvbiBlbGVtZW50XG5cdCAqL1xuXHRASW5wdXQoKSBhcmlhRGVzY3JpYmVkYnk6IHN0cmluZztcblxuXHQvKipcblx0ICogYFRhYmxlTW9kZWxgIHdpdGggZGF0YSB0aGUgdGFibGUgaXMgdG8gZGlzcGxheS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBtb2RlbChtOiBUYWJsZU1vZGVsKSB7XG5cdFx0aWYgKHRoaXMuX21vZGVsKSB7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcblx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBoZXJlIGJlY2F1c2UgdW5zdWJzY3JpYmluZyBwcmV2ZW50cyBhbnkgbmV3IHN1YnNjcmlwdGlvbnNcblx0XHRcdC8vIGZyb20gYmVpbmcgYWRkZWQgZm9yIHNvbWUgcmVhc29uLiBXaGVuIGEgbmV3IG1vZGVsIGlzIHNldCwgbm9uZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyB3b3VsZCBleGlzdC5cblx0XHRcdHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb2RlbCA9IG07XG5cblx0XHRjb25zdCByb3dzQ2hhbmdlID0gdGhpcy5fbW9kZWwucm93c1NlbGVjdGVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZVNlbGVjdEFsbENoZWNrYm94KCkpO1xuXHRcdGNvbnN0IGRhdGFDaGFuZ2UgPSB0aGlzLl9tb2RlbC5kYXRhQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc0RhdGFHcmlkKSB7XG5cdFx0XHRcdHRoaXMucmVzZXRUYWJJbmRleCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVTZWxlY3RBbGxDaGVja2JveCgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLmFkZChyb3dzQ2hhbmdlKTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGRhdGFDaGFuZ2UpO1xuXG5cdFx0aWYgKHRoaXMuaXNEYXRhR3JpZCkge1xuXHRcdFx0Y29uc3QgZXhwYW5kZWRDaGFuZ2UgPSB0aGlzLl9tb2RlbC5yb3dzRXhwYW5kZWRDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcblx0XHRcdFx0Ly8gQWxsb3dzIHRoZSBleHBhbmRlZCByb3cgdG8gaGF2ZSBhIGZvY3VzIHN0YXRlIHdoZW4gaXQgZXhpc3RzIGluIHRoZSBET01cblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZXhwYW5kZWRSb3dzID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ieC0tZXhwYW5kYWJsZS1yb3c6bm90KC5ieC0tcGFyZW50LXJvdylcIik7XG5cdFx0XHRcdFx0QXJyYXkuZnJvbTxhbnk+KGV4cGFuZGVkUm93cykuZm9yRWFjaChyb3cgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0cm93LmZpcnN0RWxlbWVudENoaWxkLnRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGV4cGFuZGVkQ2hhbmdlKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgbW9kZWwoKTogVGFibGVNb2RlbCB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGVsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpemUgb2YgdGhlIHRhYmxlIHJvd3MuXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBUYWJsZVJvd1NpemUgPSBcIm1kXCI7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgdGFibGUuXG5cdCAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkYXRhIGdyaWQgd2l0aCBrZXlib2FyZCBpbnRlcmFjdGlvbnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgaXNEYXRhR3JpZCh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuX2lzRGF0YUdyaWQgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy5pc1ZpZXdSZWFkeSkge1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuZW5hYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlzYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgc29ydGFibGUgdG8gZmFsc2Ugd2lsbCBkaXNhYmxlIGFsbCBoZWFkZXJzIGluY2x1ZGluZyBoZWFkZXJzIHdoaWNoIGFyZSBzb3J0YWJsZS4gSXMgaXNcblx0ICogcG9zc2libGUgdG8gc2V0IHRoZSBzb3J0YWJsZSBzdGF0ZSBvbiB0aGUgaGVhZGVyIGl0ZW0gdG8gZGlzYWJsZS9lbmFibGUgc29ydGluZyBmb3Igb25seSBzb21lIGhlYWRlcnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzb3J0YWJsZSA9IHRydWU7XG5cblx0QElucHV0KCkgbm9Cb3JkZXIgPSB0cnVlO1xuXG5cdGdldCBpc0RhdGFHcmlkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pc0RhdGFHcmlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIHdoZXRoZXIgdG8gc2hvdyB0aGUgc2VsZWN0aW9uIGNoZWNrYm94ZXMgY29sdW1uIG9yIG5vdC5cblx0ICovXG5cdEBJbnB1dCgpIHNob3dTZWxlY3Rpb25Db2x1bW4gPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBDb250cm9scyB3aGV0aGVyIHRvIGVuYWJsZSBtdWx0aXBsZSBvciBzaW5nbGUgcm93IHNlbGVjdGlvbi5cblx0ICovXG5cdEBJbnB1dCgpIGVuYWJsZVNpbmdsZVNlbGVjdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSAoaW4gcHgpIGZyb20gdGhlIGJvdHRvbSB0aGF0IHZpZXcgaGFzIHRvIHJlYWNoIGJlZm9yZVxuXHQgKiBgc2Nyb2xsTG9hZGAgZXZlbnQgaXMgZW1pdHRlZC5cblx0ICovXG5cdEBJbnB1dCgpIHNjcm9sbExvYWREaXN0YW5jZSA9IDA7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIHVzZXJzIHRvIHJlc2l6ZSBjb2x1bW5zLlxuXHQgKlxuXHQgKiBXb3JrcyBmb3IgY29sdW1ucyB3aXRoIHdpZHRoIHNldCBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqL1xuXHRASW5wdXQoKSBjb2x1bW5zUmVzaXphYmxlID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIHVzZXJzIHRvIGRyYWcgYW5kIGRyb3AgY29sdW1ucy5cblx0ICpcblx0ICogQ2hhbmdpbmcgdGhlIGNvbHVtbiBvcmRlciBpbiB0YWJsZSBjaGFuZ2VzIHRhYmxlIG1vZGVsLiBCZSBhd2FyZSBvZiBpdCB3aGVuIHlvdSBhZGQgYWRkaXRpb25hbCBkYXRhXG5cdCAqIHRvIHRoZSBtb2RlbC5cblx0ICpcblx0ICovXG5cdEBJbnB1dCgpIGNvbHVtbnNEcmFnZ2FibGUgPSBmYWxzZTtcblxuXHRASW5wdXQoKVxuXHRzZXQgZXhwYW5kQnV0dG9uQXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cdGdldCBleHBhbmRCdXR0b25BcmlhTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbC52YWx1ZTtcblx0fVxuXHRASW5wdXQoKVxuXHRzZXQgc29ydERlc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblx0Z2V0IHNvcnREZXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblx0QElucHV0KClcblx0c2V0IHNvcnRBc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXHRnZXQgc29ydEFzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogRXhwZWN0cyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBzb21lIG9yIGFsbCBvZjpcblx0ICogYGBgXG5cdCAqIHtcblx0ICpcdFx0XCJGSUxURVJcIjogXCJGaWx0ZXJcIixcblx0ICpcdFx0XCJFTkRfT0ZfREFUQVwiOiBcIllvdSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgeW91ciBjb250ZW50XCIsXG5cdCAqXHRcdFwiU0NST0xMX1RPUFwiOiBcIlNjcm9sbCB0byB0b3BcIixcblx0ICpcdFx0XCJDSEVDS0JPWF9IRUFERVJcIjogXCJTZWxlY3QgYWxsIHJvd3NcIixcblx0ICpcdFx0XCJDSEVDS0JPWF9ST1dcIjogXCJTZWxlY3Qgcm93XCJcblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCB0cmFuc2xhdGlvbnMgKHZhbHVlKSB7XG5cdFx0Y29uc3QgdmFsdWVXaXRoRGVmYXVsdHMgPSBtZXJnZSh0aGlzLmkxOG4uZ2V0TXVsdGlwbGUoXCJUQUJMRVwiKSwgdmFsdWUpO1xuXHRcdHRoaXMuX2ZpbHRlclRpdGxlLm92ZXJyaWRlKHZhbHVlV2l0aERlZmF1bHRzLkZJTFRFUik7XG5cdFx0dGhpcy5fZW5kT2ZEYXRhVGV4dC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5FTkRfT0ZfREFUQSk7XG5cdFx0dGhpcy5fc2Nyb2xsVG9wVGV4dC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5TQ1JPTExfVE9QKTtcblx0XHR0aGlzLl9jaGVja2JveEhlYWRlckxhYmVsLm92ZXJyaWRlKHZhbHVlV2l0aERlZmF1bHRzLkNIRUNLQk9YX0hFQURFUik7XG5cdFx0dGhpcy5fY2hlY2tib3hSb3dMYWJlbC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5DSEVDS0JPWF9ST1cpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0byBgZmFsc2VgIHRvIHJlbW92ZSB0YWJsZSByb3dzICh6ZWJyYSkgc3RyaXBlcy5cblx0ICovXG5cdEBJbnB1dCgpIHN0cmlwZWQgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBBbGxvd3MgdGFibGUgY29udGVudCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5XG5cdCAqL1xuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5ieC0tZGF0YS10YWJsZS1jb250ZW50XCIpIHRhYmxlQ29udGVudCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gc3RpY2sgdGhlIGhlYWRlciB0byB0aGUgdG9wIG9mIHRoZSB0YWJsZVxuXHQgKi9cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuYngtLWRhdGEtdGFibGVfaW5uZXItY29udGFpbmVyXCIpIEBJbnB1dCgpIHN0aWNreUhlYWRlciA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTZXQgZm9vdGVyIHRlbXBsYXRlIHRvIGN1c3RvbWl6ZSB3aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgdGZvb3Qgc2VjdGlvbiBvZiB0aGUgdGFibGVcblx0ICovXG5cdEBJbnB1dCgpIGZvb3RlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHBvcHVsYXRlIHRoZSByb3cgc2VsZWN0aW9uIGNoZWNrYm94IGxhYmVsIHdpdGggYSB1c2VmdWwgdmFsdWUgaWYgc2V0LlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKiBgYGBcblx0ICogPGlibS10YWJsZSBbc2VsZWN0aW9uTGFiZWxDb2x1bW5dPVwiMFwiPjwvaWJtLXRhYmxlPlxuXHQgKiA8IS0tIHJlc3VsdHMgaW4gYXJpYS1sYWJlbD1cIlNlbGVjdCBmaXJzdCBjb2x1bW4gdmFsdWVcIlxuXHQgKiAod2hlcmUgXCJmaXJzdCBjb2x1bW4gdmFsdWVcIiBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNvbHVtbiBpbiB0aGUgcm93IC0tPlxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpIHNlbGVjdGlvbkxhYmVsQ29sdW1uOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3YW50cyB0byBiZSBzb3J0ZWQuXG5cdCAqXG5cdCAqIElmIG5vIG9ic2VydmVycyBhcmUgcHJvdmlkZWQgKGRlZmF1bHQpLCB0YWJsZSB3aWxsIGF0dGVtcHQgdG8gZG8gYSBzaW1wbGUgc29ydCBvZiB0aGUgZGF0YSBsb2FkZWRcblx0ICogaW50byB0aGUgbW9kZWwuXG5cdCAqXG5cdCAqIElmIGFuIG9ic2VydmVyIGlzIHByb3ZpZGVkLCB0YWJsZSB3aWxsIG5vdCBhdHRlbXB0IGFueSBzb3J0aW5nIG9mIGl0cyBvd24gYW5kIGl0IGlzIHVwIHRvIHRoZSBvYnNlcnZlclxuXHQgKiB0byBzb3J0IHRoZSB0YWJsZS4gVGhpcyBpcyB3aGF0IHlvdSB0eXBpY2FsbHkgd2FudCBpZiB5b3UncmUgdXNpbmcgYSBiYWNrZW5kIHF1ZXJ5IHRvIGdldCB0aGUgc29ydGVkXG5cdCAqIGRhdGEgb3Igd2FudCB0byBzb3J0IGRhdGEgYWNyb3NzIG11bHRpcGxlIHBhZ2VzLlxuXHQgKlxuXHQgKiBVc2FnZTpcblx0ICpcblx0ICogYGBgdHlwZXNjcmlwdFxuXHQgKiBAQ29tcG9uZW50KHtcblx0ICogXHRzZWxlY3RvcjogXCJhcHAtdGFibGVcIixcblx0ICogXHR0ZW1wbGF0ZTogYFxuXHQgKiBcdFx0PGlibS10YWJsZVxuXHQgKiBcdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHQgKiBcdFx0XHQoc29ydCk9XCJzaW1wbGVTb3J0KCRldmVudClcIj5cblx0ICogXHRcdFx0Tm8gZGF0YS5cblx0ICogXHRcdDwvaWJtLXRhYmxlPlxuXHQgKiBcdGBcblx0ICogfSlcblx0ICogZXhwb3J0IGNsYXNzIFRhYmxlQXBwIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuXHQgKiBcdEBJbnB1dCgpIG1vZGVsID0gbmV3IFRhYmxlTW9kZWwoKTtcblx0ICpcblx0ICogXHRuZ09uSW5pdCgpIHtcblx0ICogXHRcdHRoaXMubW9kZWwuaGVhZGVyID0gW1xuXHQgKiBcdFx0XHRuZXcgVGFibGVIZWFkZXJJdGVtKHsgZGF0YTogXCJOYW1lXCIgfSksXG5cdCAqIFx0XHRcdG5ldyBUYWJsZUhlYWRlckl0ZW0oeyBkYXRhOiBcImh3ZXJcIiB9KVxuXHQgKiBcdFx0XTtcblx0ICpcblx0ICogXHRcdHRoaXMubW9kZWwuZGF0YSA9IFtcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgMVwiIH0pLCBuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJxd2VyXCIgfSldLFxuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSAzXCIgfSksIG5ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcInp3ZXJcIiB9KV0sXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDJcIiB9KSwgbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwic3dlclwiIH0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNFwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNVwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNlwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXVxuXHQgKiBcdFx0XTtcblx0ICogXHR9XG5cdCAqXG5cdCAqIFx0c2ltcGxlU29ydChpbmRleDogbnVtYmVyKSB7XG5cdCAqIFx0XHQvLyB0aGlzIGZ1bmN0aW9uIGRvZXMgYSBzaW1wbGUgc29ydCwgd2hpY2ggaXMgdGhlIGRlZmF1bHQgZm9yIHRoZSB0YWJsZSBhbmQgaWYgdGhhdCdzXG5cdCAqIFx0XHQvLyBhbGwgeW91IHdhbnQsIHlvdSBkb24ndCBuZWVkIHRvIGRvIHRoaXMuXG5cdCAqXG5cdCAqIFx0XHQvLyBoZXJlIHlvdSBjYW4gcXVlcnkgeW91ciBiYWNrZW5kIGFuZCB1cGRhdGUgdGhlIG1vZGVsLmRhdGEgYmFzZWQgb24gdGhlIHJlc3VsdFxuXHQgKiBcdFx0aWYgKHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5zb3J0ZWQpIHtcblx0ICogXHRcdFx0Ly8gaWYgYWxyZWFkeSBzb3J0ZWQgZmxpcCBzb3J0aW5nIGRpcmVjdGlvblxuXHQgKiBcdFx0XHR0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uYXNjZW5kaW5nID0gdGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLmRlc2NlbmRpbmc7XG5cdCAqIFx0XHR9XG5cdCAqIFx0XHR0aGlzLm1vZGVsLnNvcnQoaW5kZXgpO1xuXHQgKiBcdH1cblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBPdXRwdXQoKSBzb3J0ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBkZXNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhIHNpbmdsZSByb3cgaXMgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSAoe21vZGVsOiB0aGlzLm1vZGVsLCBzZWxlY3RlZFJvd0luZGV4OiBpbmRleH0pXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0Um93ID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGEgc2luZ2xlIHJvdyBpcyBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gKHttb2RlbDogdGhpcy5tb2RlbCwgZGVzZWxlY3RlZFJvd0luZGV4OiBpbmRleH0pXG5cdCAqL1xuXHRAT3V0cHV0KCkgZGVzZWxlY3RSb3cgPSBuZXcgRXZlbnRFbWl0dGVyPE9iamVjdD4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYSByb3cgaXRlbSBleGNsdWRpbmcgZXhwYW5kQnV0dG9ucywgY2hlY2tib3hlcywgb3IgcmFkaW9zIGlzIGNsaWNrZWQuXG5cdCAqL1xuXHRAT3V0cHV0KCkgcm93Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgd2hlbiB0YWJsZSByZXF1aXJlcyBtb3JlIGRhdGEgdG8gYmUgbG9hZGVkLlxuXHQgKi9cblx0QE91dHB1dCgpIHNjcm9sbExvYWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhYmxlTW9kZWw+KCk7XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIGlmIGFsbCBjaGVja2JveGVzIGFyZSB2aWV3ZWQgYXMgc2VsZWN0ZWQuXG5cdCAqL1xuXHRzZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBDb250cm9scyB0aGUgaW5kZXRlcm1pbmF0ZSBzdGF0ZSBvZiB0aGUgaGVhZGVyIGNoZWNrYm94LlxuXHQgKi9cblx0c2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRnZXQgbm9EYXRhKCkge1xuXHRcdHJldHVybiAhdGhpcy5tb2RlbC5kYXRhIHx8XG5cdFx0XHR0aGlzLm1vZGVsLmRhdGEubGVuZ3RoID09PSAwIHx8XG5cdFx0XHR0aGlzLm1vZGVsLmRhdGEubGVuZ3RoID09PSAxICYmIHRoaXMubW9kZWwuZGF0YVswXS5sZW5ndGggPT09IDA7XG5cdH1cblxuXHRwdWJsaWMgaXNDb2x1bW5EcmFnZ2luZyA9IGZhbHNlO1xuXHRwdWJsaWMgY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSAtMTtcblx0cHVibGljIGNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IFwiXCI7XG5cblx0cHJvdGVjdGVkIF9tb2RlbDogVGFibGVNb2RlbDtcblx0cHJvdGVjdGVkIF9pc0RhdGFHcmlkID0gZmFsc2U7XG5cdC8vIGZsYWcgdG8gcHJldmVudCBnZXR0ZXJzL3NldHRlcnMgZnJvbSBxdWVyeWluZyB0aGUgdmlldyBiZWZvcmUgaXQncyBmdWxseSBpbnN0YW50aWF0ZWRcblx0cHJvdGVjdGVkIGlzVmlld1JlYWR5ID0gZmFsc2U7XG5cblx0cHJvdGVjdGVkIHN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cdHByb3RlY3RlZCBwb3NpdGlvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG5cdHByb3RlY3RlZCBpbnRlcmFjdGlvbk1vZGVsOiBEYXRhR3JpZEludGVyYWN0aW9uTW9kZWw7XG5cdHByb3RlY3RlZCBpbnRlcmFjdGlvblBvc2l0aW9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cblx0cHJvdGVjdGVkIF9leHBhbmRCdXR0b25BcmlhTGFiZWwgID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRVhQQU5EX0JVVFRPTlwiKTtcblx0cHJvdGVjdGVkIF9zb3J0RGVzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9ERVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnRBc2NlbmRpbmdMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNPUlRfQVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX2NoZWNrYm94SGVhZGVyTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5DSEVDS0JPWF9IRUFERVJcIik7XG5cdHByb3RlY3RlZCBfY2hlY2tib3hSb3dMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkNIRUNLQk9YX1JPV1wiKTtcblx0cHJvdGVjdGVkIF9lbmRPZkRhdGFUZXh0ID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRU5EX09GX0RBVEFcIik7XG5cdHByb3RlY3RlZCBfc2Nyb2xsVG9wVGV4dCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNDUk9MTF9UT1BcIik7XG5cdHByb3RlY3RlZCBfZmlsdGVyVGl0bGUgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5GSUxURVJcIik7XG5cblx0cHJvdGVjdGVkIGNvbHVtblJlc2l6ZVdpZHRoOiBudW1iZXI7XG5cdHByb3RlY3RlZCBjb2x1bW5SZXNpemVNb3VzZVg6IG51bWJlcjtcblx0cHJvdGVjdGVkIG1vdXNlTW92ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXHRwcm90ZWN0ZWQgbW91c2VVcFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRhYmxlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG5cdFx0cHJvdGVjdGVkIGFwcGxpY2F0aW9uUmVmOiBBcHBsaWNhdGlvblJlZixcblx0XHRwcm90ZWN0ZWQgaTE4bjogSTE4blxuXHQpIHt9XG5cblx0bmdBZnRlclZpZXdJbml0KCkge1xuXHRcdHRoaXMuaXNWaWV3UmVhZHkgPSB0cnVlO1xuXHRcdGlmICh0aGlzLmlzRGF0YUdyaWQpIHtcblx0XHRcdHRoaXMuZW5hYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKTtcblx0XHR9XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpIHtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcblx0XHRpZiAodGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuXHRcdFx0dGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0fVxuXG5cdGVuYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCkge1xuXHRcdC8vIGlmIHdlIGhhdmUgYW4gYGludGVyYWN0aW9Nb2RlbGAgd2UndmUgYWxyZWFkeSBlbmFibGVkIGRhdGFncmlkXG5cdFx0aWYgKHRoaXMuaW50ZXJhY3Rpb25Nb2RlbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCB0YWJsZSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0YWJsZVwiKSBhcyBIVE1MVGFibGVFbGVtZW50O1xuXHRcdGNvbnN0IHRhYmxlQWRhcHRlciA9IG5ldyBUYWJsZURvbUFkYXB0ZXIodGFibGUpO1xuXHRcdGNvbnN0IGtleWRvd25FdmVudFN0cmVhbSA9IGZyb21FdmVudDxLZXlib2FyZEV2ZW50Pih0YWJsZSwgXCJrZXlkb3duXCIpO1xuXHRcdGNvbnN0IGNsaWNrRXZlbnRTdHJlYW0gPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGFibGUsIFwiY2xpY2tcIik7XG5cdFx0dGhpcy5pbnRlcmFjdGlvbk1vZGVsID0gbmV3IERhdGFHcmlkSW50ZXJhY3Rpb25Nb2RlbChrZXlkb3duRXZlbnRTdHJlYW0sIGNsaWNrRXZlbnRTdHJlYW0sIHRhYmxlQWRhcHRlcik7XG5cdFx0dGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMuaW50ZXJhY3Rpb25Nb2RlbC5wb3NpdGlvbi5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuXHRcdFx0Y29uc3QgW2N1cnJlbnRSb3csIGN1cnJlbnRDb2x1bW5dID0gZXZlbnQuY3VycmVudDtcblx0XHRcdGNvbnN0IFtwcmV2aW91c1JvdywgcHJldmlvdXNDb2x1bW5dID0gZXZlbnQucHJldmlvdXM7XG5cblx0XHRcdGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gdGFibGVBZGFwdGVyLmdldENlbGwoY3VycmVudFJvdywgY3VycmVudENvbHVtbik7XG5cdFx0XHRUYWJsZS5zZXRUYWJJbmRleChjdXJyZW50RWxlbWVudCwgMCk7XG5cblx0XHRcdC8vIGlmIHRoZSBtb2RlbCBoYXMganVzdCBpbml0aWFsaXplZCBkb24ndCBmb2N1cyBvciByZXNldCBhbnl0aGluZ1xuXHRcdFx0aWYgKHByZXZpb3VzUm93ID09PSAtMSB8fCBwcmV2aW91c0NvbHVtbiA9PT0gLTEpIHsgcmV0dXJuOyB9XG5cdFx0XHQvLyBNYWtlIHRoZSBwcmV2aW91cyBjZWxsIHVuZm9jdXNhYmxlIChpZiBpdCdzIG5vdCB0aGUgY3VycmVudClcblx0XHRcdGlmIChwcmV2aW91c1JvdyAhPT0gY3VycmVudFJvdyB8fCBwcmV2aW91c0NvbHVtbiAhPT0gY3VycmVudENvbHVtbikge1xuXHRcdFx0XHRjb25zdCBwcmV2aW91c0VsZW1lbnQgPSB0YWJsZUFkYXB0ZXIuZ2V0Q2VsbChwcmV2aW91c1JvdywgcHJldmlvdXNDb2x1bW4pO1xuXHRcdFx0XHRUYWJsZS5zZXRUYWJJbmRleChwcmV2aW91c0VsZW1lbnQsIC0xKTtcblx0XHRcdH1cblx0XHRcdFRhYmxlLmZvY3VzKGN1cnJlbnRFbGVtZW50KTtcblx0XHR9KTtcblx0XHQvLyBjYWxsIHRoaXMgYWZ0ZXIgYXNzaWduaW5nIGB0aGlzLmludGVyYWN0aW9uTW9kZWxgIHNpbmNlIGl0IGRlcGVuZHMgb24gaXRcblx0XHR0aGlzLnJlc2V0VGFiSW5kZXgoKTtcblx0fVxuXG5cdGRpc2FibGVEYXRhR3JpZEludGVyYWN0aW9ucygpIHtcblx0XHQvLyB1bnN1YnNjcmliZSBmaXJzdCBzbyB3ZSBkb24ndCBjYXVzZSB0aGUgZm9jdXMgdG8gZmx5IGFyb3VuZFxuXHRcdGlmICh0aGlzLnBvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHRcdC8vIHVuZG8gdGFiIGluZGV4aW5nIChhbHNvIHJlc2V0cyB0aGUgbW9kZWwpXG5cdFx0dGhpcy5yZXNldFRhYkluZGV4KDApO1xuXHRcdC8vIG51bGwgb3V0IHRoZSBtb2RlbCByZWZcblx0XHR0aGlzLmludGVyYWN0aW9uTW9kZWwgPSBudWxsO1xuXHR9XG5cblx0b25TZWxlY3RBbGwoKSB7XG5cdFx0dGhpcy5tb2RlbC5zZWxlY3RBbGwodHJ1ZSk7XG5cdFx0dGhpcy5zZWxlY3RBbGwuZW1pdCh0aGlzLm1vZGVsKTtcblx0fVxuXG5cdG9uRGVzZWxlY3RBbGwoKSB7XG5cdFx0dGhpcy5tb2RlbC5zZWxlY3RBbGwoZmFsc2UpO1xuXHRcdHRoaXMuZGVzZWxlY3RBbGwuZW1pdCh0aGlzLm1vZGVsKTtcblx0fVxuXG5cdG9uU2VsZWN0Um93KGV2ZW50KSB7XG5cdFx0Ly8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlIHNlbGVjdGVkUm93SW5kZXggcHJvcGVydHlcblx0XHRpZiAoT2JqZWN0LmtleXMoZXZlbnQpLmluY2x1ZGVzKFwic2VsZWN0ZWRSb3dJbmRleFwiKSkge1xuXHRcdFx0aWYgKHRoaXMuZW5hYmxlU2luZ2xlU2VsZWN0KSB7XG5cdFx0XHRcdHRoaXMubW9kZWwuc2VsZWN0QWxsKGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubW9kZWwuc2VsZWN0Um93KGV2ZW50LnNlbGVjdGVkUm93SW5kZXgsIHRydWUpO1xuXHRcdFx0dGhpcy5zZWxlY3RSb3cuZW1pdChldmVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubW9kZWwuc2VsZWN0Um93KGV2ZW50LmRlc2VsZWN0ZWRSb3dJbmRleCwgZmFsc2UpO1xuXHRcdFx0dGhpcy5kZXNlbGVjdFJvdy5lbWl0KGV2ZW50KTtcblx0XHR9XG5cdH1cblxuXHRvblJvd0NsaWNrKGluZGV4OiBudW1iZXIpIHtcblx0XHR0aGlzLnJvd0NsaWNrLmVtaXQoaW5kZXgpO1xuXHR9XG5cblx0dXBkYXRlU2VsZWN0QWxsQ2hlY2tib3goKSB7XG5cdFx0Y29uc3Qgc2VsZWN0ZWRSb3dzQ291bnQgPSB0aGlzLm1vZGVsLnNlbGVjdGVkUm93c0NvdW50KCk7XG5cblx0XHRpZiAoc2VsZWN0ZWRSb3dzQ291bnQgPD0gMCkge1xuXHRcdFx0Ly8gcmVzZXQgc2VsZWN0IGFsbCBjaGVja2JveCBpZiBub3RoaW5nIHNlbGVjdGVkXG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94ID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZFJvd3NDb3VudCA8IHRoaXMubW9kZWwuZGF0YS5sZW5ndGgpIHtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3ggPSB0cnVlO1xuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3ggPSB0cnVlO1xuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJlc2V0VGFiSW5kZXgobmV3VGFiSW5kZXggPSAtMSkge1xuXHRcdC8vIGVuc3VyZSB0aGUgdmlldyBpcyByZWFkeSBmb3IgdGhlIHJlc2V0IGJlZm9yZSB3ZSBwcmVmb3JtIHRoZSBhY3R1YWwgcmVzZXRcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdC8vIHJlc2V0IGFsbCB0aGUgdGFiSW5kZXhlcyB3ZSBjYW4gZmluZFxuXHRcdFx0Y29uc3QgZm9jdXNFbGVtZW50TGlzdCA9IGdldEZvY3VzRWxlbWVudExpc3QodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRhYmJhYmxlU2VsZWN0b3JJZ25vcmVUYWJJbmRleCk7XG5cdFx0XHRpZiAoZm9jdXNFbGVtZW50TGlzdCkge1xuXHRcdFx0XHRmb2N1c0VsZW1lbnRMaXN0LmZvckVhY2godGFiYmFibGUgPT4ge1xuXHRcdFx0XHRcdHRhYmJhYmxlLnRhYkluZGV4ID0gbmV3VGFiSW5kZXg7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVzZXQgaW50ZXJhY3Rpb24gbW9kZWwgcG9zaXRpb25zIGFuZCB0YWJJbmRleGVzXG5cdFx0XHRpZiAodGhpcy5pbnRlcmFjdGlvbk1vZGVsKSB7XG5cdFx0XHRcdHRoaXMuaW50ZXJhY3Rpb25Nb2RlbC5yZXNldFRhYkluZGV4ZXMobmV3VGFiSW5kZXgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Y29sdW1uUmVzaXplU3RhcnQoZXZlbnQsIGNvbHVtbikge1xuXHRcdHRoaXMuY29sdW1uUmVzaXplV2lkdGggPSBwYXJzZUludChjb2x1bW4uc3R5bGUud2lkdGgsIDEwKTtcblx0XHR0aGlzLmNvbHVtblJlc2l6ZU1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHRoaXMubW91c2VNb3ZlU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KGRvY3VtZW50LmJvZHksIFwibW91c2Vtb3ZlXCIpLnN1YnNjcmliZShldmVudCA9PiB7XG5cdFx0XHR0aGlzLmNvbHVtblJlc2l6ZVByb2dyZXNzKGV2ZW50LCBjb2x1bW4pO1xuXHRcdH0pO1xuXHRcdHRoaXMubW91c2VVcFN1YnNjcmlwdGlvbiA9IGZyb21FdmVudChkb2N1bWVudC5ib2R5LCBcIm1vdXNldXBcIikuc3Vic2NyaWJlKGV2ZW50ID0+IHtcblx0XHRcdHRoaXMuY29sdW1uUmVzaXplRW5kKGV2ZW50LCBjb2x1bW4pO1xuXHRcdH0pO1xuXHR9XG5cblx0Y29sdW1uUmVzaXplUHJvZ3Jlc3MoZXZlbnQsIGNvbHVtbikge1xuXHRcdGNvbnN0IG1vdmUgPSBldmVudC5jbGllbnRYIC0gdGhpcy5jb2x1bW5SZXNpemVNb3VzZVg7XG5cdFx0Y29sdW1uLnN0eWxlLndpZHRoID0gYCR7dGhpcy5jb2x1bW5SZXNpemVXaWR0aCArIG1vdmV9cHhgO1xuXHR9XG5cblx0Y29sdW1uUmVzaXplRW5kKGV2ZW50LCBjb2x1bW4pIHtcblx0XHR0aGlzLm1vdXNlTW92ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHRcdHRoaXMubW91c2VVcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgb24gdGhlIGA8dGJvZHk+YCBlbGVtZW50LlxuXHQgKiBFbWl0cyB0aGUgYHNjcm9sbExvYWRgIGV2ZW50LlxuXHQgKi9cblx0b25TY3JvbGwoZXZlbnQpIHtcblx0XHRjb25zdCBkaXN0YW5jZUZyb21Cb3R0b20gPSBldmVudC50YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gZXZlbnQudGFyZ2V0LmNsaWVudEhlaWdodCAtIGV2ZW50LnRhcmdldC5zY3JvbGxUb3A7XG5cblx0XHRpZiAoZGlzdGFuY2VGcm9tQm90dG9tIDw9IHRoaXMuc2Nyb2xsTG9hZERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLnNjcm9sbExvYWQuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tb2RlbC5pc0VuZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGNvbHVtbkRyYWdTdGFydChldmVudCwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmlzQ29sdW1uRHJhZ2dpbmcgPSB0cnVlO1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSBjb2x1bW5JbmRleDtcblx0XHRldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcImNvbHVtbkluZGV4XCIsIEpTT04uc3RyaW5naWZ5KGNvbHVtbkluZGV4KSk7XG5cdH1cblxuXHRjb2x1bW5EcmFnRW5kKGV2ZW50LCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuaXNDb2x1bW5EcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSAtMTtcblx0fVxuXG5cdGNvbHVtbkRyYWdFbnRlcihldmVudCwgcG9zaXRpb24sIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gY29sdW1uSW5kZXg7XG5cdH1cblxuXHRjb2x1bW5EcmFnTGVhdmUoZXZlbnQsIHBvc2l0aW9uLCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gXCJcIjtcblx0fVxuXG5cdGNvbHVtbkRyYWdvdmVyKGV2ZW50LCBwb3NpdGlvbiwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gY29sdW1uSW5kZXg7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkUG9zaXRpb24gPSBwb3NpdGlvbjtcblxuXHRcdC8vIG5lZWRlZCB0byB0ZWxsIGJyb3dzZXIgdG8gYWxsb3cgZHJvcHBpbmdcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblx0Y29sdW1uRHJvcChldmVudCwgcG9zaXRpb24sIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5pc0NvbHVtbkRyYWdnaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IC0xO1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gXCJcIjtcblxuXHRcdHRoaXMubW9kZWwubW92ZUNvbHVtbihcblx0XHRcdHBhcnNlSW50KGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiY29sdW1uSW5kZXhcIiksIDEwKSxcblx0XHRcdGNvbHVtbkluZGV4ICsgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgPyAxIDogMClcblx0XHQpO1xuXHR9XG5cblx0ZG9Tb3J0KGluZGV4OiBudW1iZXIpIHtcblx0XHRpZiAodGhpcy5zb3J0Lm9ic2VydmVycy5sZW5ndGggPT09IDApIHtcblx0XHRcdC8vIG5vIHNvcnQgcHJvdmlkZWQgc28gZG8gdGhlIHNpbXBsZSBzb3J0XG5cdFx0XHRpZiAodGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLnNvcnRlZCkge1xuXHRcdFx0XHQvLyBpZiBhbHJlYWR5IHNvcnRlZCBmbGlwIHNvcnRpbmcgZGlyZWN0aW9uXG5cdFx0XHRcdHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5hc2NlbmRpbmcgPSB0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uZGVzY2VuZGluZztcblx0XHRcdH1cblx0XHRcdHRoaXMubW9kZWwuc29ydChpbmRleCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zb3J0LmVtaXQoaW5kZXgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgb24gdGhlIGA8dGJvZHk+YCBlbGVtZW50LlxuXHQgKiBFbWl0cyB0aGUgYHNjcm9sbExvYWRgIGV2ZW50LlxuXHQgKi9cblx0c2Nyb2xsVG9Ub3AoZXZlbnQpIHtcblx0XHRldmVudC50YXJnZXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlblsxXS5zY3JvbGxUb3AgPSAwO1xuXHRcdHRoaXMubW9kZWwuaXNFbmQgPSBmYWxzZTtcblx0fVxuXG5cdGdldFNlbGVjdGlvbkxhYmVsVmFsdWUocm93OiBUYWJsZUl0ZW1bXSkge1xuXHRcdGlmICghdGhpcy5zZWxlY3Rpb25MYWJlbENvbHVtbikge1xuXHRcdFx0cmV0dXJuIHsgdmFsdWU6IHRoaXMuaTE4bi5nZXQoKS5UQUJMRS5ST1cgfTtcblx0XHR9XG5cdFx0cmV0dXJuIHsgdmFsdWU6IHJvd1t0aGlzLnNlbGVjdGlvbkxhYmVsQ29sdW1uXS5kYXRhIH07XG5cdH1cblxuXHRnZXRFeHBhbmRCdXR0b25BcmlhTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbC5zdWJqZWN0O1xuXHR9XG5cdGdldFNvcnREZXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwuc3ViamVjdDtcblx0fVxuXHRnZXRTb3J0QXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0Q2hlY2tib3hIZWFkZXJMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0Q2hlY2tib3hSb3dMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tib3hSb3dMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0RW5kT2ZEYXRhVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZW5kT2ZEYXRhVGV4dC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0U2Nyb2xsVG9wVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2Nyb2xsVG9wVGV4dC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0RmlsdGVyVGl0bGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZpbHRlclRpdGxlLnN1YmplY3Q7XG5cdH1cbn1cbiJdfQ==