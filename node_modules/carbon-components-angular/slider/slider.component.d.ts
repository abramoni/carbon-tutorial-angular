/**
 *
 * carbon-angular v0.0.0 | slider.component.d.ts
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { EventEmitter, AfterViewInit, ElementRef, TemplateRef, QueryList } from "@angular/core";
import { ControlValueAccessor } from "@angular/forms";
import { EventService } from "carbon-components-angular/utils";
/**
 * Used to select from ranges of values. [See here](https://www.carbondesignsystem.com/components/slider/usage) for usage information.
 *
 * [See demo](../../?path=/story/components-slider--advanced)
 *
 * The simplest possible slider usage looks something like:
 * ```html
 * <ibm-slider></ibm-slider>
 * ```
 *
 * That will render a slider without labels or alternative value input. Labels can be provided by
 * elements with `[minLabel]` and `[maxLabel]` attributes, and an `input` (may use the `ibmInput` directive) can be supplied
 * for use as an alternative value field.
 *
 * ex:
 * ```html
 * <!-- full example -->
 * <ibm-slider>
 *		<span minLabel>0GB</span>
 *		<span maxLabel>100GB</span>
 *		<input/>
 *	</ibm-slider>
 * <!-- with just an input -->
 * <ibm-slider>
 *		<input/>
 *	</ibm-slider>
 * <!-- with just one label -->
 * <ibm-slider>
 *		<span maxLabel>Maximum</span>
 *	</ibm-slider>
 * ```
 *
 * Slider supports `NgModel` by default, as well as two way binding to the `value` input.
 *
 * <example-url>../../iframe.html?id=components-slider--advanced</example-url>
 */
import * as ɵngcc0 from '@angular/core';
export declare class Slider implements AfterViewInit, ControlValueAccessor {
    protected elementRef: ElementRef;
    protected eventService: EventService;
    /** Used to generate unique IDs */
    private static count;
    /** The lower bound of our range */
    min: any;
    /** The upper bound of our range */
    max: any;
    /** The interval for our range */
    step: number;
    /** Set the initial value. Available for two way binding */
    value: any;
    /** Base ID for the slider. The min and max labels get IDs `${this.id}-bottom-range` and `${this.id}-top-range` respectively */
    id: string;
    /** Value used to "multiply" the `step` when using arrow keys to select values */
    shiftMultiplier: number;
    /** Set to `true` for a loading slider */
    skeleton: boolean;
    /** Sets the text inside the `label` tag */
    label: string | TemplateRef<any>;
    /** Set to `true` for a slider without arrow key interactions. */
    disableArrowKeys: boolean;
    /** Disables the range visually and functionally */
    disabled: any;
    /** Emits every time a new value is selected */
    valueChange: EventEmitter<number | number[]>;
    hostClass: boolean;
    thumbs: QueryList<ElementRef>;
    track: ElementRef;
    filledTrack: ElementRef;
    range: ElementRef;
    labelId: string;
    bottomRangeId: string;
    topRangeId: string;
    fractionComplete: number;
    protected isMouseDown: boolean;
    protected inputs: HTMLInputElement[];
    protected _min: number;
    protected _max: number;
    protected _value: number[];
    protected _previousValue: number[];
    protected _disabled: boolean;
    protected _focusedThumbIndex: number;
    constructor(elementRef: ElementRef, eventService: EventService);
    ngAfterViewInit(): void;
    trackThumbsBy(index: number, item: any): number;
    /** Send changes back to the model */
    propagateChange: (_: any) => void;
    /** Register a change propagation function for `ControlValueAccessor` */
    registerOnChange(fn: any): void;
    /** Callback to notify the model when our input has been touched */
    onTouched: () => any;
    /** Register a callback to notify when our input has been touched */
    registerOnTouched(fn: any): void;
    /** Receives a value from the model */
    writeValue(v: any): void;
    /**
     * Returns the amount of "completeness" of a value as a fraction of the total track width
     */
    getFractionComplete(value: number): number;
    /** Helper function to return the CSS transform `scaleX` function */
    scaleX(complete: any): string;
    /** Converts a given px value to a "real" value in our range */
    convertToValue(pxAmount: any): number;
    /** Converts a given "real" value to a px value we can update the view with */
    convertToPx(value: any): any;
    /**
     * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    incrementValue(multiplier?: number, index?: number): void;
    /**
     * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    decrementValue(multiplier?: number, index?: number): void;
    /**
     * Determines if the slider is in range mode.
     */
    isRange(): boolean;
    /**
     * Range mode only.
     * Updates the track width to span from the low thumb to the high thumb
     */
    updateTrackRangeWidth(): void;
    /** Change handler for the optional input */
    onChange(event: any, index: any): void;
    /** Handles clicks on the range track, and setting the value to it's "real" equivalent */
    onClick(event: any): void;
    /** Focus handler for the optional input */
    onFocus({ target }: {
        target: any;
    }): void;
    /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */
    onMouseMove(event: any): void;
    /**
     * Enables the `onMouseMove` handler
     *
     * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.
     */
    onMouseDown(event: any, index?: number): void;
    /** Disables the `onMouseMove` handler */
    onMouseUp(): void;
    /**
     * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.
     *
     * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.
     */
    onKeyDown(event: KeyboardEvent, index?: number): void;
    isTemplate(value: any): boolean;
    /** Get optional input fields */
    protected getInputs(): HTMLInputElement[];
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Slider>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<Slider, "ibm-slider", never, {
    "step": "step";
    "id": "id";
    "shiftMultiplier": "shiftMultiplier";
    "skeleton": "skeleton";
    "disableArrowKeys": "disableArrowKeys";
    "min": "min";
    "value": "value";
    "max": "max";
    "disabled": "disabled";
    "label": "label";
}, {
    "valueChange": "valueChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJzbGlkZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1IQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIGNhcmJvbi1hbmd1bGFyIHYwLjAuMCB8IHNsaWRlci5jb21wb25lbnQuZC50c1xuICpcbiAqIENvcHlyaWdodCAyMDE0LCAyMDIxIElCTVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBUZW1wbGF0ZVJlZiwgUXVlcnlMaXN0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBFdmVudFNlcnZpY2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuLyoqXG4gKiBVc2VkIHRvIHNlbGVjdCBmcm9tIHJhbmdlcyBvZiB2YWx1ZXMuIFtTZWUgaGVyZV0oaHR0cHM6Ly93d3cuY2FyYm9uZGVzaWduc3lzdGVtLmNvbS9jb21wb25lbnRzL3NsaWRlci91c2FnZSkgZm9yIHVzYWdlIGluZm9ybWF0aW9uLlxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtc2xpZGVyLS1hZHZhbmNlZClcbiAqXG4gKiBUaGUgc2ltcGxlc3QgcG9zc2libGUgc2xpZGVyIHVzYWdlIGxvb2tzIHNvbWV0aGluZyBsaWtlOlxuICogYGBgaHRtbFxuICogPGlibS1zbGlkZXI+PC9pYm0tc2xpZGVyPlxuICogYGBgXG4gKlxuICogVGhhdCB3aWxsIHJlbmRlciBhIHNsaWRlciB3aXRob3V0IGxhYmVscyBvciBhbHRlcm5hdGl2ZSB2YWx1ZSBpbnB1dC4gTGFiZWxzIGNhbiBiZSBwcm92aWRlZCBieVxuICogZWxlbWVudHMgd2l0aCBgW21pbkxhYmVsXWAgYW5kIGBbbWF4TGFiZWxdYCBhdHRyaWJ1dGVzLCBhbmQgYW4gYGlucHV0YCAobWF5IHVzZSB0aGUgYGlibUlucHV0YCBkaXJlY3RpdmUpIGNhbiBiZSBzdXBwbGllZFxuICogZm9yIHVzZSBhcyBhbiBhbHRlcm5hdGl2ZSB2YWx1ZSBmaWVsZC5cbiAqXG4gKiBleDpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gZnVsbCBleGFtcGxlIC0tPlxuICogPGlibS1zbGlkZXI+XG4gKlx0XHQ8c3BhbiBtaW5MYWJlbD4wR0I8L3NwYW4+XG4gKlx0XHQ8c3BhbiBtYXhMYWJlbD4xMDBHQjwvc3Bhbj5cbiAqXHRcdDxpbnB1dC8+XG4gKlx0PC9pYm0tc2xpZGVyPlxuICogPCEtLSB3aXRoIGp1c3QgYW4gaW5wdXQgLS0+XG4gKiA8aWJtLXNsaWRlcj5cbiAqXHRcdDxpbnB1dC8+XG4gKlx0PC9pYm0tc2xpZGVyPlxuICogPCEtLSB3aXRoIGp1c3Qgb25lIGxhYmVsIC0tPlxuICogPGlibS1zbGlkZXI+XG4gKlx0XHQ8c3BhbiBtYXhMYWJlbD5NYXhpbXVtPC9zcGFuPlxuICpcdDwvaWJtLXNsaWRlcj5cbiAqIGBgYFxuICpcbiAqIFNsaWRlciBzdXBwb3J0cyBgTmdNb2RlbGAgYnkgZGVmYXVsdCwgYXMgd2VsbCBhcyB0d28gd2F5IGJpbmRpbmcgdG8gdGhlIGB2YWx1ZWAgaW5wdXQuXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNvbXBvbmVudHMtc2xpZGVyLS1hZHZhbmNlZDwvZXhhbXBsZS11cmw+XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNsaWRlciBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZjtcbiAgICBwcm90ZWN0ZWQgZXZlbnRTZXJ2aWNlOiBFdmVudFNlcnZpY2U7XG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICAgIHByaXZhdGUgc3RhdGljIGNvdW50O1xuICAgIC8qKiBUaGUgbG93ZXIgYm91bmQgb2Ygb3VyIHJhbmdlICovXG4gICAgbWluOiBhbnk7XG4gICAgLyoqIFRoZSB1cHBlciBib3VuZCBvZiBvdXIgcmFuZ2UgKi9cbiAgICBtYXg6IGFueTtcbiAgICAvKiogVGhlIGludGVydmFsIGZvciBvdXIgcmFuZ2UgKi9cbiAgICBzdGVwOiBudW1iZXI7XG4gICAgLyoqIFNldCB0aGUgaW5pdGlhbCB2YWx1ZS4gQXZhaWxhYmxlIGZvciB0d28gd2F5IGJpbmRpbmcgKi9cbiAgICB2YWx1ZTogYW55O1xuICAgIC8qKiBCYXNlIElEIGZvciB0aGUgc2xpZGVyLiBUaGUgbWluIGFuZCBtYXggbGFiZWxzIGdldCBJRHMgYCR7dGhpcy5pZH0tYm90dG9tLXJhbmdlYCBhbmQgYCR7dGhpcy5pZH0tdG9wLXJhbmdlYCByZXNwZWN0aXZlbHkgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKiBWYWx1ZSB1c2VkIHRvIFwibXVsdGlwbHlcIiB0aGUgYHN0ZXBgIHdoZW4gdXNpbmcgYXJyb3cga2V5cyB0byBzZWxlY3QgdmFsdWVzICovXG4gICAgc2hpZnRNdWx0aXBsaWVyOiBudW1iZXI7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgZm9yIGEgbG9hZGluZyBzbGlkZXIgKi9cbiAgICBza2VsZXRvbjogYm9vbGVhbjtcbiAgICAvKiogU2V0cyB0aGUgdGV4dCBpbnNpZGUgdGhlIGBsYWJlbGAgdGFnICovXG4gICAgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgZm9yIGEgc2xpZGVyIHdpdGhvdXQgYXJyb3cga2V5IGludGVyYWN0aW9ucy4gKi9cbiAgICBkaXNhYmxlQXJyb3dLZXlzOiBib29sZWFuO1xuICAgIC8qKiBEaXNhYmxlcyB0aGUgcmFuZ2UgdmlzdWFsbHkgYW5kIGZ1bmN0aW9uYWxseSAqL1xuICAgIGRpc2FibGVkOiBhbnk7XG4gICAgLyoqIEVtaXRzIGV2ZXJ5IHRpbWUgYSBuZXcgdmFsdWUgaXMgc2VsZWN0ZWQgKi9cbiAgICB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlciB8IG51bWJlcltdPjtcbiAgICBob3N0Q2xhc3M6IGJvb2xlYW47XG4gICAgdGh1bWJzOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG4gICAgdHJhY2s6IEVsZW1lbnRSZWY7XG4gICAgZmlsbGVkVHJhY2s6IEVsZW1lbnRSZWY7XG4gICAgcmFuZ2U6IEVsZW1lbnRSZWY7XG4gICAgbGFiZWxJZDogc3RyaW5nO1xuICAgIGJvdHRvbVJhbmdlSWQ6IHN0cmluZztcbiAgICB0b3BSYW5nZUlkOiBzdHJpbmc7XG4gICAgZnJhY3Rpb25Db21wbGV0ZTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBpc01vdXNlRG93bjogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W107XG4gICAgcHJvdGVjdGVkIF9taW46IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX21heDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfdmFsdWU6IG51bWJlcltdO1xuICAgIHByb3RlY3RlZCBfcHJldmlvdXNWYWx1ZTogbnVtYmVyW107XG4gICAgcHJvdGVjdGVkIF9kaXNhYmxlZDogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgX2ZvY3VzZWRUaHVtYkluZGV4OiBudW1iZXI7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgZXZlbnRTZXJ2aWNlOiBFdmVudFNlcnZpY2UpO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIHRyYWNrVGh1bWJzQnkoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KTogbnVtYmVyO1xuICAgIC8qKiBTZW5kIGNoYW5nZXMgYmFjayB0byB0aGUgbW9kZWwgKi9cbiAgICBwcm9wYWdhdGVDaGFuZ2U6IChfOiBhbnkpID0+IHZvaWQ7XG4gICAgLyoqIFJlZ2lzdGVyIGEgY2hhbmdlIHByb3BhZ2F0aW9uIGZ1bmN0aW9uIGZvciBgQ29udHJvbFZhbHVlQWNjZXNzb3JgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZDtcbiAgICAvKiogQ2FsbGJhY2sgdG8gbm90aWZ5IHRoZSBtb2RlbCB3aGVuIG91ciBpbnB1dCBoYXMgYmVlbiB0b3VjaGVkICovXG4gICAgb25Ub3VjaGVkOiAoKSA9PiBhbnk7XG4gICAgLyoqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gb3VyIGlucHV0IGhhcyBiZWVuIHRvdWNoZWQgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZDtcbiAgICAvKiogUmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBtb2RlbCAqL1xuICAgIHdyaXRlVmFsdWUodjogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgXCJjb21wbGV0ZW5lc3NcIiBvZiBhIHZhbHVlIGFzIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHRyYWNrIHdpZHRoXG4gICAgICovXG4gICAgZ2V0RnJhY3Rpb25Db21wbGV0ZSh2YWx1ZTogbnVtYmVyKTogbnVtYmVyO1xuICAgIC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBDU1MgdHJhbnNmb3JtIGBzY2FsZVhgIGZ1bmN0aW9uICovXG4gICAgc2NhbGVYKGNvbXBsZXRlOiBhbnkpOiBzdHJpbmc7XG4gICAgLyoqIENvbnZlcnRzIGEgZ2l2ZW4gcHggdmFsdWUgdG8gYSBcInJlYWxcIiB2YWx1ZSBpbiBvdXIgcmFuZ2UgKi9cbiAgICBjb252ZXJ0VG9WYWx1ZShweEFtb3VudDogYW55KTogbnVtYmVyO1xuICAgIC8qKiBDb252ZXJ0cyBhIGdpdmVuIFwicmVhbFwiIHZhbHVlIHRvIGEgcHggdmFsdWUgd2UgY2FuIHVwZGF0ZSB0aGUgdmlldyB3aXRoICovXG4gICAgY29udmVydFRvUHgodmFsdWU6IGFueSk6IGFueTtcbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnRzIHRoZSB2YWx1ZSBieSB0aGUgc3RlcCB2YWx1ZSwgb3IgdGhlIHN0ZXAgdmFsdWUgbXVsdGlwbGllZCBieSB0aGUgYG11bHRpcGxpZXJgIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGFyZ3VtZW50IG11bHRpcGxpZXIgRGVmYXVsdHMgdG8gYDFgLCBtdWx0aXBsaWVkIHdpdGggdGhlIHN0ZXAgdmFsdWUuXG4gICAgICovXG4gICAgaW5jcmVtZW50VmFsdWUobXVsdGlwbGllcj86IG51bWJlciwgaW5kZXg/OiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERlY3JlbWVudHMgdGhlIHZhbHVlIGJ5IHRoZSBzdGVwIHZhbHVlLCBvciB0aGUgc3RlcCB2YWx1ZSBtdWx0aXBsaWVkIGJ5IHRoZSBgbXVsdGlwbGllcmAgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAYXJndW1lbnQgbXVsdGlwbGllciBEZWZhdWx0cyB0byBgMWAsIG11bHRpcGxpZWQgd2l0aCB0aGUgc3RlcCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkZWNyZW1lbnRWYWx1ZShtdWx0aXBsaWVyPzogbnVtYmVyLCBpbmRleD86IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgc2xpZGVyIGlzIGluIHJhbmdlIG1vZGUuXG4gICAgICovXG4gICAgaXNSYW5nZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJhbmdlIG1vZGUgb25seS5cbiAgICAgKiBVcGRhdGVzIHRoZSB0cmFjayB3aWR0aCB0byBzcGFuIGZyb20gdGhlIGxvdyB0aHVtYiB0byB0aGUgaGlnaCB0aHVtYlxuICAgICAqL1xuICAgIHVwZGF0ZVRyYWNrUmFuZ2VXaWR0aCgpOiB2b2lkO1xuICAgIC8qKiBDaGFuZ2UgaGFuZGxlciBmb3IgdGhlIG9wdGlvbmFsIGlucHV0ICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSwgaW5kZXg6IGFueSk6IHZvaWQ7XG4gICAgLyoqIEhhbmRsZXMgY2xpY2tzIG9uIHRoZSByYW5nZSB0cmFjaywgYW5kIHNldHRpbmcgdGhlIHZhbHVlIHRvIGl0J3MgXCJyZWFsXCIgZXF1aXZhbGVudCAqL1xuICAgIG9uQ2xpY2soZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqIEZvY3VzIGhhbmRsZXIgZm9yIHRoZSBvcHRpb25hbCBpbnB1dCAqL1xuICAgIG9uRm9jdXMoeyB0YXJnZXQgfToge1xuICAgICAgICB0YXJnZXQ6IGFueTtcbiAgICB9KTogdm9pZDtcbiAgICAvKiogTW91c2UgbW92ZSBoYW5kbGVyLiBSZXNwb25zaWJsZSBmb3IgdXBkYXRpbmcgdGhlIHZhbHVlIGFuZCB2aXN1YWwgc2VsZWN0aW9uIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50ICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgYG9uTW91c2VNb3ZlYCBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRodW1iIElmIHRydWUgdGhlbiBgdGh1bWJgIGlzIGNsaWNrZWQgZG93biwgb3RoZXJ3aXNlIGB0aHVtYjJgIGlzIGNsaWNrZWQgZG93bi5cbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudDogYW55LCBpbmRleD86IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqIERpc2FibGVzIHRoZSBgb25Nb3VzZU1vdmVgIGhhbmRsZXIgKi9cbiAgICBvbk1vdXNlVXAoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxscyBgaW5jcmVtZW50VmFsdWVgIGZvciBBcnJvd1JpZ2h0IGFuZCBBcnJvd1VwLCBgZGVjcmVtZW50VmFsdWVgIGZvciBBcnJvd0xlZnQgYW5kIEFycm93RG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdGh1bWIgSWYgdHJ1ZSB0aGVuIGB0aHVtYmAgaXMgcHJlc3NlZCBkb3duLCBvdGhlcndpc2UgYHRodW1iMmAgaXMgcHJlc3NlZCBkb3duLlxuICAgICAqL1xuICAgIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgaW5kZXg/OiBudW1iZXIpOiB2b2lkO1xuICAgIGlzVGVtcGxhdGUodmFsdWU6IGFueSk6IGJvb2xlYW47XG4gICAgLyoqIEdldCBvcHRpb25hbCBpbnB1dCBmaWVsZHMgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0SW5wdXRzKCk6IEhUTUxJbnB1dEVsZW1lbnRbXTtcbn1cbiJdfQ==