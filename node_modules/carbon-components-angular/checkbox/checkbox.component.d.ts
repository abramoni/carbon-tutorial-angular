/**
 *
 * carbon-angular v0.0.0 | checkbox.component.d.ts
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { AfterViewInit, ChangeDetectorRef, ElementRef, EventEmitter } from "@angular/core";
import { ControlValueAccessor } from "@angular/forms";
import { CheckboxValue } from "./checkbox.types";
/**
 * Defines the set of states for a checkbox component.
 */
import * as ɵngcc0 from '@angular/core';
export declare enum CheckboxState {
    Init = 0,
    Indeterminate = 1,
    Checked = 2,
    Unchecked = 3
}
/**
 * Used to emit changes performed on checkbox components.
 *
 * @deprecated since v4
 */
export declare class CheckboxChange {
    /**
     * Contains the `Checkbox` that has been changed.
     */
    source: Checkbox;
    /**
     * The state of the `Checkbox` encompassed in the `CheckboxChange` class.
     */
    checked: boolean;
}
/**
 * [See demo](../../?path=/story/components-checkbox--basic)
 *
 * <example-url>../../iframe.html?id=components-checkbox--basic</example-url>
 */
export declare class Checkbox implements ControlValueAccessor, AfterViewInit {
    protected changeDetectorRef: ChangeDetectorRef;
    /**
     * Variable used for creating unique ids for checkbox components.
     */
    static checkboxCount: number;
    /**
     * Size of the checkbox.
     *
     * @deprecated since v4
     */
    size: "sm" | "md";
    /**
     * Set to `true` for checkbox to be rendered with nested styles.
     *
     * @deprecated since v4
     */
    nested: boolean;
    /**
     * Set to `true` for checkbox to be rendered without any classes on the host element.
     */
    inline: boolean;
    /**
     * Set to `true` for a disabled checkbox.
     */
    disabled: boolean;
    /**
     * Set to `true` for a loading checkbox.
     */
    skeleton: boolean;
    /**
     * Set to `true` to hide the checkbox labels.
     */
    hideLabel: boolean;
    /**
     * Sets the name attribute on the `input` element.
     */
    name: string;
    /**
     * The unique id for the checkbox component.
     */
    id: string;
    /**
     * Reflects the required attribute of the `input` element.
     */
    required: boolean;
    /**
     * Sets the value attribute on the `input` element.
     */
    value: CheckboxValue;
    /**
     * Used to set the `aria-label` attribute on the input element.
     *
     * @deprecated since v4 use the `ariaLabel` input instead
     */
    ariaLabel: string;
    _ariaLabel: string;
    /**
     * Used to set the `aria-labelledby` attribute on the input element.
     *
     * @deprecated since v4 use the `ariaLabelledby` input instead
     */
    ariaLabelledby: string;
    _ariaLabelledby: string;
    /**
     * Set the checkbox's indeterminate state to match the parameter and transition the view to reflect the change.
     *
     * Allows double binding with the `indeterminateChange` Output.
     */
    /**
    * Reflects whether the checkbox state is indeterminate.
    */
    indeterminate: boolean;
    /**
     * Sets the `checked` state. `true` for checked, `false` for unchecked
     *
     * Allows double binding with the `checkedChange` Output.
     */
    /**
    * Returns value `true` if state is selected for the checkbox.
    */
    checked: boolean;
    /**
     * Emits click event.
     */
    click: EventEmitter<void>;
    /**
     * Emits event notifying other classes when a change in state occurs on a checkbox after a
     * click.
     *
     * @deprecated since v4 use `checked` and `checkedChange` instead
     */
    change: EventEmitter<any>;
    /**
     * Emits an event when the value of the checkbox changes.
     *
     * Allows double biding with the `checked` Input.
     */
    checkedChange: EventEmitter<boolean>;
    /**
     * Emits event notifying other classes when a change in state occurs specifically
     * on an indeterminate checkbox.
     */
    indeterminateChange: EventEmitter<boolean>;
    /**
     * Set to `true` if the input checkbox is selected (or checked).
     */
    _checked: boolean;
    /**
     * Set to `true` if the input checkbox is in state indeterminate.
     */
    _indeterminate: boolean;
    /**
     * Keeps a reference to the checkboxes current state, as defined in `CheckboxState`.
     */
    currentCheckboxState: CheckboxState;
    /**
     * Maintains a reference to the view DOM element of the `Checkbox`.
     */
    inputCheckbox: ElementRef;
    /**
     * Creates an instance of `Checkbox`.
     */
    constructor(changeDetectorRef: ChangeDetectorRef);
    /**
     * Toggle the selected state of the checkbox.
     */
    toggle(): void;
    /**
     * Writes a value from `ngModel` to the component.
     *
     * In this case the value is the `checked` property.
     *
     * @param value boolean, corresponds to the `checked` property.
     */
    writeValue(value: any): void;
    /**
     * Sets a method in order to propagate changes back to the form.
     */
    registerOnChange(fn: any): void;
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    registerOnTouched(fn: any): void;
    /**
     * `ControlValueAccessor` method to programmatically disable the checkbox.
     *
     * ex: `this.formGroup.get("myCheckbox").disable();`
     *
     * @param isDisabled `true` to disable the checkbox
     */
    setDisabledState(isDisabled: boolean): void;
    focusOut(): void;
    /**
     * Executes on the event of a change within `Checkbox` to block propagation.
     */
    onChange(event: Event): void;
    /**
     * Handles click events on the `Checkbox` and emits changes to other classes.
     */
    onClick(event: Event): void;
    /**
     * Called when checkbox is blurred. Needed to properly implement `ControlValueAccessor`.
     */
    onTouched: () => any;
    /**
     * Handles changes between checkbox states.
     */
    transitionCheckboxState(newState: CheckboxState): void;
    /**
     * Creates instance of `CheckboxChange` used to propagate the change event.
     */
    emitChangeEvent(): void;
    /**
     * Updates the checkbox if it is in the indeterminate state.
     */
    ngAfterViewInit(): void;
    /**
     * Method set in `registerOnChange` to propagate changes back to the form.
     */
    propagateChange: (_: any) => void;
    /**
     * Sets checked state and optionally resets indeterminate state.
     */
    private setChecked;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Checkbox>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<Checkbox, "ibm-checkbox", never, {
    "size": "size";
    "inline": "inline";
    "disabled": "disabled";
    "skeleton": "skeleton";
    "hideLabel": "hideLabel";
    "id": "id";
    "_ariaLabel": "ariaLabel";
    "ariaLabel": "aria-label";
    "ariaLabelledby": "aria-labelledby";
    "_ariaLabelledby": "ariaLabelledby";
    "indeterminate": "indeterminate";
    "checked": "checked";
    "nested": "nested";
    "name": "name";
    "required": "required";
    "value": "value";
}, {
    "click": "click";
    "change": "change";
    "checkedChange": "checkedChange";
    "indeterminateChange": "indeterminateChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3guY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNoZWNrYm94LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb05BIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY2FyYm9uLWFuZ3VsYXIgdjAuMC4wIHwgY2hlY2tib3guY29tcG9uZW50LmQudHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCwgMjAyMSBJQk1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IENoZWNrYm94VmFsdWUgfSBmcm9tIFwiLi9jaGVja2JveC50eXBlc1wiO1xuLyoqXG4gKiBEZWZpbmVzIHRoZSBzZXQgb2Ygc3RhdGVzIGZvciBhIGNoZWNrYm94IGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZW51bSBDaGVja2JveFN0YXRlIHtcbiAgICBJbml0ID0gMCxcbiAgICBJbmRldGVybWluYXRlID0gMSxcbiAgICBDaGVja2VkID0gMixcbiAgICBVbmNoZWNrZWQgPSAzXG59XG4vKipcbiAqIFVzZWQgdG8gZW1pdCBjaGFuZ2VzIHBlcmZvcm1lZCBvbiBjaGVja2JveCBjb21wb25lbnRzLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENoZWNrYm94Q2hhbmdlIHtcbiAgICAvKipcbiAgICAgKiBDb250YWlucyB0aGUgYENoZWNrYm94YCB0aGF0IGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICovXG4gICAgc291cmNlOiBDaGVja2JveDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdGUgb2YgdGhlIGBDaGVja2JveGAgZW5jb21wYXNzZWQgaW4gdGhlIGBDaGVja2JveENoYW5nZWAgY2xhc3MuXG4gICAgICovXG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbn1cbi8qKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1jaGVja2JveC0tYmFzaWMpXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNvbXBvbmVudHMtY2hlY2tib3gtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ2hlY2tib3ggaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgcHJvdGVjdGVkIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSB1c2VkIGZvciBjcmVhdGluZyB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjaGVja2JveENvdW50OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgY2hlY2tib3guXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NFxuICAgICAqL1xuICAgIHNpemU6IFwic21cIiB8IFwibWRcIjtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBjaGVja2JveCB0byBiZSByZW5kZXJlZCB3aXRoIG5lc3RlZCBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NFxuICAgICAqL1xuICAgIG5lc3RlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBjaGVja2JveCB0byBiZSByZW5kZXJlZCB3aXRob3V0IGFueSBjbGFzc2VzIG9uIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICovXG4gICAgaW5saW5lOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgZm9yIGEgZGlzYWJsZWQgY2hlY2tib3guXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIGNoZWNrYm94LlxuICAgICAqL1xuICAgIHNrZWxldG9uOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gaGlkZSB0aGUgY2hlY2tib3ggbGFiZWxzLlxuICAgICAqL1xuICAgIGhpZGVMYWJlbDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuYW1lIGF0dHJpYnV0ZSBvbiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIGlkIGZvciB0aGUgY2hlY2tib3ggY29tcG9uZW50LlxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUmVmbGVjdHMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvbiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgICAqL1xuICAgIHZhbHVlOiBDaGVja2JveFZhbHVlO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2V0IHRoZSBgYXJpYS1sYWJlbGAgYXR0cmlidXRlIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdjQgdXNlIHRoZSBgYXJpYUxhYmVsYCBpbnB1dCBpbnN0ZWFkXG4gICAgICovXG4gICAgYXJpYUxhYmVsOiBzdHJpbmc7XG4gICAgX2FyaWFMYWJlbDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2V0IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NCB1c2UgdGhlIGBhcmlhTGFiZWxsZWRieWAgaW5wdXQgaW5zdGVhZFxuICAgICAqL1xuICAgIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmc7XG4gICAgX2FyaWFMYWJlbGxlZGJ5OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjaGVja2JveCdzIGluZGV0ZXJtaW5hdGUgc3RhdGUgdG8gbWF0Y2ggdGhlIHBhcmFtZXRlciBhbmQgdHJhbnNpdGlvbiB0aGUgdmlldyB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBBbGxvd3MgZG91YmxlIGJpbmRpbmcgd2l0aCB0aGUgYGluZGV0ZXJtaW5hdGVDaGFuZ2VgIE91dHB1dC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAqIFJlZmxlY3RzIHdoZXRoZXIgdGhlIGNoZWNrYm94IHN0YXRlIGlzIGluZGV0ZXJtaW5hdGUuXG4gICAgKi9cbiAgICBpbmRldGVybWluYXRlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGBjaGVja2VkYCBzdGF0ZS4gYHRydWVgIGZvciBjaGVja2VkLCBgZmFsc2VgIGZvciB1bmNoZWNrZWRcbiAgICAgKlxuICAgICAqIEFsbG93cyBkb3VibGUgYmluZGluZyB3aXRoIHRoZSBgY2hlY2tlZENoYW5nZWAgT3V0cHV0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICogUmV0dXJucyB2YWx1ZSBgdHJ1ZWAgaWYgc3RhdGUgaXMgc2VsZWN0ZWQgZm9yIHRoZSBjaGVja2JveC5cbiAgICAqL1xuICAgIGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW1pdHMgY2xpY2sgZXZlbnQuXG4gICAgICovXG4gICAgY2xpY2s6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBldmVudCBub3RpZnlpbmcgb3RoZXIgY2xhc3NlcyB3aGVuIGEgY2hhbmdlIGluIHN0YXRlIG9jY3VycyBvbiBhIGNoZWNrYm94IGFmdGVyIGFcbiAgICAgKiBjbGljay5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY0IHVzZSBgY2hlY2tlZGAgYW5kIGBjaGVja2VkQ2hhbmdlYCBpbnN0ZWFkXG4gICAgICovXG4gICAgY2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgY2hlY2tib3ggY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEFsbG93cyBkb3VibGUgYmlkaW5nIHdpdGggdGhlIGBjaGVja2VkYCBJbnB1dC5cbiAgICAgKi9cbiAgICBjaGVja2VkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogRW1pdHMgZXZlbnQgbm90aWZ5aW5nIG90aGVyIGNsYXNzZXMgd2hlbiBhIGNoYW5nZSBpbiBzdGF0ZSBvY2N1cnMgc3BlY2lmaWNhbGx5XG4gICAgICogb24gYW4gaW5kZXRlcm1pbmF0ZSBjaGVja2JveC5cbiAgICAgKi9cbiAgICBpbmRldGVybWluYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCBpZiB0aGUgaW5wdXQgY2hlY2tib3ggaXMgc2VsZWN0ZWQgKG9yIGNoZWNrZWQpLlxuICAgICAqL1xuICAgIF9jaGVja2VkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgaWYgdGhlIGlucHV0IGNoZWNrYm94IGlzIGluIHN0YXRlIGluZGV0ZXJtaW5hdGUuXG4gICAgICovXG4gICAgX2luZGV0ZXJtaW5hdGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogS2VlcHMgYSByZWZlcmVuY2UgdG8gdGhlIGNoZWNrYm94ZXMgY3VycmVudCBzdGF0ZSwgYXMgZGVmaW5lZCBpbiBgQ2hlY2tib3hTdGF0ZWAuXG4gICAgICovXG4gICAgY3VycmVudENoZWNrYm94U3RhdGU6IENoZWNrYm94U3RhdGU7XG4gICAgLyoqXG4gICAgICogTWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3IERPTSBlbGVtZW50IG9mIHRoZSBgQ2hlY2tib3hgLlxuICAgICAqL1xuICAgIGlucHV0Q2hlY2tib3g6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgQ2hlY2tib3hgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgY2hlY2tib3guXG4gICAgICovXG4gICAgdG9nZ2xlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgdmFsdWUgZnJvbSBgbmdNb2RlbGAgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgY2FzZSB0aGUgdmFsdWUgaXMgdGhlIGBjaGVja2VkYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBib29sZWFuLCBjb3JyZXNwb25kcyB0byB0aGUgYGNoZWNrZWRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1ldGhvZCBpbiBvcmRlciB0byBwcm9wYWdhdGUgY2hhbmdlcyBiYWNrIHRvIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRyb2wgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNoZWNrYm94IGlzIHRvdWNoZWQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBtZXRob2QgdG8gcHJvZ3JhbW1hdGljYWxseSBkaXNhYmxlIHRoZSBjaGVja2JveC5cbiAgICAgKlxuICAgICAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlDaGVja2JveFwiKS5kaXNhYmxlKCk7YFxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWQgYHRydWVgIHRvIGRpc2FibGUgdGhlIGNoZWNrYm94XG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICBmb2N1c091dCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIG9uIHRoZSBldmVudCBvZiBhIGNoYW5nZSB3aXRoaW4gYENoZWNrYm94YCB0byBibG9jayBwcm9wYWdhdGlvbi5cbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudDogRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgY2xpY2sgZXZlbnRzIG9uIHRoZSBgQ2hlY2tib3hgIGFuZCBlbWl0cyBjaGFuZ2VzIHRvIG90aGVyIGNsYXNzZXMuXG4gICAgICovXG4gICAgb25DbGljayhldmVudDogRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoZWNrYm94IGlzIGJsdXJyZWQuIE5lZWRlZCB0byBwcm9wZXJseSBpbXBsZW1lbnQgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYC5cbiAgICAgKi9cbiAgICBvblRvdWNoZWQ6ICgpID0+IGFueTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZXMgYmV0d2VlbiBjaGVja2JveCBzdGF0ZXMuXG4gICAgICovXG4gICAgdHJhbnNpdGlvbkNoZWNrYm94U3RhdGUobmV3U3RhdGU6IENoZWNrYm94U3RhdGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgYENoZWNrYm94Q2hhbmdlYCB1c2VkIHRvIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAqL1xuICAgIGVtaXRDaGFuZ2VFdmVudCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNoZWNrYm94IGlmIGl0IGlzIGluIHRoZSBpbmRldGVybWluYXRlIHN0YXRlLlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCBzZXQgaW4gYHJlZ2lzdGVyT25DaGFuZ2VgIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzIGJhY2sgdG8gdGhlIGZvcm0uXG4gICAgICovXG4gICAgcHJvcGFnYXRlQ2hhbmdlOiAoXzogYW55KSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNldHMgY2hlY2tlZCBzdGF0ZSBhbmQgb3B0aW9uYWxseSByZXNldHMgaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNldENoZWNrZWQ7XG59XG4iXX0=