/**
 *
 * carbon-angular v0.0.0 | modal.component.d.ts
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { ModalService } from "./modal.service";
import { AfterViewInit, EventEmitter, ElementRef, SimpleChanges, OnChanges } from "@angular/core";
/**
 * Component to create modals for presenting content.
 *
 * [See demo](../../?path=/story/components-modal--basic)
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
```html
<ibm-placeholder></ibm-placeholder>
```
 *
 * A more complete example for `Modal` is given as follows:
 *
 * Example modal definition:
 *
```typescript
@Component({
    selector: "app-sample-modal",
    template: `
                <ibm-modal size="xl" (overlaySelected)="closeModal()">
                    <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
                        <section class="modal-body">
                            <h1>Sample modal works.</h1>
                            <button class="btn--icon-link" nPopover="Hello there" title="Popover title" placement="right" appendInline="true">
                                <svg ibmIcon="info" size="sm"></svg>
                            </button>
                            {{modalText}}
                        </section>
                    <ibm-modal-footer><button ibmButton="primary" (click)="closeModal()">Close</button></ibm-modal-footer>
                </ibm-modal>`,
    styleUrls: ["./sample-modal.component.scss"]
})
export class SampleModal extends BaseModal {
    modalText: string;
    constructor(protected injector: Injector) {
        super();
        this.modalText = this.injector.get("modalText");
    }
}
```
 *
 * Example of opening the modal:
 *
```typescript
@Component({
    selector: "app-modal-demo",
    template: `
                <button ibmButton="primary" (click)="openModal('drill')">Drill-down modal</button>
                <ibm-placeholder></ibm-placeholder>`
})
export class ModalDemo {
    openModal() {
        this.modalService.create({component: SampleModal, inputs: {modalText: "Hello universe."}});
    }
}
```
 *
 * <example-url>../../iframe.html?id=components-modal--basic</example-url>
 */
import * as ɵngcc0 from '@angular/core';
export declare class Modal implements AfterViewInit, OnChanges {
    modalService: ModalService;
    /**
     * Size of the modal to display.
     */
    size: "xs" | "sm" | "lg";
    /**
     * Classification of the modal.
     */
    theme: "default" | "danger";
    /**
     * Label for the modal.
     *
     * @deprecated since v4
     */
    modalLabel: string;
    ariaLabel: string;
    /**
     * Controls the visibility of the modal when used directly in a template
     */
    open: boolean;
    /**
     * The element that triggers the modal, which should receive focus when the modal closes
     */
    trigger: HTMLElement;
    /**
     * Specify whether the modal contains scrolling content. This property overrides the automatic
     * detection of the existence of scrolling content. Set this property to `true` to force
     * overflow indicator to show up or to `false` to force overflow indicator to disappear.
     * It is set to `null` by default which indicates not to override automatic detection.
     */
    hasScrollingContent: boolean;
    /**
     * Emits event when click occurs within `n-overlay` element. This is to track click events occurring outside bounds of the `Modal` object.
     */
    overlaySelected: EventEmitter<{}>;
    /**
     * To emit the closing event of the modal window.
     */
    close: EventEmitter<{}>;
    /**
     * Maintains a reference to the view DOM element of the `Modal`.
     */
    modal: ElementRef;
    /**
     * An element should have 'modal-primary-focus' as an attribute to receive initial focus within the `Modal` component.
     */
    selectorPrimaryFocus: string;
    /**
     * Creates an instance of `Modal`.
     */
    constructor(modalService: ModalService);
    ngOnChanges({ open }: SimpleChanges): void;
    /**
     * Set document focus to be on the modal component after it is initialized.
     */
    ngAfterViewInit(): void;
    /**
     * Handle keyboard events to close modal and tab through the content within the modal.
     */
    handleKeyboardEvent(event: KeyboardEvent): void;
    /**
     * This detects whether or not the modal contains scrolling content.
     *
     * To force trigger a detection (ie. on window resize), change or reset the value of the modal content.
     *
     * Use the `hasScrollingContent` input to manually override the overflow indicator.
     */
    readonly shouldShowScrollbar: boolean;
    protected focusInitialElement(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Modal>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<Modal, "ibm-modal", never, {
    "theme": "theme";
    "ariaLabel": "ariaLabel";
    "open": "open";
    "hasScrollingContent": "hasScrollingContent";
    "modalLabel": "modalLabel";
    "size": "size";
    "trigger": "trigger";
}, {
    "overlaySelected": "overlaySelected";
    "close": "close";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kYWwuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbIm1vZGFsLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzRUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBjYXJib24tYW5ndWxhciB2MC4wLjAgfCBtb2RhbC5jb21wb25lbnQuZC50c1xuICpcbiAqIENvcHlyaWdodCAyMDE0LCAyMDIxIElCTVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuaW1wb3J0IHsgTW9kYWxTZXJ2aWNlIH0gZnJvbSBcIi4vbW9kYWwuc2VydmljZVwiO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBTaW1wbGVDaGFuZ2VzLCBPbkNoYW5nZXMgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuLyoqXG4gKiBDb21wb25lbnQgdG8gY3JlYXRlIG1vZGFscyBmb3IgcHJlc2VudGluZyBjb250ZW50LlxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtbW9kYWwtLWJhc2ljKVxuICpcbiAqIFVzaW5nIGEgbW9kYWwgaW4geW91ciBhcHBsaWNhdGlvbiByZXF1aXJlcyBgaWJtLXBsYWNlaG9sZGVyYCB3aGljaCB3b3VsZCBnZW5lcmFsbHkgYmVcbiAqIHBsYWNlZCBuZWFyIHRoZSBlbmQgb2YgeW91ciBhcHAgY29tcG9uZW50IHRlbXBsYXRlIChhcHAuY29tcG9uZW50LnRzIG9yIGFwcC5jb21wb25lbnQuaHRtbCkgYXM6XG4gKlxuYGBgaHRtbFxuPGlibS1wbGFjZWhvbGRlcj48L2libS1wbGFjZWhvbGRlcj5cbmBgYFxuICpcbiAqIEEgbW9yZSBjb21wbGV0ZSBleGFtcGxlIGZvciBgTW9kYWxgIGlzIGdpdmVuIGFzIGZvbGxvd3M6XG4gKlxuICogRXhhbXBsZSBtb2RhbCBkZWZpbml0aW9uOlxuICpcbmBgYHR5cGVzY3JpcHRcbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImFwcC1zYW1wbGUtbW9kYWxcIixcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgICAgIDxpYm0tbW9kYWwgc2l6ZT1cInhsXCIgKG92ZXJsYXlTZWxlY3RlZCk9XCJjbG9zZU1vZGFsKClcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlibS1tb2RhbC1oZWFkZXIgKGNsb3NlU2VsZWN0KT1cImNsb3NlTW9kYWwoKVwiPkhlYWRlciB0ZXh0PC9pYm0tbW9kYWwtaGVhZGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgxPlNhbXBsZSBtb2RhbCB3b3Jrcy48L2gxPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4tLWljb24tbGlua1wiIG5Qb3BvdmVyPVwiSGVsbG8gdGhlcmVcIiB0aXRsZT1cIlBvcG92ZXIgdGl0bGVcIiBwbGFjZW1lbnQ9XCJyaWdodFwiIGFwcGVuZElubGluZT1cInRydWVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyBpYm1JY29uPVwiaW5mb1wiIHNpemU9XCJzbVwiPjwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bW9kYWxUZXh0fX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPGlibS1tb2RhbC1mb290ZXI+PGJ1dHRvbiBpYm1CdXR0b249XCJwcmltYXJ5XCIgKGNsaWNrKT1cImNsb3NlTW9kYWwoKVwiPkNsb3NlPC9idXR0b24+PC9pYm0tbW9kYWwtZm9vdGVyPlxuICAgICAgICAgICAgICAgIDwvaWJtLW1vZGFsPmAsXG4gICAgc3R5bGVVcmxzOiBbXCIuL3NhbXBsZS1tb2RhbC5jb21wb25lbnQuc2Nzc1wiXVxufSlcbmV4cG9ydCBjbGFzcyBTYW1wbGVNb2RhbCBleHRlbmRzIEJhc2VNb2RhbCB7XG4gICAgbW9kYWxUZXh0OiBzdHJpbmc7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1vZGFsVGV4dCA9IHRoaXMuaW5qZWN0b3IuZ2V0KFwibW9kYWxUZXh0XCIpO1xuICAgIH1cbn1cbmBgYFxuICpcbiAqIEV4YW1wbGUgb2Ygb3BlbmluZyB0aGUgbW9kYWw6XG4gKlxuYGBgdHlwZXNjcmlwdFxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IFwiYXBwLW1vZGFsLWRlbW9cIixcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgICAgIDxidXR0b24gaWJtQnV0dG9uPVwicHJpbWFyeVwiIChjbGljayk9XCJvcGVuTW9kYWwoJ2RyaWxsJylcIj5EcmlsbC1kb3duIG1vZGFsPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGlibS1wbGFjZWhvbGRlcj48L2libS1wbGFjZWhvbGRlcj5gXG59KVxuZXhwb3J0IGNsYXNzIE1vZGFsRGVtbyB7XG4gICAgb3Blbk1vZGFsKCkge1xuICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5jcmVhdGUoe2NvbXBvbmVudDogU2FtcGxlTW9kYWwsIGlucHV0czoge21vZGFsVGV4dDogXCJIZWxsbyB1bml2ZXJzZS5cIn19KTtcbiAgICB9XG59XG5gYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9Y29tcG9uZW50cy1tb2RhbC0tYmFzaWM8L2V4YW1wbGUtdXJsPlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNb2RhbCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcyB7XG4gICAgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2U7XG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgbW9kYWwgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBzaXplOiBcInhzXCIgfCBcInNtXCIgfCBcImxnXCI7XG4gICAgLyoqXG4gICAgICogQ2xhc3NpZmljYXRpb24gb2YgdGhlIG1vZGFsLlxuICAgICAqL1xuICAgIHRoZW1lOiBcImRlZmF1bHRcIiB8IFwiZGFuZ2VyXCI7XG4gICAgLyoqXG4gICAgICogTGFiZWwgZm9yIHRoZSBtb2RhbC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG4gICAgICovXG4gICAgbW9kYWxMYWJlbDogc3RyaW5nO1xuICAgIGFyaWFMYWJlbDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBtb2RhbCB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYSB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIG9wZW46IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCB0cmlnZ2VycyB0aGUgbW9kYWwsIHdoaWNoIHNob3VsZCByZWNlaXZlIGZvY3VzIHdoZW4gdGhlIG1vZGFsIGNsb3Nlc1xuICAgICAqL1xuICAgIHRyaWdnZXI6IEhUTUxFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0aGUgbW9kYWwgY29udGFpbnMgc2Nyb2xsaW5nIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgb3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWNcbiAgICAgKiBkZXRlY3Rpb24gb2YgdGhlIGV4aXN0ZW5jZSBvZiBzY3JvbGxpbmcgY29udGVudC4gU2V0IHRoaXMgcHJvcGVydHkgdG8gYHRydWVgIHRvIGZvcmNlXG4gICAgICogb3ZlcmZsb3cgaW5kaWNhdG9yIHRvIHNob3cgdXAgb3IgdG8gYGZhbHNlYCB0byBmb3JjZSBvdmVyZmxvdyBpbmRpY2F0b3IgdG8gZGlzYXBwZWFyLlxuICAgICAqIEl0IGlzIHNldCB0byBgbnVsbGAgYnkgZGVmYXVsdCB3aGljaCBpbmRpY2F0ZXMgbm90IHRvIG92ZXJyaWRlIGF1dG9tYXRpYyBkZXRlY3Rpb24uXG4gICAgICovXG4gICAgaGFzU2Nyb2xsaW5nQ29udGVudDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBldmVudCB3aGVuIGNsaWNrIG9jY3VycyB3aXRoaW4gYG4tb3ZlcmxheWAgZWxlbWVudC4gVGhpcyBpcyB0byB0cmFjayBjbGljayBldmVudHMgb2NjdXJyaW5nIG91dHNpZGUgYm91bmRzIG9mIHRoZSBgTW9kYWxgIG9iamVjdC5cbiAgICAgKi9cbiAgICBvdmVybGF5U2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjx7fT47XG4gICAgLyoqXG4gICAgICogVG8gZW1pdCB0aGUgY2xvc2luZyBldmVudCBvZiB0aGUgbW9kYWwgd2luZG93LlxuICAgICAqL1xuICAgIGNsb3NlOiBFdmVudEVtaXR0ZXI8e30+O1xuICAgIC8qKlxuICAgICAqIE1haW50YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgdmlldyBET00gZWxlbWVudCBvZiB0aGUgYE1vZGFsYC5cbiAgICAgKi9cbiAgICBtb2RhbDogRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBBbiBlbGVtZW50IHNob3VsZCBoYXZlICdtb2RhbC1wcmltYXJ5LWZvY3VzJyBhcyBhbiBhdHRyaWJ1dGUgdG8gcmVjZWl2ZSBpbml0aWFsIGZvY3VzIHdpdGhpbiB0aGUgYE1vZGFsYCBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2VsZWN0b3JQcmltYXJ5Rm9jdXM6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNb2RhbGAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpO1xuICAgIG5nT25DaGFuZ2VzKHsgb3BlbiB9OiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZXQgZG9jdW1lbnQgZm9jdXMgdG8gYmUgb24gdGhlIG1vZGFsIGNvbXBvbmVudCBhZnRlciBpdCBpcyBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUga2V5Ym9hcmQgZXZlbnRzIHRvIGNsb3NlIG1vZGFsIGFuZCB0YWIgdGhyb3VnaCB0aGUgY29udGVudCB3aXRoaW4gdGhlIG1vZGFsLlxuICAgICAqL1xuICAgIGhhbmRsZUtleWJvYXJkRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZGV0ZWN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgbW9kYWwgY29udGFpbnMgc2Nyb2xsaW5nIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBUbyBmb3JjZSB0cmlnZ2VyIGEgZGV0ZWN0aW9uIChpZS4gb24gd2luZG93IHJlc2l6ZSksIGNoYW5nZSBvciByZXNldCB0aGUgdmFsdWUgb2YgdGhlIG1vZGFsIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhlIGBoYXNTY3JvbGxpbmdDb250ZW50YCBpbnB1dCB0byBtYW51YWxseSBvdmVycmlkZSB0aGUgb3ZlcmZsb3cgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNob3VsZFNob3dTY3JvbGxiYXI6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGZvY3VzSW5pdGlhbEVsZW1lbnQoKTogdm9pZDtcbn1cbiJdfQ==